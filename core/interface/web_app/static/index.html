<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jotty - AI Assistant</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ¤–</text></svg>">
    <style>
/* Jotty Web UI - LibreChat-inspired Design */
:root {
    --bg-primary: #0d0d0d;
    --bg-secondary: #171717;
    --bg-tertiary: #212121;
    --bg-hover: #2a2a2a;
    --bg-input: #1e1e1e;
    --text-primary: #e5e5e5;
    --text-secondary: #a1a1a1;
    --text-muted: #6b6b6b;
    --accent: #10a37f;
    --accent-hover: #0d8c6d;
    --border-color: #2d2d2d;
    --error: #ef4444;
    --success: #10a37f;
    --code-bg: #1a1a1a;
    --scrollbar-thumb: #4a4a4a;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body { height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background: var(--bg-primary); color: var(--text-primary); overflow: hidden; }
.app-container { display: flex; height: 100vh; }
.sidebar { width: 260px; background: var(--bg-secondary); border-right: 1px solid var(--border-color); display: flex; flex-direction: column; transition: transform 0.3s ease; }
.sidebar.hidden { transform: translateX(-100%); position: absolute; }
.sidebar-header { padding: 16px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 8px; }
.new-chat-btn { flex: 1; padding: 12px 16px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; cursor: pointer; display: flex; align-items: center; gap: 8px; transition: background 0.2s; }
.new-chat-btn:hover { background: var(--bg-hover); }
.new-chat-btn svg { width: 16px; height: 16px; }
.sidebar-close-btn { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: transparent; border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-secondary); cursor: pointer; transition: all 0.2s; flex-shrink: 0; }
.sidebar-close-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
.sidebar-close-btn svg { width: 16px; height: 16px; }
.sessions-list { flex: 1; overflow-y: auto; padding: 8px; }
.sessions-list::-webkit-scrollbar { width: 6px; }
.sessions-list::-webkit-scrollbar-track { background: transparent; }
.sessions-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }
.session-group { margin-bottom: 16px; }
.session-group-title { font-size: 12px; font-weight: 500; color: var(--text-muted); padding: 8px 12px; text-transform: uppercase; letter-spacing: 0.05em; }
.session-item { padding: 10px 12px; border-radius: 6px; cursor: pointer; font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; transition: background 0.2s; }
.session-item:hover { background: var(--bg-hover); color: var(--text-primary); }
.session-item.active { background: var(--bg-tertiary); color: var(--text-primary); }
.sidebar-footer { padding: 12px 16px; border-top: 1px solid var(--border-color); font-size: 12px; color: var(--text-muted); }
.main-content { flex: 1; display: flex; flex-direction: column; min-width: 0; }
.header { padding: 12px 16px; border-bottom: 1px solid var(--border-color); display: flex; align-items: center; gap: 12px; }
.menu-toggle { display: none; background: none; border: none; color: var(--text-secondary); cursor: pointer; padding: 8px; border-radius: 6px; }
.menu-toggle:hover { background: var(--bg-hover); }
.header-title { font-size: 16px; font-weight: 500; }
.session-id { font-size: 12px; color: var(--text-muted); font-family: monospace; }
.chat-area { flex: 1; overflow-y: auto; padding: 0; }
.chat-area::-webkit-scrollbar { width: 8px; }
.chat-area::-webkit-scrollbar-track { background: transparent; }
.chat-area::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
.messages-container { max-width: 800px; margin: 0 auto; padding: 24px; }
.message { display: flex; gap: 16px; margin-bottom: 24px; animation: fadeIn 0.3s ease; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
.message-avatar { width: 32px; height: 32px; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 14px; flex-shrink: 0; }
.message.user .message-avatar { background: var(--accent); color: white; }
.message.assistant .message-avatar { background: var(--bg-tertiary); color: var(--text-primary); }
.message-content { flex: 1; min-width: 0; }
.message-role { font-weight: 600; font-size: 14px; margin-bottom: 4px; }
.message.user .message-role { color: var(--text-primary); }
.message.assistant .message-role { color: var(--accent); }
.message-text { font-size: 15px; line-height: 1.6; color: var(--text-primary); word-wrap: break-word; }
.message-text p { margin-bottom: 12px; }
.message-text p:last-child { margin-bottom: 0; }
.message-text code { background: var(--code-bg); padding: 2px 6px; border-radius: 4px; font-family: 'SF Mono', Monaco, Consolas, monospace; font-size: 13px; }
.message-text pre { background: var(--code-bg); padding: 16px; border-radius: 8px; overflow-x: auto; margin: 12px 0; }
.message-text pre code { background: none; padding: 0; }
.message-text ul, .message-text ol { margin: 12px 0; padding-left: 24px; }
.message-text li { margin-bottom: 6px; }
.message-text h1, .message-text h2, .message-text h3 { margin-top: 20px; margin-bottom: 12px; }
.message-text h1 { font-size: 20px; }
.message-text h2 { font-size: 18px; }
.message-text h3 { font-size: 16px; }
.message-text a { color: var(--accent); text-decoration: none; cursor: pointer; border-bottom: 1px dashed var(--accent); transition: all 0.2s; }
.message-text a:hover { color: var(--accent-hover); border-bottom-style: solid; }
.message-meta { margin-top: 8px; font-size: 12px; color: var(--text-muted); display: flex; align-items: center; gap: 12px; flex-wrap: wrap; }
.message-interface { padding: 2px 6px; background: var(--bg-tertiary); border-radius: 4px; text-transform: uppercase; font-size: 10px; letter-spacing: 0.05em; }
.output-path { color: var(--accent); font-family: monospace; }
.download-buttons { display: flex; gap: 6px; margin-top: 8px; flex-wrap: wrap; }
.download-btn, .preview-btn { padding: 4px 10px; font-size: 11px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-secondary); cursor: pointer; transition: all 0.2s; display: flex; align-items: center; gap: 4px; }
.download-btn:hover, .preview-btn:hover { background: var(--bg-hover); color: var(--text-primary); border-color: var(--accent); }
.preview-btn { background: var(--accent); color: white; border-color: var(--accent); }
.preview-btn:hover { background: var(--accent-hover); }
.download-btn svg, .preview-btn svg { width: 12px; height: 12px; }
.download-btn.loading, .preview-btn.loading { opacity: 0.6; cursor: wait; }
/* Preview Modal */
.preview-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 1000; display: flex; flex-direction: column; animation: fadeIn 0.2s ease; }
.preview-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); }
.preview-title { font-size: 14px; font-weight: 500; color: var(--text-primary); }
.preview-actions { display: flex; gap: 8px; align-items: center; }
.preview-format-btn { padding: 6px 12px; font-size: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-secondary); cursor: pointer; }
.preview-format-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
.preview-format-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
.preview-close { padding: 8px 16px; font-size: 13px; background: var(--error); border: none; border-radius: 4px; color: white; cursor: pointer; }
.preview-close:hover { opacity: 0.9; }
.preview-content { flex: 1; overflow: auto; padding: 0; background: var(--bg-primary); }
.preview-content iframe { width: 100%; height: 100%; border: none; min-height: 80vh; background: white; }
.preview-content .markdown-preview { padding: 40px; max-width: 800px; margin: 0 auto; color: var(--text-primary); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.6; }
.preview-content .markdown-preview h1, .preview-content .markdown-preview h2, .preview-content .markdown-preview h3 { margin-top: 24px; margin-bottom: 16px; color: var(--text-primary); }
.preview-content .markdown-preview pre { background: var(--code-bg); padding: 16px; border-radius: 8px; overflow-x: auto; color: var(--text-primary); }
.preview-content .markdown-preview code { background: var(--code-bg); padding: 2px 6px; border-radius: 4px; color: var(--text-primary); }
.preview-content .markdown-preview ul, .preview-content .markdown-preview ol { padding-left: 24px; }
.preview-loading { display: flex; align-items: center; justify-content: center; height: 100%; min-height: 300px; color: var(--text-secondary); font-size: 16px; background: var(--bg-primary); }
/* PDF Viewer */
.pdf-viewer-container { display: flex; flex-direction: column; height: 100%; min-height: 80vh; background: var(--bg-primary); }
.pdf-viewer-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); }
.pdf-info { display: flex; align-items: center; gap: 10px; font-size: 14px; font-weight: 500; color: var(--text-primary); }
.pdf-icon { width: 20px; height: 20px; color: #dc2626; }
.pdf-actions { display: flex; gap: 8px; }
.pdf-action-btn { display: flex; align-items: center; gap: 6px; padding: 8px 14px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; font-size: 13px; color: var(--text-primary); cursor: pointer; transition: all 0.2s; }
.pdf-action-btn:hover { background: var(--bg-hover); border-color: var(--accent); }
.pdf-action-btn.primary { background: var(--accent); color: white; border-color: var(--accent); }
.pdf-action-btn.primary:hover { background: var(--accent-hover); }
.pdf-action-btn svg { width: 16px; height: 16px; }
.pdf-embed-container { flex: 1; position: relative; min-height: 70vh; background: #525659; }
.pdf-iframe { width: 100%; height: 100%; min-height: 70vh; border: none; position: absolute; top: 0; left: 0; }
.pdf-fallback { display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: var(--bg-primary); align-items: center; justify-content: center; }
.pdf-fallback-content { text-align: center; padding: 40px; }
.pdf-fallback-content svg { width: 64px; height: 64px; color: var(--text-muted); margin-bottom: 16px; }
.pdf-fallback-content p { color: var(--text-secondary); margin: 0 0 20px; font-size: 14px; }
.pdf-fallback-btn { padding: 12px 24px; background: var(--accent); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
.pdf-fallback-btn:hover { background: var(--accent-hover); }
.preview-error { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; min-height: 300px; text-align: center; color: var(--text-secondary); padding: 40px; }
.preview-error h3 { margin: 0 0 8px; color: var(--text-primary); }
.preview-error p { margin: 0; }
/* Extracted Links */
.extracted-links { margin-top: 24px; padding: 16px; background: var(--bg-tertiary); border-radius: 12px; border: 1px solid var(--border-color); }
.links-header { font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); }
.links-list { display: flex; flex-direction: column; gap: 8px; }
.link-item { display: flex; flex-direction: column; padding: 10px 12px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 8px; text-decoration: none; transition: all 0.2s; cursor: pointer; }
.link-item:hover { border-color: var(--accent); background: var(--bg-hover); }
.link-text { font-size: 14px; font-weight: 500; color: var(--accent); margin-bottom: 2px; }
.link-url { font-size: 11px; color: var(--text-muted); font-family: monospace; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
/* Message Links Section */
.message-links { margin-top: 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
.message-links-header { display: flex; align-items: center; justify-content: space-between; padding: 8px 12px; font-size: 12px; font-weight: 500; color: var(--text-secondary); cursor: pointer; transition: background 0.2s; }
.message-links-header:hover { background: var(--bg-hover); }
.message-links-header .expand-icon { width: 16px; height: 16px; transition: transform 0.2s; }
.message-links.expanded .expand-icon { transform: rotate(180deg); }
.message-links-list { display: none; padding: 8px; border-top: 1px solid var(--border-color); max-height: 200px; overflow-y: auto; }
.message-links.expanded .message-links-list { display: flex; flex-direction: column; gap: 4px; }
.message-link-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: var(--bg-primary); border-radius: 6px; text-decoration: none; transition: all 0.2s; cursor: pointer; }
.message-link-item:hover { background: var(--bg-hover); }
.message-link-item .link-favicon { font-size: 14px; }
.message-link-item .link-text { flex: 1; font-size: 13px; color: var(--accent); font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.message-link-item .link-domain { font-size: 11px; color: var(--text-muted); font-family: monospace; }
/* Smart Preview Section Renderers */
.smart-preview { padding: 20px; max-width: 900px; margin: 0 auto; color: var(--text-primary); }
.section-mermaid, .section-plantuml, .section-latex, .section-json, .section-chart, .section-code { margin-bottom: 24px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 12px; overflow: hidden; }
.section-header { display: flex; align-items: center; gap: 8px; padding: 10px 16px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); font-size: 13px; font-weight: 600; color: var(--text-primary); }
.section-icon { font-size: 16px; }
.section-content { padding: 16px; overflow-x: auto; background: var(--bg-primary); color: var(--text-primary); }
.section-source { margin: 0; border-top: 1px solid var(--border-color); }
.section-source summary { padding: 8px 16px; font-size: 12px; color: var(--text-muted); cursor: pointer; background: var(--bg-tertiary); }
.section-source summary:hover { color: var(--text-primary); }
.section-source pre { margin: 0; padding: 12px 16px; background: var(--code-bg); font-size: 12px; overflow-x: auto; color: var(--text-primary); }
.section-source code { color: var(--text-primary); }
/* Mermaid & PlantUML */
.mermaid-img, .plantuml-img { max-width: 100%; height: auto; display: block; margin: 0 auto; background: white; padding: 16px; border-radius: 8px; }
.render-error { padding: 12px; background: rgba(239,68,68,0.15); color: #f87171; border-radius: 6px; margin-bottom: 12px; font-size: 13px; border: 1px solid rgba(239,68,68,0.3); }
/* LaTeX */
.math-content { display: flex; justify-content: center; padding: 24px; background: white; border-radius: 8px; }
.latex-img { max-width: 100%; height: auto; }
/* JSON - theme aware colors */
.json-pretty { margin: 0; padding: 0; font-size: 13px; line-height: 1.5; background: transparent; color: var(--text-primary); }
.json-key { color: #c792ea; }
.json-string { color: #c3e88d; }
.json-number { color: #f78c6c; }
.json-boolean { color: #82aaff; }
.json-null { color: #676e95; }
/* Data Table */
.data-table { width: 100%; border-collapse: collapse; font-size: 13px; color: var(--text-primary); }
.data-table th, .data-table td { padding: 8px 12px; text-align: left; border-bottom: 1px solid var(--border-color); color: var(--text-primary); }
.data-table th { background: var(--bg-tertiary); font-weight: 600; position: sticky; top: 0; color: var(--text-primary); }
.data-table tr:hover { background: var(--bg-hover); }
.table-footer { padding: 8px 12px; font-size: 12px; color: var(--text-muted); background: var(--bg-tertiary); border-top: 1px solid var(--border-color); }
/* Code */
.code-block { margin: 0; padding: 0; font-size: 13px; line-height: 1.5; background: transparent; color: var(--text-primary); }
.code-block code { color: #abb2bf; }
/* Section Markdown */
.section-markdown { border: none; background: transparent; padding: 0 16px; margin-bottom: 16px; }
.section-markdown h1, .section-markdown h2, .section-markdown h3 { margin-top: 20px; margin-bottom: 12px; color: var(--text-primary); }
.section-markdown p { margin-bottom: 12px; line-height: 1.6; color: var(--text-primary); }
.section-markdown ul, .section-markdown ol { padding-left: 24px; margin-bottom: 12px; color: var(--text-primary); }
.section-markdown li { margin-bottom: 6px; color: var(--text-primary); }
.section-markdown code { background: var(--code-bg); padding: 2px 6px; border-radius: 4px; font-size: 13px; color: var(--text-primary); }
.section-markdown pre { background: var(--code-bg); padding: 16px; border-radius: 8px; overflow-x: auto; margin: 12px 0; }
.section-markdown a { color: var(--accent); text-decoration: none; border-bottom: 1px dashed var(--accent); cursor: pointer; }
.section-markdown a:hover { border-bottom-style: solid; }
/* PDF object fallback */
.preview-content object { width: 100%; height: 100%; min-height: 80vh; }
/* Inline Browser Modal */
.inline-browser-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 1001; display: flex; flex-direction: column; animation: fadeIn 0.2s ease; }
.inline-browser-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 16px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); }
.inline-browser-url { flex: 1; padding: 8px 12px; margin: 0 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-size: 13px; font-family: monospace; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.inline-browser-actions { display: flex; gap: 8px; align-items: center; }
.inline-browser-btn { padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-secondary); cursor: pointer; font-size: 12px; display: flex; align-items: center; gap: 4px; }
.inline-browser-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
.inline-browser-btn.close { background: var(--error); color: white; border-color: var(--error); }
.inline-browser-content { flex: 1; background: white; }
.status-indicator { display: flex; align-items: center; gap: 8px; padding: 12px 16px; margin: 16px 0; background: var(--bg-tertiary); border-radius: 8px; font-size: 14px; color: var(--text-secondary); }
.status-spinner { width: 16px; height: 16px; border: 2px solid var(--border-color); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
.input-area { padding: 16px 24px 24px; border-top: 1px solid var(--border-color); background: var(--bg-primary); }
.input-container { max-width: 800px; margin: 0 auto; position: relative; }
.input-wrapper { display: flex; align-items: flex-end; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: 12px; transition: border-color 0.2s; }
.input-wrapper:focus-within { border-color: var(--accent); }
.message-input { flex: 1; background: none; border: none; padding: 14px 16px; font-size: 15px; color: var(--text-primary); resize: none; min-height: 24px; max-height: 200px; outline: none; font-family: inherit; line-height: 1.5; }
.message-input::placeholder { color: var(--text-muted); }
.send-btn { padding: 10px 14px; margin: 4px; background: var(--accent); border: none; border-radius: 8px; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: background 0.2s, opacity 0.2s; }
.send-btn:hover:not(:disabled) { background: var(--accent-hover); }
.send-btn:disabled { opacity: 0.5; cursor: not-allowed; }
.send-btn svg { width: 18px; height: 18px; }
.input-hint { margin-top: 8px; font-size: 12px; color: var(--text-muted); text-align: center; }
.welcome-screen { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 48px 24px; text-align: center; }
.welcome-logo { font-size: 48px; margin-bottom: 16px; }
.welcome-title { font-size: 24px; font-weight: 600; margin-bottom: 8px; }
.welcome-subtitle { font-size: 16px; color: var(--text-secondary); margin-bottom: 32px; max-width: 400px; }
.examples-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; max-width: 600px; width: 100%; }
.example-card { background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; padding: 16px; cursor: pointer; text-align: left; transition: background 0.2s, border-color 0.2s; }
.example-card:hover { background: var(--bg-tertiary); border-color: var(--accent); }
.example-icon { font-size: 20px; margin-bottom: 8px; }
.example-text { font-size: 14px; color: var(--text-secondary); }
.error-message { background: rgba(239, 68, 68, 0.1); border: 1px solid var(--error); border-radius: 8px; padding: 12px 16px; margin: 16px 0; color: var(--error); font-size: 14px; }
.connection-status { position: fixed; top: 16px; right: 120px; padding: 8px 12px; border-radius: 6px; font-size: 12px; display: flex; align-items: center; gap: 6px; z-index: 100; }
.connection-status.connected { background: rgba(16, 163, 127, 0.2); color: var(--success); }
.connection-status.disconnected { background: rgba(239, 68, 68, 0.2); color: var(--error); }
.connection-dot { width: 8px; height: 8px; border-radius: 50%; }
.connection-status.connected .connection-dot { background: var(--success); }
.connection-status.disconnected .connection-dot { background: var(--error); }
@media (max-width: 768px) {
    .sidebar { position: fixed; left: 0; top: 0; bottom: 0; z-index: 50; transform: translateX(-100%); }
    .sidebar.visible { transform: translateX(0); }
    .menu-toggle { display: block; }
    .messages-container { padding: 16px; }
    .input-area { padding: 12px 16px 16px; }
    .examples-grid { grid-template-columns: 1fr; }
}
/* Command autocomplete dropdown */
.command-dropdown {
    position: absolute;
    bottom: 100%;
    left: 0;
    right: 0;
    background: var(--bg-primary);
    border: 1px solid var(--border);
    border-radius: 8px;
    margin-bottom: 8px;
    max-height: 300px;
    overflow-y: auto;
    z-index: 100;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.15);
}
.command-option {
    padding: 10px 14px;
    cursor: pointer;
    border-bottom: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    gap: 2px;
}
.command-option:last-child { border-bottom: none; }
.command-option:hover, .command-option.selected {
    background: var(--accent);
    color: white;
}
.command-name {
    font-weight: 600;
    font-family: monospace;
}
.command-desc {
    font-size: 12px;
    opacity: 0.7;
}
.input-wrapper { position: relative; }
/* Enhanced Sidebar Styles */
.sidebar-actions { display: flex; gap: 6px; padding: 0 12px 12px; }
.sidebar-action-btn { flex: 1; display: flex; align-items: center; justify-content: center; gap: 4px; padding: 6px 8px; font-size: 11px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); cursor: pointer; transition: all 0.2s; }
.sidebar-action-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
.sidebar-action-btn.active { background: var(--accent); color: white; border-color: var(--accent); }
.sidebar-action-btn svg { width: 12px; height: 12px; }
/* Session sections */
.sessions-section { margin-bottom: 8px; }
.sessions-section-header { display: flex; align-items: center; gap: 6px; padding: 6px 12px; font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.05em; cursor: pointer; }
.sessions-section-header:hover { color: var(--text-secondary); }
.sessions-section-header svg { width: 12px; height: 12px; transition: transform 0.2s; }
.sessions-section-header.collapsed svg { transform: rotate(-90deg); }
.sessions-section-header .count { margin-left: auto; font-size: 10px; padding: 1px 5px; background: var(--bg-tertiary); border-radius: 8px; }
/* Session items */
.session-item { position: relative; display: flex; align-items: center; gap: 8px; padding: 8px 12px; margin: 2px 8px; border-radius: 8px; cursor: pointer; transition: all 0.2s; }
.session-item:hover { background: var(--bg-hover); }
.session-item.active { background: var(--accent); color: white; }
.session-item .session-icon { width: 16px; height: 16px; flex-shrink: 0; opacity: 0.7; }
.session-item.active .session-icon { opacity: 1; }
.session-item .session-icon.pinned { color: #f59e0b; }
.session-item .session-title { flex: 1; font-size: 13px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.session-item .session-title-input { flex: 1; padding: 2px 6px; font-size: 13px; background: var(--bg-primary); border: 1px solid var(--accent); border-radius: 4px; color: var(--text-primary); outline: none; }
.session-item .session-menu-btn { opacity: 0; padding: 4px; border-radius: 4px; background: transparent; border: none; color: inherit; cursor: pointer; transition: opacity 0.2s; }
.session-item:hover .session-menu-btn { opacity: 0.7; }
.session-item .session-menu-btn:hover { opacity: 1; background: rgba(0,0,0,0.1); }
.session-item.active .session-menu-btn { opacity: 0.8; }
.session-item .session-menu-btn svg { width: 14px; height: 14px; }
/* Context menu */
.session-context-menu { position: fixed; width: 180px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.25); z-index: 1000; overflow: visible; animation: fadeIn 0.15s ease; }
.session-context-menu .menu-item { display: flex; align-items: center; gap: 8px; padding: 8px 12px; font-size: 12px; color: var(--text-primary); cursor: pointer; transition: background 0.15s; }
.session-context-menu .menu-item:hover { background: var(--bg-hover); }
.session-context-menu .menu-item.danger { color: var(--error); }
.session-context-menu .menu-item svg { width: 14px; height: 14px; }
.session-context-menu .menu-divider { height: 1px; background: var(--border-color); margin: 4px 0; }
.session-context-menu .menu-submenu { padding: 4px 0; border-top: 1px solid var(--border-color); }
.session-context-menu .menu-submenu-title { padding: 4px 12px; font-size: 10px; color: var(--text-muted); text-transform: uppercase; }
/* Folder item */
.folder-item { display: flex; align-items: center; gap: 6px; padding: 6px 12px; margin: 2px 8px; border-radius: 8px; cursor: pointer; transition: all 0.2s; position: relative; }
.folder-item:hover { background: var(--bg-hover); }
.folder-item .folder-color { width: 10px; height: 10px; border-radius: 3px; flex-shrink: 0; cursor: pointer; transition: transform 0.2s; }
.folder-item .folder-color:hover { transform: scale(1.2); }
.folder-item .folder-name { flex: 1; font-size: 12px; font-weight: 500; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.folder-item .folder-name-input { flex: 1; padding: 2px 6px; font-size: 12px; background: var(--bg-primary); border: 1px solid var(--accent); border-radius: 4px; color: var(--text-primary); outline: none; font-weight: 500; }
.folder-item .folder-count { font-size: 10px; color: var(--text-muted); margin-right: 4px; }
.folder-item .folder-chevron { width: 14px; height: 14px; transition: transform 0.2s; flex-shrink: 0; }
.folder-item.collapsed .folder-chevron { transform: rotate(-90deg); }
.folder-item .folder-menu-btn { opacity: 0; padding: 4px; border-radius: 4px; background: transparent; border: none; color: var(--text-secondary); cursor: pointer; transition: opacity 0.2s; flex-shrink: 0; }
.folder-item:hover .folder-menu-btn { opacity: 0.7; }
.folder-item .folder-menu-btn:hover { opacity: 1; background: rgba(255,255,255,0.1); }
.folder-item .folder-menu-btn svg { width: 14px; height: 14px; }
.folder-sessions { margin-left: 12px; }
/* Folder context menu */
.folder-context-menu { position: fixed; width: 180px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.25); z-index: 1000; overflow: visible; animation: fadeIn 0.15s ease; }
.folder-context-menu .menu-item { display: flex; align-items: center; gap: 8px; padding: 8px 12px; font-size: 12px; color: var(--text-primary); cursor: pointer; transition: background 0.15s; }
.folder-context-menu .menu-item:hover { background: var(--bg-hover); }
.folder-context-menu .menu-item.danger { color: var(--error); }
.folder-context-menu .menu-item svg { width: 14px; height: 14px; }
.folder-context-menu .menu-divider { height: 1px; background: var(--border-color); margin: 4px 0; }
.folder-context-menu .color-row { display: flex; gap: 6px; padding: 8px 12px; }
.folder-context-menu .color-dot { width: 18px; height: 18px; border-radius: 4px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; }
.folder-context-menu .color-dot:hover { transform: scale(1.15); }
.folder-context-menu .color-dot.active { border-color: var(--text-primary); }
/* Create folder modal */
.folder-modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 200; display: flex; align-items: center; justify-content: center; animation: fadeIn 0.2s ease; }
.folder-modal { background: var(--bg-secondary); border-radius: 12px; padding: 20px; width: 300px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); }
.folder-modal h3 { margin: 0 0 16px; font-size: 16px; color: var(--text-primary); }
.folder-modal input { width: 100%; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; outline: none; }
.folder-modal input:focus { border-color: var(--accent); }
.folder-modal .color-picker { display: flex; gap: 8px; margin: 12px 0; }
.folder-modal .color-option { width: 24px; height: 24px; border-radius: 6px; cursor: pointer; border: 2px solid transparent; transition: all 0.2s; }
.folder-modal .color-option:hover, .folder-modal .color-option.selected { transform: scale(1.1); border-color: var(--text-primary); }
.folder-modal .modal-actions { display: flex; gap: 8px; margin-top: 16px; }
.folder-modal .modal-actions button { flex: 1; padding: 10px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.2s; }
.folder-modal .cancel-btn { background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-secondary); }
.folder-modal .cancel-btn:hover { background: var(--bg-hover); }
.folder-modal .create-btn { background: var(--accent); border: none; color: white; }
.folder-modal .create-btn:hover { background: var(--accent-hover); }

/* ===== AGUI/A2UI COMPONENTS ===== */
/* AI-Generated UI - Smart Response Cards */

/* Thinking Indicator */
.thinking-indicator { display: flex; align-items: center; gap: 12px; padding: 16px 20px; background: linear-gradient(135deg, var(--bg-tertiary) 0%, var(--bg-secondary) 100%); border: 1px solid var(--border-color); border-radius: 12px; margin-bottom: 16px; animation: pulseGlow 2s ease-in-out infinite; }
@keyframes pulseGlow { 0%, 100% { box-shadow: 0 0 0 0 rgba(16, 163, 127, 0); } 50% { box-shadow: 0 0 20px 2px rgba(16, 163, 127, 0.15); } }
.thinking-dots { display: flex; gap: 4px; }
.thinking-dots span { width: 8px; height: 8px; background: var(--accent); border-radius: 50%; animation: bounce 1.4s ease-in-out infinite; }
.thinking-dots span:nth-child(1) { animation-delay: 0s; }
.thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
.thinking-dots span:nth-child(3) { animation-delay: 0.4s; }
@keyframes bounce { 0%, 80%, 100% { transform: translateY(0); } 40% { transform: translateY(-6px); } }
@keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
@keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
.thinking-text { font-size: 13px; color: var(--text-secondary); }
.thinking-step { font-size: 11px; color: var(--accent); margin-top: 4px; font-family: monospace; }

/* Suggested Actions / Quick Replies */
.suggested-actions { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 16px; padding-top: 16px; border-top: 1px solid var(--border-color); }
.action-chip { display: inline-flex; align-items: center; gap: 6px; padding: 8px 14px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 20px; font-size: 13px; color: var(--text-primary); cursor: pointer; transition: all 0.2s; }
.action-chip:hover { background: var(--accent); border-color: var(--accent); color: white; transform: translateY(-1px); }
.action-chip svg { width: 14px; height: 14px; }
.action-chip.primary { background: var(--accent); border-color: var(--accent); color: white; }
.action-chip.primary:hover { background: var(--accent-hover); }

/* Smart Cards - Entity Cards */
.smart-card { background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 12px; padding: 16px; margin: 12px 0; transition: all 0.2s; }
.smart-card:hover { border-color: var(--accent); transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
.smart-card-header { display: flex; align-items: center; gap: 12px; margin-bottom: 12px; }
.smart-card-icon { width: 40px; height: 40px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 20px; background: var(--bg-primary); }
.smart-card-title { font-size: 15px; font-weight: 600; color: var(--text-primary); }
.smart-card-subtitle { font-size: 12px; color: var(--text-muted); }
.smart-card-body { font-size: 14px; color: var(--text-secondary); line-height: 1.5; }
.smart-card-actions { display: flex; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); }
.smart-card-btn { padding: 6px 12px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; font-size: 12px; color: var(--text-secondary); cursor: pointer; transition: all 0.2s; }
.smart-card-btn:hover { background: var(--bg-hover); color: var(--text-primary); }
.smart-card-btn.primary { background: var(--accent); border-color: var(--accent); color: white; }

/* Data Cards - Stats/Metrics */
.data-card { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin: 12px 0; }
.data-card-item { background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 10px; padding: 14px; text-align: center; }
.data-card-value { font-size: 24px; font-weight: 700; color: var(--accent); margin-bottom: 4px; }
.data-card-label { font-size: 11px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px; }
.data-card-change { font-size: 12px; margin-top: 6px; }
.data-card-change.positive { color: #22c55e; }
.data-card-change.negative { color: #ef4444; }

/* Citation Cards */
.citation-card { display: flex; align-items: flex-start; gap: 12px; padding: 12px; background: var(--bg-tertiary); border-left: 3px solid var(--accent); border-radius: 0 8px 8px 0; margin: 8px 0; cursor: pointer; transition: all 0.2s; }
.citation-card:hover { background: var(--bg-hover); }
.citation-number { width: 24px; height: 24px; background: var(--accent); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 600; color: white; flex-shrink: 0; }
.citation-content { flex: 1; min-width: 0; }
.citation-title { font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.citation-source { font-size: 11px; color: var(--text-muted); }

/* Timeline View */
.timeline { position: relative; padding-left: 24px; margin: 16px 0; }
.timeline::before { content: ''; position: absolute; left: 7px; top: 0; bottom: 0; width: 2px; background: var(--border-color); }
.timeline-item { position: relative; padding: 12px 0 12px 20px; }
.timeline-item::before { content: ''; position: absolute; left: -20px; top: 16px; width: 12px; height: 12px; background: var(--accent); border-radius: 50%; border: 2px solid var(--bg-primary); }
.timeline-date { font-size: 11px; color: var(--accent); font-weight: 500; margin-bottom: 4px; }
.timeline-content { font-size: 14px; color: var(--text-primary); }
.timeline-desc { font-size: 12px; color: var(--text-secondary); margin-top: 4px; }

/* Expandable Sections */
.expandable-section { border: 1px solid var(--border-color); border-radius: 8px; margin: 12px 0; overflow: hidden; }
.expandable-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--bg-tertiary); cursor: pointer; transition: background 0.2s; }
.expandable-header:hover { background: var(--bg-hover); }
.expandable-title { font-size: 14px; font-weight: 500; color: var(--text-primary); display: flex; align-items: center; gap: 8px; }
.expandable-icon { width: 20px; height: 20px; transition: transform 0.2s; }
.expandable-section.expanded .expandable-icon { transform: rotate(180deg); }
.expandable-content { display: none; padding: 16px; background: var(--bg-primary); }
.expandable-section.expanded .expandable-content { display: block; }

/* Progress Steps */
.progress-steps { display: flex; align-items: center; gap: 0; margin: 16px 0; overflow-x: auto; padding: 8px 0; }
.progress-step { display: flex; align-items: center; }
.progress-step-circle { width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 13px; font-weight: 600; background: var(--bg-tertiary); border: 2px solid var(--border-color); color: var(--text-muted); transition: all 0.3s; flex-shrink: 0; }
.progress-step.active .progress-step-circle { background: var(--accent); border-color: var(--accent); color: white; }
.progress-step.completed .progress-step-circle { background: var(--success); border-color: var(--success); color: white; }
.progress-step-line { width: 40px; height: 2px; background: var(--border-color); }
.progress-step.completed + .progress-step .progress-step-line { background: var(--success); }
.progress-step-label { position: absolute; top: 100%; left: 50%; transform: translateX(-50%); font-size: 10px; color: var(--text-muted); white-space: nowrap; margin-top: 4px; }

/* Interactive Chart Container */
.chart-container { background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 12px; padding: 16px; margin: 12px 0; }
.chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; }
.chart-title { font-size: 14px; font-weight: 600; color: var(--text-primary); }
.chart-controls { display: flex; gap: 4px; }
.chart-control-btn { padding: 4px 10px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; font-size: 11px; color: var(--text-muted); cursor: pointer; }
.chart-control-btn:hover, .chart-control-btn.active { background: var(--accent); border-color: var(--accent); color: white; }
.chart-canvas { width: 100%; height: 200px; }

/* ===== VOICE CHAT ===== */
.voice-chat-btn {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: var(--bg-tertiary);
    border: 2px solid var(--border-color);
    color: var(--text-secondary);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    position: relative;
}
.voice-chat-btn:hover {
    background: var(--accent);
    border-color: var(--accent);
    color: white;
}
.voice-chat-btn.recording {
    background: #ef4444;
    border-color: #ef4444;
    color: white;
    animation: pulse-recording 1.5s infinite;
}
.voice-chat-btn.playing {
    background: var(--accent);
    border-color: var(--accent);
    color: white;
}
.voice-chat-btn svg {
    width: 24px;
    height: 24px;
}
@keyframes pulse-recording {
    0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
    50% { box-shadow: 0 0 0 12px rgba(239, 68, 68, 0); }
}
.voice-chat-container {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px;
    background: var(--bg-secondary);
    border-radius: 12px;
    margin: 8px 0;
}
.voice-status {
    flex: 1;
    font-size: 14px;
    color: var(--text-secondary);
}
.voice-status.active {
    color: var(--accent);
}
.voice-waveform {
    display: flex;
    align-items: center;
    gap: 2px;
    height: 24px;
}
.voice-waveform-bar {
    width: 3px;
    background: var(--accent);
    border-radius: 2px;
    animation: waveform 0.5s ease-in-out infinite;
}
.voice-waveform-bar:nth-child(1) { animation-delay: 0s; }
.voice-waveform-bar:nth-child(2) { animation-delay: 0.1s; }
.voice-waveform-bar:nth-child(3) { animation-delay: 0.2s; }
.voice-waveform-bar:nth-child(4) { animation-delay: 0.3s; }
.voice-waveform-bar:nth-child(5) { animation-delay: 0.4s; }
@keyframes waveform {
    0%, 100% { height: 8px; }
    50% { height: 24px; }
}
.voice-transcript {
    padding: 8px 12px;
    background: var(--bg-tertiary);
    border-radius: 8px;
    font-size: 13px;
    color: var(--text-secondary);
    margin-top: 8px;
    font-style: italic;
}
.voice-mode-toggle {
    display: flex;
    gap: 4px;
    background: var(--bg-tertiary);
    border-radius: 8px;
    padding: 4px;
}
.voice-mode-btn {
    padding: 6px 12px;
    background: transparent;
    border: none;
    border-radius: 6px;
    color: var(--text-muted);
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
}
.voice-mode-btn:hover {
    color: var(--text-primary);
}
.voice-mode-btn.active {
    background: var(--accent);
    color: white;
}

/* ===== DOCUMENT UPLOAD & CHAT ===== */

/* Folder with documents indicator */
.folder-item .folder-docs { display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text-muted); margin-left: auto; }
.folder-item .folder-docs svg { width: 12px; height: 12px; }

/* Chat with context button */
.chat-context-btn { width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; background: transparent; border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-muted); cursor: pointer; transition: all 0.2s; flex-shrink: 0; }
.chat-context-btn:hover { background: var(--accent); border-color: var(--accent); color: white; }
.chat-context-btn svg { width: 14px; height: 14px; }
.chat-context-btn.active { background: var(--accent); border-color: var(--accent); color: white; }

/* Upload dropzone */
.upload-dropzone { border: 2px dashed var(--border-color); border-radius: 12px; padding: 32px; text-align: center; cursor: pointer; transition: all 0.2s; margin: 8px; }
.upload-dropzone:hover, .upload-dropzone.dragover { border-color: var(--accent); background: rgba(16, 163, 127, 0.05); }
.upload-dropzone-icon { font-size: 32px; margin-bottom: 8px; }
.upload-dropzone-text { font-size: 14px; color: var(--text-secondary); margin-bottom: 4px; }
.upload-dropzone-hint { font-size: 11px; color: var(--text-muted); }
.upload-dropzone input[type="file"] { display: none; }

/* Document list in folder */
.folder-documents { background: var(--bg-primary); border-top: 1px solid var(--border-color); margin-top: 4px; }
.document-item { display: flex; align-items: center; gap: 10px; padding: 10px 16px; border-bottom: 1px solid var(--border-color); transition: background 0.2s; }
.document-item:last-child { border-bottom: none; }
.document-item:hover { background: var(--bg-hover); }
.document-icon { width: 32px; height: 32px; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0; }
.document-icon.pdf { background: rgba(220, 38, 38, 0.15); color: #dc2626; }
.document-icon.doc { background: rgba(37, 99, 235, 0.15); color: #2563eb; }
.document-icon.txt { background: rgba(107, 114, 128, 0.15); color: #6b7280; }
.document-icon.csv { background: rgba(34, 197, 94, 0.15); color: #22c55e; }
.document-icon.default { background: var(--bg-tertiary); color: var(--text-muted); }
.document-info { flex: 1; min-width: 0; }
.document-name { font-size: 13px; font-weight: 500; color: var(--text-primary); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.document-meta { font-size: 11px; color: var(--text-muted); display: flex; gap: 8px; }
.document-actions { display: flex; gap: 4px; opacity: 0; transition: opacity 0.2s; }
.document-item:hover .document-actions { opacity: 1; }
.document-action-btn { width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; background: transparent; border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-muted); cursor: pointer; transition: all 0.2s; }
.document-action-btn:hover { background: var(--bg-tertiary); color: var(--text-primary); }
.document-action-btn.chat:hover { background: var(--accent); border-color: var(--accent); color: white; }
.document-action-btn.delete:hover { background: var(--error); border-color: var(--error); color: white; }
.document-action-btn svg { width: 14px; height: 14px; }

/* Context badge in input area */
.context-badge { display: inline-flex; align-items: center; gap: 6px; padding: 6px 12px; background: var(--accent); border-radius: 20px; font-size: 12px; color: white; margin-bottom: 8px; }
.context-badge svg { width: 14px; height: 14px; }
.context-badge-remove { cursor: pointer; opacity: 0.8; transition: opacity 0.2s; }
.context-badge-remove:hover { opacity: 1; }
.context-badges { display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 8px; }

/* Attachment previews in input area */
.attachment-previews { display: flex; flex-wrap: wrap; gap: 8px; padding: 8px 0; margin-bottom: 8px; }
.attachment-preview { position: relative; width: 80px; height: 80px; border-radius: 8px; overflow: hidden; background: var(--bg-tertiary); border: 1px solid var(--border-color); }
.attachment-preview img { width: 100%; height: 100%; object-fit: cover; }
.attachment-preview .remove-attachment { position: absolute; top: 2px; right: 2px; width: 20px; height: 20px; background: var(--error); border: none; border-radius: 50%; color: white; font-size: 14px; cursor: pointer; display: flex; align-items: center; justify-content: center; opacity: 0.8; transition: opacity 0.2s; }
.attachment-preview .remove-attachment:hover { opacity: 1; }
.attachment-preview .attachment-name { position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: white; font-size: 9px; padding: 2px 4px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; }

/* Message attachments (displayed in chat) */
.message-attachments { display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px; }
.message-attachment { max-width: 300px; border-radius: 8px; overflow: hidden; background: var(--bg-tertiary); border: 1px solid var(--border-color); }
.message-attachment img { max-width: 100%; height: auto; display: block; }

/* Toolbar buttons (ðŸ“Ž ðŸŽ¤) */
.toolbar-btn { background: transparent; border: none; padding: 8px; font-size: 18px; cursor: pointer; opacity: 0.7; transition: opacity 0.2s, transform 0.2s; }
.toolbar-btn:hover { opacity: 1; transform: scale(1.1); }
.toolbar-btn.listening { color: var(--error); animation: pulse 1s infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

/* Upload progress */
.upload-progress { padding: 12px; background: var(--bg-tertiary); border-radius: 8px; margin: 8px; }
.upload-progress-header { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 6px; }
.upload-progress-bar { height: 4px; background: var(--border-color); border-radius: 2px; overflow: hidden; }
.upload-progress-fill { height: 100%; background: var(--accent); transition: width 0.3s; }

/* Document viewer modal */
.doc-viewer-modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 1000; display: flex; flex-direction: column; }
.doc-viewer-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 20px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); }
.doc-viewer-title { font-size: 14px; font-weight: 500; color: var(--text-primary); display: flex; align-items: center; gap: 8px; }
.doc-viewer-actions { display: flex; gap: 8px; }
.doc-viewer-content { flex: 1; overflow: auto; padding: 20px; background: var(--bg-primary); }
.doc-viewer-text { max-width: 800px; margin: 0 auto; font-size: 14px; line-height: 1.7; color: var(--text-primary); white-space: pre-wrap; }

/* Chat mode indicator */
.chat-mode-indicator { display: flex; align-items: center; gap: 8px; padding: 8px 16px; background: linear-gradient(90deg, rgba(16, 163, 127, 0.1) 0%, transparent 100%); border-left: 3px solid var(--accent); margin-bottom: 8px; border-radius: 0 8px 8px 0; }
.chat-mode-icon { font-size: 16px; }
.chat-mode-text { font-size: 13px; color: var(--text-secondary); }
.chat-mode-text strong { color: var(--accent); }
.chat-mode-close { margin-left: auto; cursor: pointer; color: var(--text-muted); padding: 4px; }
.chat-mode-close:hover { color: var(--text-primary); }

/* ===== AG-UI PROTOCOL COMPONENTS ===== */
/* Open standard for Agent-User Interaction (CopilotKit) */

.agui-tool-call { background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 10px; margin: 12px 0; overflow: hidden; }
.agui-tool-header { display: flex; align-items: center; gap: 8px; padding: 10px 14px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); }
.agui-tool-icon { font-size: 16px; }
.agui-tool-name { font-size: 13px; font-weight: 600; color: var(--text-primary); flex: 1; }
.agui-tool-status { font-size: 11px; padding: 3px 8px; border-radius: 10px; }
.agui-tool-status.running { background: rgba(234, 179, 8, 0.2); color: #eab308; }
.agui-tool-status.completed { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
.agui-tool-body { padding: 12px 14px; }
.agui-tool-body details { margin: 8px 0; }
.agui-tool-body summary { cursor: pointer; font-size: 12px; color: var(--text-secondary); margin-bottom: 6px; }
.agui-tool-body pre { background: var(--bg-primary); padding: 10px; border-radius: 6px; font-size: 11px; overflow-x: auto; color: var(--text-primary); margin: 0; }

.agui-activity { background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 10px; margin: 12px 0; padding: 14px; }
.agui-plan-header { font-size: 14px; font-weight: 600; color: var(--text-primary); margin-bottom: 12px; display: flex; align-items: center; gap: 8px; }
.agui-plan-steps { display: flex; flex-direction: column; gap: 8px; }
.agui-plan-step { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: var(--bg-primary); border-radius: 8px; }
.agui-plan-step.completed { opacity: 0.7; }
.agui-plan-step.current { border-left: 3px solid var(--accent); }
.agui-step-number { width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; background: var(--accent); color: white; border-radius: 50%; font-size: 12px; font-weight: 600; flex-shrink: 0; }
.agui-plan-step.completed .agui-step-number { background: var(--success); }
.agui-step-text { flex: 1; font-size: 13px; color: var(--text-primary); }
.agui-step-check { color: var(--success); font-size: 16px; }

.agui-progress { padding: 4px 0; }
.agui-progress-header { font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; }
.agui-progress-bar { height: 6px; background: var(--bg-primary); border-radius: 3px; overflow: hidden; }
.agui-progress-fill { height: 100%; background: var(--accent); border-radius: 3px; transition: width 0.3s ease; }
.agui-progress-text { font-size: 11px; color: var(--text-muted); text-align: right; margin-top: 4px; }

/* Human-in-the-loop approval */
.agui-approval { background: linear-gradient(135deg, rgba(234, 179, 8, 0.1) 0%, rgba(234, 179, 8, 0.05) 100%); border: 1px solid rgba(234, 179, 8, 0.3); border-radius: 12px; padding: 16px; margin: 12px 0; }
.agui-approval-header { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
.agui-approval-icon { font-size: 20px; }
.agui-approval-title { font-size: 14px; font-weight: 600; color: #eab308; }
.agui-approval-content { font-size: 13px; color: var(--text-primary); margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; }
.agui-approval-actions { display: flex; gap: 10px; }
.agui-approval-btn { padding: 8px 16px; border-radius: 8px; font-size: 13px; cursor: pointer; transition: all 0.2s; border: none; }
.agui-approval-btn.approve { background: var(--success); color: white; }
.agui-approval-btn.approve:hover { background: #16a34a; }
.agui-approval-btn.reject { background: var(--bg-tertiary); color: var(--text-secondary); border: 1px solid var(--border-color); }
.agui-approval-btn.reject:hover { background: var(--error); color: white; border-color: var(--error); }

/* State indicator */
.agui-state-badge { display: inline-flex; align-items: center; gap: 6px; padding: 4px 10px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 12px; font-size: 11px; color: var(--text-secondary); }
.agui-state-badge.synced { border-color: var(--success); color: var(--success); }
.agui-state-dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }

/* ===== THEME SYSTEM (JustJot.ai Sync) ===== */
[data-theme="light"] {
    --bg-primary: #ffffff;
    --bg-secondary: #f9fafb;
    --bg-tertiary: #f3f4f6;
    --bg-hover: #e5e7eb;
    --bg-input: #ffffff;
    --text-primary: #1f2937;
    --text-secondary: #6b7280;
    --text-muted: #9ca3af;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --border-color: #e5e7eb;
    --error: #ef4444;
    --success: #22c55e;
    --code-bg: #f3f4f6;
    --scrollbar-thumb: #d1d5db;
}

/* ===== HEADER ACTIONS ===== */
.header-actions { display: flex; gap: 8px; margin-left: auto; }
.header-btn { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; font-size: 16px; transition: all 0.2s; position: relative; }
.header-btn:hover { background: var(--bg-hover); border-color: var(--accent); }
.config-badge[data-count]:not([data-count="0"])::after { content: attr(data-count); position: absolute; top: -4px; right: -4px; background: var(--accent); color: white; font-size: 10px; padding: 2px 5px; border-radius: 8px; }

/* ===== TOOLBAR BUTTONS ===== */
.toolbar-btn { width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; background: transparent; border: none; cursor: pointer; font-size: 16px; color: var(--text-muted); transition: all 0.2s; flex-shrink: 0; }
.toolbar-btn:hover { color: var(--text-primary); background: var(--bg-hover); border-radius: 6px; }
#voice-btn.listening { color: var(--error); animation: pulse 1s ease-in-out infinite; }
@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

/* ===== ATTACHMENT PREVIEWS ===== */
.attachment-previews { display: flex; flex-wrap: wrap; gap: 8px; padding: 8px 0; }
.attachment-preview { position: relative; width: 80px; height: 80px; border-radius: 8px; overflow: hidden; border: 1px solid var(--border-color); }
.attachment-preview img { width: 100%; height: 100%; object-fit: cover; }
.attachment-preview .remove-attachment { position: absolute; top: 4px; right: 4px; width: 20px; height: 20px; background: rgba(0,0,0,0.6); color: white; border: none; border-radius: 50%; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; }
.attachment-preview .attachment-name { position: absolute; bottom: 0; left: 0; right: 0; padding: 4px; background: rgba(0,0,0,0.6); color: white; font-size: 9px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; }

/* ===== AGENT/SWARM SELECTOR ===== */
#agent-selector { margin-bottom: 8px; }
.mode-toggle { display: flex; gap: 4px; margin-bottom: 8px; }
.mode-toggle button { flex: 1; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-secondary); cursor: pointer; font-size: 12px; transition: all 0.2s; }
.mode-toggle button:hover { background: var(--bg-hover); }
.mode-toggle button.active { background: var(--accent); border-color: var(--accent); color: white; }
.agent-dropdown { width: 100%; padding: 8px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-size: 13px; cursor: pointer; }
.swarm-modes { display: flex; gap: 4px; margin-top: 8px; }
.swarm-modes button { flex: 1; padding: 6px 10px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-muted); cursor: pointer; font-size: 11px; }
.swarm-modes button.active { background: var(--accent); border-color: var(--accent); color: white; }

/* ===== CONFIG MODAL ===== */
.modal { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 1000; display: none; align-items: center; justify-content: center; animation: fadeIn 0.2s ease; }
.modal.open { display: flex; }
.modal-content { background: var(--bg-secondary); border-radius: 16px; width: 90%; max-width: 600px; max-height: 80vh; overflow: hidden; display: flex; flex-direction: column; box-shadow: 0 20px 60px rgba(0,0,0,0.4); }
.modal-header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--border-color); }
.modal-header h3 { margin: 0; font-size: 18px; color: var(--text-primary); }
.modal-header button { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 20px; padding: 4px 8px; border-radius: 4px; }
.modal-header button:hover { background: var(--bg-hover); color: var(--text-primary); }
.modal-body { flex: 1; overflow-y: auto; padding: 20px; }
.config-tabs { display: flex; gap: 4px; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid var(--border-color); }
.config-tabs button { padding: 8px 16px; background: transparent; border: none; border-radius: 6px; color: var(--text-secondary); cursor: pointer; font-size: 13px; transition: all 0.2s; }
.config-tabs button:hover { background: var(--bg-hover); }
.config-tabs button.active { background: var(--accent); color: white; }
.config-tab-content { display: none; }
.config-tab-content.active { display: block; }
.config-category { margin-bottom: 20px; }
.config-category h4 { font-size: 12px; text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted); margin: 0 0 12px 0; }
.config-items { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 8px; }
.config-item { display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; transition: all 0.2s; }
.config-item:hover { border-color: var(--accent); }
.config-item input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent); }
.config-item .item-icon { font-size: 16px; }
.config-item .item-label { flex: 1; font-size: 13px; color: var(--text-primary); }
.config-item .item-desc { font-size: 11px; color: var(--text-muted); }

/* ===== CONTEXT PANEL ===== */
.context-panel { position: fixed; top: 0; right: 0; bottom: 0; width: 320px; background: var(--bg-secondary); border-left: 1px solid var(--border-color); transform: translateX(100%); transition: transform 0.3s ease; z-index: 100; display: flex; flex-direction: column; }
.context-panel.open { transform: translateX(0); }
.panel-header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid var(--border-color); }
.panel-header h3 { margin: 0; font-size: 16px; color: var(--text-primary); }
.panel-header button { background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 18px; padding: 4px; border-radius: 4px; }
.panel-header button:hover { background: var(--bg-hover); color: var(--text-primary); }
#context-panel-content { flex: 1; overflow-y: auto; padding: 16px; }
.context-section { margin-bottom: 20px; padding: 16px; background: var(--bg-tertiary); border-radius: 12px; }
.context-section h4 { margin: 0 0 12px 0; font-size: 14px; color: var(--text-primary); display: flex; align-items: center; gap: 8px; }
.context-section p { margin: 0 0 8px 0; font-size: 13px; color: var(--text-secondary); }
.context-section p:last-child { margin-bottom: 0; }
.context-section button { padding: 8px 14px; background: var(--bg-primary); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); cursor: pointer; font-size: 13px; display: flex; align-items: center; gap: 6px; transition: all 0.2s; }
.context-section button:hover { border-color: var(--accent); background: var(--bg-hover); }

/* ===== MODEL SELECTOR ===== */
.model-provider h4 { display: flex; align-items: center; gap: 8px; }
.model-list { display: flex; flex-direction: column; gap: 6px; }
.model-item { display: flex; align-items: center; gap: 10px; padding: 12px 14px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; transition: all 0.2s; }
.model-item:hover { border-color: var(--accent); background: var(--bg-hover); }
.model-item.active { border-color: var(--accent); background: rgba(16, 163, 127, 0.15); }
.model-item input[type="radio"] { width: 16px; height: 16px; accent-color: var(--accent); flex-shrink: 0; }
.model-info { flex: 1; display: flex; flex-direction: column; gap: 4px; min-width: 0; }
.model-name { font-size: 13px; font-weight: 500; color: var(--text-primary); }
.model-badges { display: flex; flex-wrap: wrap; gap: 4px; }
.badge { display: inline-flex; align-items: center; padding: 2px 6px; font-size: 10px; border-radius: 4px; background: var(--bg-primary); color: var(--text-muted); border: 1px solid var(--border-color); }
.badge.recommended { background: rgba(234, 179, 8, 0.2); color: #eab308; border-color: transparent; }
.badge.vision { background: rgba(139, 92, 246, 0.2); color: #a78bfa; border-color: transparent; }
.badge.fast { background: rgba(34, 197, 94, 0.2); color: #22c55e; border-color: transparent; }
.badge.free { background: rgba(16, 163, 127, 0.2); color: var(--accent); border-color: transparent; }
.badge.local { background: rgba(59, 130, 246, 0.2); color: #3b82f6; border-color: transparent; }
.badge.context { font-family: monospace; }

/* ===== DOCUMENT ATTACHMENT PREVIEW ===== */
.doc-preview { background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; }
.doc-preview .doc-icon { font-size: 32px; }
.doc-preview .attachment-name { background: rgba(0,0,0,0.8); }

/* ===== LIBRECHAT FEATURES ===== */
/* Web Search, Tool Calls, Artifacts, Branching, Code Interpreter */

/* Search Indicator */
.search-indicator { display: flex; align-items: center; gap: 10px; padding: 12px 16px; margin: 8px 0; background: var(--bg-secondary); border-radius: 8px; border: 1px solid var(--border-color); font-size: 14px; color: var(--text-secondary); }
.search-spinner { width: 16px; height: 16px; border: 2px solid var(--border-color); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
.search-provider { margin-left: auto; padding: 2px 8px; background: var(--bg-tertiary); border-radius: 4px; font-size: 12px; }

/* Citation Cards */
.citation-cards { margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); }
.citation-header { display: flex; align-items: center; gap: 6px; margin-bottom: 8px; font-size: 13px; color: var(--text-secondary); }
.citation-list { display: flex; flex-wrap: wrap; gap: 8px; }
.citation-card { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-tertiary); border-radius: 6px; text-decoration: none; color: var(--text-primary); font-size: 12px; transition: all 0.2s; border: 1px solid transparent; }
.citation-card:hover { background: var(--bg-hover); border-color: var(--accent); }
.citation-number { width: 20px; height: 20px; background: var(--accent); color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: 600; }
.citation-source { color: var(--text-muted); }
.citation-title { max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }

/* Tool Call Cards */
.tool-call-card { margin: 12px 0; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
.tool-call-header { display: flex; align-items: center; gap: 8px; padding: 10px 14px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); }
.tool-name { font-weight: 500; color: var(--text-primary); }
.tool-status { margin-left: auto; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 500; }
.tool-status.running { background: rgba(59, 130, 246, 0.2); color: #60a5fa; }
.tool-status.completed { background: rgba(16, 163, 127, 0.2); color: var(--success); }
.tool-call-args, .tool-call-result { padding: 10px 14px; font-size: 12px; }
.tool-call-args pre, .tool-call-result pre { margin: 0; padding: 8px; background: var(--code-bg); border-radius: 4px; overflow-x: auto; font-family: 'Monaco', 'Menlo', monospace; font-size: 11px; }
.tool-call-result { border-top: 1px solid var(--border-color); background: var(--bg-tertiary); }

/* Artifact Containers */
.artifact-container { margin: 12px 0; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 8px; overflow: hidden; }
.artifact-header { display: flex; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-tertiary); border-bottom: 1px solid var(--border-color); }
.artifact-title { flex: 1; font-size: 13px; font-weight: 500; color: var(--text-primary); }
.artifact-action { width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; background: transparent; border: none; border-radius: 4px; color: var(--text-secondary); cursor: pointer; font-size: 14px; transition: all 0.2s; }
.artifact-action:hover { background: var(--bg-hover); color: var(--text-primary); }
.artifact-action.run-btn { background: var(--accent); color: white; padding: 4px 8px; width: auto; font-size: 12px; }
.artifact-action.run-btn:hover { background: var(--accent-hover); }
.mermaid-preview { padding: 16px; overflow-x: auto; display: flex; justify-content: center; background: white; min-height: 100px; }
.mermaid-error { color: var(--error); padding: 12px; font-size: 12px; }
.html-preview { width: 100%; height: 300px; border: none; background: white; }
.svg-preview { padding: 16px; display: flex; justify-content: center; background: white; }
.svg-preview svg { max-width: 100%; height: auto; }
.code-container pre { margin: 0; padding: 16px; overflow-x: auto; }
.code-container code { font-family: 'Monaco', 'Menlo', monospace; font-size: 13px; line-height: 1.5; }
.code-output { border-top: 1px solid var(--border-color); padding: 12px 16px; background: var(--bg-tertiary); font-family: 'Monaco', 'Menlo', monospace; font-size: 12px; }
.code-running { display: flex; align-items: center; gap: 8px; color: var(--text-secondary); }
.code-running::before { content: ''; width: 12px; height: 12px; border: 2px solid var(--border-color); border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite; }
.code-success .output-header, .code-error .output-header { font-size: 11px; font-weight: 500; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
.code-success { color: var(--success); }
.code-error { color: var(--error); }
.code-success pre, .code-error pre { margin: 0; padding: 8px; background: var(--code-bg); border-radius: 4px; color: var(--text-primary); white-space: pre-wrap; word-break: break-word; }

/* Artifact Modal */
.artifact-modal { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 24px; }
.artifact-modal-content { background: var(--bg-primary); border-radius: 12px; width: 100%; max-width: 900px; max-height: 90vh; overflow: hidden; display: flex; flex-direction: column; }
.artifact-modal-header { display: flex; align-items: center; justify-content: space-between; padding: 16px; border-bottom: 1px solid var(--border-color); }
.artifact-modal-header button { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; background: transparent; border: none; border-radius: 6px; color: var(--text-secondary); cursor: pointer; font-size: 18px; }
.artifact-modal-header button:hover { background: var(--bg-hover); }
.artifact-modal-body { flex: 1; overflow: auto; padding: 16px; }
.artifact-modal-body iframe { width: 100%; height: 500px; border: none; background: white; border-radius: 8px; }

/* Message Actions */
.message-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 4px; }
.message-actions { display: flex; align-items: center; gap: 4px; opacity: 0; transition: opacity 0.2s; }
.message:hover .message-actions { opacity: 1; }
.msg-action-btn { width: 26px; height: 26px; display: flex; align-items: center; justify-content: center; background: transparent; border: none; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s; }
.msg-action-btn:hover { background: var(--bg-hover); }
.branch-badge { padding: 2px 6px; background: rgba(139, 92, 246, 0.2); color: #a78bfa; border-radius: 4px; font-size: 10px; font-weight: 500; }

/* Edit Message Modal */
.edit-message-modal { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 24px; }
.edit-modal-content { background: var(--bg-primary); border-radius: 12px; width: 100%; max-width: 600px; overflow: hidden; }
.edit-modal-header { display: flex; align-items: center; justify-content: space-between; padding: 16px; border-bottom: 1px solid var(--border-color); font-weight: 500; }
.edit-modal-header button { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; background: transparent; border: none; border-radius: 6px; color: var(--text-secondary); cursor: pointer; }
.edit-modal-body { padding: 16px; }
.edit-modal-body textarea { width: 100%; min-height: 120px; padding: 12px; background: var(--bg-input); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; resize: vertical; font-family: inherit; }
.edit-modal-body textarea:focus { outline: none; border-color: var(--accent); }
.edit-options { margin-top: 12px; }
.edit-options label { display: flex; align-items: center; gap: 8px; font-size: 13px; color: var(--text-secondary); cursor: pointer; }
.edit-modal-footer { display: flex; justify-content: flex-end; gap: 8px; padding: 16px; border-top: 1px solid var(--border-color); }
.btn-secondary, .btn-primary { padding: 8px 16px; border-radius: 6px; font-size: 14px; font-weight: 500; cursor: pointer; transition: all 0.2s; }
.btn-secondary { background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); }
.btn-secondary:hover { background: var(--bg-hover); }
.btn-primary { background: var(--accent); border: none; color: white; }
.btn-primary:hover { background: var(--accent-hover); }

/* Branch Selector */
#branch-selector { display: none; align-items: center; gap: 8px; padding: 8px 12px; background: var(--bg-secondary); border-bottom: 1px solid var(--border-color); font-size: 13px; }
#branch-selector select { padding: 4px 8px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px; cursor: pointer; }
.branch-tree-btn { width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; background: transparent; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
.branch-tree-btn:hover { background: var(--bg-hover); }

/* Branch Tree Modal */
.branch-tree-modal { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.8); display: flex; align-items: center; justify-content: center; z-index: 1000; padding: 24px; }
.branch-tree-content { background: var(--bg-primary); border-radius: 12px; width: 100%; max-width: 400px; overflow: hidden; }
.branch-tree-header { display: flex; align-items: center; justify-content: space-between; padding: 16px; border-bottom: 1px solid var(--border-color); font-weight: 500; }
.branch-tree-header button { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; background: transparent; border: none; border-radius: 6px; color: var(--text-secondary); cursor: pointer; }
.branch-tree-body { padding: 8px; max-height: 400px; overflow-y: auto; }
.branch-item { display: flex; align-items: center; gap: 8px; padding: 10px 12px; border-radius: 6px; cursor: pointer; transition: all 0.2s; }
.branch-item:hover { background: var(--bg-hover); }
.branch-item.active { background: rgba(16, 163, 127, 0.2); }
.branch-name { font-weight: 500; }
.branch-info { margin-left: auto; font-size: 12px; color: var(--text-muted); }

/* Toast Notification */
.toast { position: fixed; bottom: 80px; left: 50%; transform: translateX(-50%); padding: 12px 24px; background: var(--bg-tertiary); border: 1px solid var(--border-color); border-radius: 8px; color: var(--text-primary); font-size: 14px; z-index: 1100; animation: slideUp 0.3s ease-out, fadeOut 0.3s ease-in 1.7s forwards; }
@keyframes slideUp { from { opacity: 0; transform: translateX(-50%) translateY(20px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
    </style>
</head>
<body>
    <div class="app-container">
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn" id="new-chat-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="12" y1="5" x2="12" y2="19"></line>
                        <line x1="5" y1="12" x2="19" y2="12"></line>
                    </svg>
                    New Chat
                </button>
                <button class="sidebar-close-btn" id="sidebar-close-btn" title="Close sidebar">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M11 19l-7-7 7-7M18 19l-7-7 7-7"/>
                    </svg>
                </button>
            </div>
            <div class="sidebar-actions">
                <button class="sidebar-action-btn" id="create-folder-btn" title="Create folder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/><line x1="12" y1="11" x2="12" y2="17"/><line x1="9" y1="14" x2="15" y2="14"/></svg>
                    Folder
                </button>
                <button class="sidebar-action-btn" id="toggle-archived-btn" title="Show archived">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="21 8 21 21 3 21 3 8"/><rect x="1" y="3" width="22" height="5"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
                    Archived
                </button>
            </div>
            <div class="sessions-list" id="sessions-list"></div>
            <div class="sidebar-footer">
                <div>Jotty v1.0</div>
                <div style="margin-top: 4px;">Multi-Agent AI Assistant</div>
            </div>
        </aside>
        <main class="main-content">
            <header class="header">
                <button class="menu-toggle" id="menu-toggle">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                <span class="header-title">Jotty</span>
                <span class="session-id" id="session-id"></span>
                <div class="header-actions">
                    <button class="header-btn config-badge" id="config-btn" data-count="0" onclick="jottyApp && jottyApp.showConfigModal && jottyApp.showConfigModal()" title="Configure widgets & tools">âš™ï¸</button>
                    <button class="header-btn" id="info-btn" onclick="jottyApp && jottyApp.toggleContextPanel && jottyApp.toggleContextPanel()" title="Context details">â„¹ï¸</button>
                </div>
            </header>
            <div class="connection-status disconnected" id="connection-status">
                <span class="connection-dot"></span>
                Connecting...
            </div>
            <!-- Branch Selector (hidden by default) -->
            <div id="branch-selector"></div>
            <div class="chat-area" id="chat-area">
                <div class="welcome-screen" id="welcome-screen">
                    <div class="welcome-logo">ðŸ¤–</div>
                    <h1 class="welcome-title">Welcome to Jotty</h1>
                    <p class="welcome-subtitle">Your AI assistant for research, writing, analysis, and more. Start a conversation or try one of these examples:</p>
                    <div class="examples-grid">
                        <div class="example-card"><div class="example-icon">ðŸ”</div><div class="example-text">Search for the latest AI news</div></div>
                        <div class="example-card"><div class="example-icon">ðŸ“</div><div class="example-text">Create a checklist for project management</div></div>
                        <div class="example-card"><div class="example-icon">ðŸ§ </div><div class="example-text">Explain how transformers work</div></div>
                        <div class="example-card"><div class="example-icon">ðŸ“Š</div><div class="example-text">Analyze market trends for 2024</div></div>
                    </div>
                </div>
                <div class="messages-container" id="messages-container" style="display: none;"></div>
            </div>
            <div class="input-area">
                <div class="input-container">
                    <!-- Agent/Swarm Mode Selector -->
                    <div id="agent-selector"></div>
                    <!-- Attachment Previews -->
                    <div id="attachment-previews" class="attachment-previews" style="display: none;"></div>
                    <div class="input-wrapper">
                        <!-- Toolbar Buttons -->
                        <input type="file" id="file-input" accept="image/*,.pdf,.doc,.docx,.txt,.md,.csv,.json,.pptx,.html" multiple hidden>
                        <button class="toolbar-btn" onclick="document.getElementById('file-input').click()" title="Attach files (images, PDFs, docs)">ðŸ“Ž</button>
                        <button class="toolbar-btn" id="voice-btn" onclick="jottyApp && jottyApp.toggleVoice && jottyApp.toggleVoice()" title="Voice to text">ðŸŽ¤</button>
                        <button class="toolbar-btn" id="wake-word-btn" onclick="jottyApp && jottyApp.toggleWakeWord && jottyApp.toggleWakeWord()" title='Enable wake word ("Hey Jotty")'>ðŸ‘‚</button>
                        <button class="toolbar-btn" id="continuous-btn" onclick="jottyApp && jottyApp.toggleContinuousMode && jottyApp.toggleContinuousMode()" title="Enable continuous conversation">ðŸ”„</button>
                        <button class="toolbar-btn" id="transcript-btn" onclick="jottyApp && jottyApp.toggleTranscriptPanel && jottyApp.toggleTranscriptPanel()" title="Show transcript">ðŸ“</button>
                        <textarea class="message-input" id="message-input" placeholder="Message Jotty..." rows="1"></textarea>
                        <div class="voice-chat-wrapper">
                            <div class="audio-level-meter" id="audio-level-meter">
                                <div class="level-bar" id="level-bar"></div>
                            </div>
                            <button class="voice-chat-btn" id="voice-chat-btn" onclick="jottyApp && jottyApp.toggleVoiceChat && jottyApp.toggleVoiceChat()" title="Voice chat (speak & listen)">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
                            </button>
                            <button class="voice-picker-btn" id="voice-picker-btn" onclick="jottyApp && jottyApp.toggleVoicePicker && jottyApp.toggleVoicePicker()" title="Select voice">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>
                            </button>
                            <div class="voice-picker-dropdown" id="voice-picker-dropdown"></div>
                        </div>
                        <button class="send-btn" id="send-btn">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="22" y1="2" x2="11" y2="13"></line>
                                <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
                            </svg>
                        </button>
                    </div>
                    <div class="input-hint">Press Enter to send, Shift+Enter for new line | ðŸŽ¤ Voice | ðŸ“Ž Attach</div>
                </div>
            </div>
        </main>
    </div>

    <!-- Config Modal -->
    <div id="config-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Configuration</h3>
                <button onclick="jottyApp && jottyApp.hideConfigModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="config-tabs">
                    <button class="active" onclick="jottyApp && jottyApp.showConfigTab('widgets')">Widgets</button>
                    <button onclick="jottyApp && jottyApp.showConfigTab('tools')">Tools</button>
                    <button onclick="jottyApp && jottyApp.showConfigTab('models')">Models</button>
                </div>
                <div id="config-widgets" class="config-tab-content active">
                    <div class="config-category">
                        <h4>Loading...</h4>
                    </div>
                </div>
                <div id="config-tools" class="config-tab-content">
                    <div class="config-category">
                        <h4>Loading...</h4>
                    </div>
                </div>
                <div id="config-models" class="config-tab-content">
                    <div class="config-category">
                        <h4>Loading models...</h4>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Panel -->
    <div id="context-panel" class="context-panel">
        <div class="panel-header">
            <h3>Context</h3>
            <button onclick="jottyApp && jottyApp.toggleContextPanel()">&times;</button>
        </div>
        <div id="context-panel-content">
            <!-- Populated by JavaScript -->
        </div>
    </div>

    <!-- Transcript Panel -->
    <div id="transcript-panel" class="transcript-panel">
        <div class="panel-header">
            <h3>ðŸ“ Transcript</h3>
            <div class="panel-actions">
                <button onclick="jottyApp && jottyApp.copyTranscript()" title="Copy">ðŸ“‹</button>
                <button onclick="jottyApp && jottyApp.exportTranscriptText()" title="Export text">ðŸ’¾</button>
                <button onclick="jottyApp && jottyApp.exportConversationAudio()" title="Export audio">ðŸŽµ</button>
                <button onclick="jottyApp && jottyApp.clearTranscript()" title="Clear">ðŸ—‘ï¸</button>
                <button onclick="jottyApp && jottyApp.toggleTranscriptPanel()">&times;</button>
            </div>
        </div>
        <div id="transcript-content" class="transcript-content">
            <p class="transcript-empty">Voice transcripts will appear here...</p>
        </div>
    </div>

    <script>
class JottyApp {
    constructor() {
        this.sessionId = null;
        this.ws = null;
        this.messages = [];
        this.isProcessing = false;
        this.streamingContent = '';
        // Session management state
        this.sessions = [];
        this.folders = [];
        this.showArchived = false;
        this.activeContextMenu = null;
        this.renamingSession = null;
        this.expandedFolders = new Set();
        this.renamingFolder = null;
        this.activeFolderMenu = null;
        // Document & Context state
        this.folderDocuments = {};  // folderId -> [documents]
        this.chatContext = null;    // { type: 'folder'|'document'|'chat', id, name }
        this.suggestedActions = []; // AI-suggested follow-up actions
        // New features state (DRY - from unified registries)
        this.capabilities = null;       // Loaded from /api/capabilities
        this.enabledWidgets = [];
        this.enabledTools = [];
        this.agents = [];
        this.chatMode = 'raw';          // raw | agent | swarm
        this.selectedAgent = null;
        this.swarmMode = 'auto';        // auto | manual | workflow
        this.attachments = [];
        this.isListening = false;
        this.recognition = null;
        this.theme = localStorage.getItem('jotty_theme') || 'dark';
        // Detect proxy path and build URLs accordingly
        const path = window.location.pathname;
        const proxyMatch = path.match(/^(\/proxy\/\d+)/) || path.match(/^(\/jotty-web)/);
        if (proxyMatch) {
            // Running behind proxy - use proxy-relative paths
            this.apiBase = proxyMatch[1];
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            this.wsBase = `${wsProtocol}//${window.location.host}${proxyMatch[1]}`;
        } else {
            // Direct access - use relative paths
            this.apiBase = '';
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            this.wsBase = `${wsProtocol}//${window.location.host}`;
        }
        // Test API and detect correct base (for port mismatch scenarios)
        this.detectApiBase();
        this.init();
    }
    async detectApiBase() {
        // Test if current apiBase works, if not try common alternatives
        const testBases = [this.apiBase, '', '/proxy/8081'];
        for (const base of testBases) {
            try {
                const response = await fetch(`${base}/health`, { method: 'GET', signal: AbortSignal.timeout(2000) });
                if (response.ok) {
                    if (base !== this.apiBase) {
                        console.log(`API base changed from "${this.apiBase}" to "${base}"`);
                        this.apiBase = base;
                    }
                    return;
                }
            } catch (e) { /* continue to next */ }
        }
        console.log('Could not detect API base, using default');
    }
    init() {
        this.chatArea = document.getElementById('chat-area');
        this.messagesContainer = document.getElementById('messages-container');
        this.messageInput = document.getElementById('message-input');
        this.sendBtn = document.getElementById('send-btn');
        this.newChatBtn = document.getElementById('new-chat-btn');
        this.sessionsList = document.getElementById('sessions-list');
        this.sessionIdDisplay = document.getElementById('session-id');
        this.menuToggle = document.getElementById('menu-toggle');
        this.sidebar = document.getElementById('sidebar');
        this.connectionStatus = document.getElementById('connection-status');
        this.welcomeScreen = document.getElementById('welcome-screen');
        this.sendBtn.addEventListener('click', () => this.sendMessage());
        this.messageInput.addEventListener('keydown', (e) => this.handleKeydown(e));
        this.messageInput.addEventListener('input', (e) => { this.autoResize(); this.handleCommandAutocomplete(e); });
        this.commands = [];
        this.loadCommands();
        this.newChatBtn.addEventListener('click', () => this.newChat());
        this.menuToggle?.addEventListener('click', () => this.toggleSidebar());
        // Sidebar close button
        document.getElementById('sidebar-close-btn')?.addEventListener('click', () => this.toggleSidebar());
        // Sidebar action buttons
        document.getElementById('create-folder-btn')?.addEventListener('click', () => this.showFolderModal());
        document.getElementById('toggle-archived-btn')?.addEventListener('click', () => this.toggleArchived());
        // Close context menus on outside click
        document.addEventListener('click', (e) => {
            if (this.activeContextMenu && !e.target.closest('.session-context-menu') && !e.target.closest('.session-menu-btn')) {
                this.closeContextMenu();
            }
            if (this.activeFolderMenu && !e.target.closest('.folder-context-menu') && !e.target.closest('.folder-menu-btn')) {
                this.closeFolderContextMenu();
            }
        });
        document.querySelectorAll('.example-card').forEach(card => {
            card.addEventListener('click', () => {
                const text = card.querySelector('.example-text').textContent;
                this.messageInput.value = text;
                this.messageInput.focus();
                this.autoResize();
            });
        });
        this.loadSessions();
        this.loadFolders();
        this.loadFolderDocuments();
        // Initialize new features
        this.loadCapabilities();
        this.applyTheme();
        this.initVoice();
        this.initVoiceChat();
        this.initFileInput();
        this.newChat();
    }
    generateSessionId() { return 'web_' + Math.random().toString(36).substr(2, 8); }
    async loadSessions() {
        try {
            const response = await fetch(`${this.apiBase}/api/sessions`);
            const data = await response.json();
            this.sessions = data.sessions || [];
            this.renderSessions();
        } catch (error) { console.error('Failed to load sessions:', error); }
    }
    async loadFolders() {
        try {
            const response = await fetch(`${this.apiBase}/api/folders`);
            if (response.ok) {
                const data = await response.json();
                this.folders = data.folders || [];
            }
        } catch (error) {
            console.log('Folders API not available, using local storage');
            this.folders = JSON.parse(localStorage.getItem('jotty_folders') || '[]');
        }
        this.renderSessions();
    }
    renderSessions() {
        if (!this.sessionsList) return;
        // Filter based on archived state
        let filteredSessions = this.sessions.filter(s =>
            this.showArchived ? s.isArchived : !s.isArchived
        );
        // Group sessions
        const pinned = filteredSessions.filter(s => s.isPinned && !s.folderId);
        const uncategorized = filteredSessions.filter(s => !s.isPinned && !s.folderId);
        const byFolder = {};
        this.folders.forEach(f => { byFolder[f.id] = filteredSessions.filter(s => s.folderId === f.id); });

        let html = '';
        // Update archived button state
        const archivedBtn = document.getElementById('toggle-archived-btn');
        if (archivedBtn) {
            archivedBtn.classList.toggle('active', this.showArchived);
        }
        // Pinned section
        if (pinned.length > 0) {
            html += `<div class="sessions-section">
                <div class="sessions-section-header"><svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M16 12V4h1V2H7v2h1v8l-2 2v2h5.2v6h1.6v-6H18v-2l-2-2z"/></svg>Pinned<span class="count">${pinned.length}</span></div>
                ${pinned.map(s => this.renderSessionItem(s)).join('')}
            </div>`;
        }
        // Folders with documents
        this.folders.forEach((folder, index) => {
            const folderSessions = byFolder[folder.id] || [];
            const folderDocs = this.folderDocuments[folder.id] || [];
            const isExpanded = this.expandedFolders.has(folder.id);
            const isRenaming = this.renamingFolder === folder.id;
            const totalItems = folderSessions.length + folderDocs.length;

            html += `<div class="folder-item ${isExpanded ? '' : 'collapsed'}" data-folder-id="${folder.id}" data-folder-index="${index}">
                <svg class="folder-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="9 18 15 12 9 6"/></svg>
                <div class="folder-color" style="background:${folder.color}" data-folder-id="${folder.id}"></div>
                ${isRenaming
                    ? `<input type="text" class="folder-name-input" value="${folder.name}" data-folder-id="${folder.id}">`
                    : `<span class="folder-name">${folder.name}</span>`
                }
                ${folderDocs.length > 0 ? `<span class="folder-docs"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>${folderDocs.length}</span>` : ''}
                <span class="folder-count">${folderSessions.length}</span>
                <button class="chat-context-btn" data-context-type="folder" data-context-id="${folder.id}" data-context-name="${folder.name}" onclick="event.stopPropagation(); jottyApp.setChatContext('folder', '${folder.id}', '${folder.name}');" title="Chat with this folder">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                </button>
                <button class="folder-menu-btn" data-folder-id="${folder.id}" onclick="event.stopPropagation();">
                    <svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg>
                </button>
            </div>`;

            if (isExpanded) {
                html += `<div class="folder-content">`;
                // Upload dropzone
                html += `<div class="upload-dropzone" data-folder-id="${folder.id}">
                    <input type="file" id="upload-input-${folder.id}" data-folder-id="${folder.id}" multiple accept=".pdf,.docx,.doc,.pptx,.ppt,.txt,.md,.csv,.json,.html,.htm,.epub" style="display:none;">
                    <div class="upload-dropzone-icon">ðŸ“„</div>
                    <div class="upload-dropzone-text">Drop files or click to upload</div>
                    <div class="upload-dropzone-hint">PDF, DOCX, TXT, MD, CSV, JSON</div>
                </div>`;
                // Documents list
                if (folderDocs.length > 0) {
                    html += `<div class="folder-documents">`;
                    folderDocs.forEach(doc => {
                        const icon = this.getDocIcon(doc.file_type);
                        const size = this.formatFileSize(doc.file_size);
                        html += `<div class="document-item" data-doc-id="${doc.id}">
                            <div class="document-icon ${icon.class}">${icon.emoji}</div>
                            <div class="document-info">
                                <div class="document-name">${doc.filename}</div>
                                <div class="document-meta"><span>${size}</span><span>${doc.chunk_count || 0} chunks</span></div>
                            </div>
                            <div class="document-actions">
                                <button class="document-action-btn chat" data-doc-id="${doc.id}" data-doc-name="${doc.filename}" title="Chat with document" onclick="event.stopPropagation(); jottyApp.setChatContext('document', '${doc.id}', '${doc.filename}');">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                                </button>
                                <button class="document-action-btn" data-doc-id="${doc.id}" title="View document" onclick="event.stopPropagation(); jottyApp.viewDocument('${doc.id}');">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                                </button>
                                <button class="document-action-btn delete" data-doc-id="${doc.id}" title="Delete document" onclick="event.stopPropagation(); jottyApp.deleteDocument('${doc.id}');">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                                </button>
                            </div>
                        </div>`;
                    });
                    html += `</div>`;
                }
                // Sessions
                if (folderSessions.length > 0) {
                    html += `<div class="folder-sessions">${folderSessions.map(s => this.renderSessionItem(s)).join('')}</div>`;
                }
                html += `</div>`;
            }
        });
        // Uncategorized (grouped by date)
        if (uncategorized.length > 0) {
            const today = new Date().toDateString();
            const yesterday = new Date(Date.now() - 86400000).toDateString();
            const grouped = { today: [], yesterday: [], older: [] };
            uncategorized.forEach(session => {
                const date = new Date(session.created_at).toDateString();
                if (date === today) grouped.today.push(session);
                else if (date === yesterday) grouped.yesterday.push(session);
                else grouped.older.push(session);
            });
            if (grouped.today.length > 0) html += this.renderSessionGroup('Today', grouped.today);
            if (grouped.yesterday.length > 0) html += this.renderSessionGroup('Yesterday', grouped.yesterday);
            if (grouped.older.length > 0) html += this.renderSessionGroup('Previous', grouped.older);
        }
        this.sessionsList.innerHTML = html || `<div style="padding:20px;text-align:center;color:var(--text-muted);font-size:13px;">${this.showArchived ? 'No archived chats' : 'No conversations yet'}</div>`;
        this.attachSessionListeners();
    }
    renderSessionGroup(title, sessions) {
        return `<div class="sessions-section">
            <div class="sessions-section-header"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>${title}<span class="count">${sessions.length}</span></div>
            ${sessions.map(s => this.renderSessionItem(s)).join('')}
        </div>`;
    }
    renderSessionItem(session) {
        const isActive = session.session_id === this.sessionId;
        const isRenaming = this.renamingSession === session.session_id;
        const title = this.getSessionTitle(session);
        const iconClass = session.isPinned ? 'pinned' : '';
        const icon = session.isPinned
            ? '<svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M16 12V4h1V2H7v2h1v8l-2 2v2h5.2v6h1.6v-6H18v-2l-2-2z"/></svg>'
            : '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>';
        return `<div class="session-item ${isActive ? 'active' : ''}" data-session-id="${session.session_id}">
            <span class="session-icon ${iconClass}">${icon}</span>
            ${isRenaming
                ? `<input type="text" class="session-title-input" value="${title}" data-session-id="${session.session_id}">`
                : `<span class="session-title">${title}</span>`
            }
            <button class="session-menu-btn" data-session-id="${session.session_id}">
                <svg viewBox="0 0 24 24" fill="currentColor"><circle cx="12" cy="5" r="2"/><circle cx="12" cy="12" r="2"/><circle cx="12" cy="19" r="2"/></svg>
            </button>
        </div>`;
    }
    attachSessionListeners() {
        // Session item click (load session)
        this.sessionsList.querySelectorAll('.session-item').forEach(item => {
            item.addEventListener('click', (e) => {
                if (e.target.closest('.session-menu-btn') || e.target.closest('.session-context-menu')) return;
                const id = item.dataset.sessionId;
                if (id && this.renamingSession !== id) this.loadSession(id);
            });
        });
        // Menu button click
        this.sessionsList.querySelectorAll('.session-menu-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = btn.dataset.sessionId;
                this.toggleContextMenu(id, btn);
            });
        });
        // Folder click (expand/collapse)
        this.sessionsList.querySelectorAll('.folder-item').forEach(item => {
            item.addEventListener('click', (e) => {
                // Don't expand if clicking menu or color
                if (e.target.closest('.folder-menu-btn') || e.target.closest('.folder-color') || e.target.closest('.folder-name-input')) return;
                const id = item.dataset.folderId;
                this.toggleFolderExpand(id);
            });
        });
        // Folder menu button click
        this.sessionsList.querySelectorAll('.folder-menu-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = btn.dataset.folderId;
                this.toggleFolderContextMenu(id, btn);
            });
        });
        // Folder color click (quick color change)
        this.sessionsList.querySelectorAll('.folder-color').forEach(dot => {
            dot.addEventListener('click', (e) => {
                e.stopPropagation();
                const id = dot.dataset.folderId;
                this.showFolderColorPicker(id, dot);
            });
        });
        // Folder rename input
        this.sessionsList.querySelectorAll('.folder-name-input').forEach(input => {
            input.addEventListener('click', (e) => e.stopPropagation());
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') this.saveFolderRename(input.dataset.folderId, input.value);
                if (e.key === 'Escape') this.cancelFolderRename();
            });
            input.addEventListener('blur', () => this.saveFolderRename(input.dataset.folderId, input.value));
            input.focus();
            input.select();
        });
        // Rename input
        this.sessionsList.querySelectorAll('.session-title-input').forEach(input => {
            input.addEventListener('click', (e) => e.stopPropagation());
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') this.saveRename(input.dataset.sessionId, input.value);
                if (e.key === 'Escape') this.cancelRename();
            });
            input.addEventListener('blur', () => this.saveRename(input.dataset.sessionId, input.value));
            input.focus();
            input.select();
        });
        // File upload handlers
        this.sessionsList.querySelectorAll('input[type="file"]').forEach(input => {
            input.addEventListener('change', async (e) => {
                const files = e.target.files;
                const folderId = input.dataset.folderId;
                for (const file of files) {
                    await this.uploadDocument(file, folderId);
                }
                input.value = ''; // Reset input
            });
        });
        // Drag and drop on upload zones
        this.sessionsList.querySelectorAll('.upload-dropzone').forEach(zone => {
            // Stop propagation to prevent folder collapse when clicking dropzone
            zone.addEventListener('click', (e) => {
                e.stopPropagation();
                const folderId = zone.dataset.folderId;
                const input = document.getElementById(`upload-input-${folderId}`);
                if (input) {
                    console.log('Triggering file input for folder:', folderId);
                    input.click();
                } else {
                    console.error('File input not found for folder:', folderId);
                }
            });
            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                zone.classList.add('dragover');
            });
            zone.addEventListener('dragleave', () => {
                zone.classList.remove('dragover');
            });
            zone.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                zone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                const folderId = zone.dataset.folderId;
                console.log('Drop detected, files:', files.length, 'folder:', folderId);
                for (const file of files) {
                    await this.uploadDocument(file, folderId);
                }
            });
        });
    }
    getSessionTitle(session) {
        if (session.title) return session.title;
        if (session.history && session.history.length > 0) {
            const firstUser = session.history.find(m => m.role === 'user');
            if (firstUser) return firstUser.content.substring(0, 30) + (firstUser.content.length > 30 ? '...' : '');
        }
        return `Chat ${session.session_id.substring(0, 8)}`;
    }
    toggleContextMenu(sessionId, buttonElement) {
        // Remove any existing context menu
        const existingMenu = document.getElementById('session-context-menu');
        if (existingMenu) existingMenu.remove();

        if (this.activeContextMenu === sessionId) {
            this.activeContextMenu = null;
            return;
        }

        this.activeContextMenu = sessionId;
        const session = this.sessions.find(s => s.session_id === sessionId);
        if (!session) return;

        // Get button position
        const btn = buttonElement || this.sessionsList.querySelector(`.session-menu-btn[data-session-id="${sessionId}"]`);
        if (!btn) return;
        const rect = btn.getBoundingClientRect();

        // Create menu element
        const menu = document.createElement('div');
        menu.id = 'session-context-menu';
        menu.className = 'session-context-menu';
        menu.innerHTML = this.renderContextMenuContent(session);

        // Position menu
        menu.style.top = `${rect.bottom + 4}px`;
        menu.style.left = `${Math.min(rect.left, window.innerWidth - 190)}px`;

        document.body.appendChild(menu);

        // Attach menu item listeners
        menu.querySelectorAll('.menu-item[data-action]').forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const action = item.dataset.action;
                const sid = item.dataset.sessionId;
                const folderId = item.dataset.folderId;
                this.handleSessionAction(action, sid, folderId);
            });
        });
    }
    renderContextMenuContent(session) {
        let html = `
            <div class="menu-item" data-action="pin" data-session-id="${session.session_id}">
                <svg viewBox="0 0 24 24" fill="${session.isPinned ? 'currentColor' : 'none'}" stroke="currentColor" stroke-width="2"><path d="M16 12V4h1V2H7v2h1v8l-2 2v2h5.2v6h1.6v-6H18v-2l-2-2z"/></svg>
                ${session.isPinned ? 'Unpin' : 'Pin'}
            </div>
            <div class="menu-item" data-action="rename" data-session-id="${session.session_id}">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                Rename
            </div>
            <div class="menu-item" data-action="archive" data-session-id="${session.session_id}">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="21 8 21 21 3 21 3 8"/><rect x="1" y="3" width="22" height="5"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
                ${session.isArchived ? 'Unarchive' : 'Archive'}
            </div>
            <div class="menu-divider"></div>
            <div class="menu-item danger" data-action="delete" data-session-id="${session.session_id}">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                Delete
            </div>`;

        if (this.folders.length > 0) {
            html += `<div class="menu-divider"></div>
                <div class="menu-submenu-title" style="padding:6px 12px;font-size:10px;color:var(--text-muted);text-transform:uppercase;">Move to folder</div>
                <div class="menu-item" data-action="moveto" data-session-id="${session.session_id}" data-folder-id="">
                    No folder
                </div>`;
            this.folders.forEach(f => {
                html += `<div class="menu-item" data-action="moveto" data-session-id="${session.session_id}" data-folder-id="${f.id}">
                    <div style="width:10px;height:10px;border-radius:3px;background:${f.color}"></div>
                    ${f.name}
                </div>`;
            });
        }
        return html;
    }
    closeContextMenu() {
        this.activeContextMenu = null;
        const existingMenu = document.getElementById('session-context-menu');
        if (existingMenu) existingMenu.remove();
    }
    toggleArchived() {
        this.showArchived = !this.showArchived;
        this.renderSessions();
    }
    toggleFolderExpand(folderId) {
        if (this.expandedFolders.has(folderId)) {
            this.expandedFolders.delete(folderId);
        } else {
            this.expandedFolders.add(folderId);
        }
        this.renderSessions();
    }
    handleSessionAction(action, sessionId, folderId) {
        const session = this.sessions.find(s => s.session_id === sessionId);
        if (!session) return;
        switch(action) {
            case 'pin':
                this.togglePin(sessionId, !session.isPinned);
                break;
            case 'rename':
                this.startRename(sessionId);
                break;
            case 'archive':
                this.toggleArchive(sessionId, !session.isArchived);
                break;
            case 'delete':
                if (confirm('Delete this conversation?')) this.deleteSession(sessionId);
                break;
            case 'moveto':
                this.moveToFolder(sessionId, folderId || null);
                break;
        }
        this.closeContextMenu();
    }
    startRename(sessionId) {
        this.renamingSession = sessionId;
        this.renderSessions();
    }
    cancelRename() {
        this.renamingSession = null;
        this.renderSessions();
    }
    async saveRename(sessionId, newTitle) {
        if (!newTitle.trim()) {
            this.cancelRename();
            return;
        }
        const session = this.sessions.find(s => s.session_id === sessionId);
        if (session) session.title = newTitle.trim();
        this.renamingSession = null;
        await this.updateSession(sessionId, { title: newTitle.trim() });
        this.renderSessions();
    }
    async togglePin(sessionId, pinned) {
        const session = this.sessions.find(s => s.session_id === sessionId);
        if (session) session.isPinned = pinned;
        await this.updateSession(sessionId, { isPinned: pinned });
        this.renderSessions();
    }
    async toggleArchive(sessionId, archived) {
        const session = this.sessions.find(s => s.session_id === sessionId);
        if (session) session.isArchived = archived;
        await this.updateSession(sessionId, { isArchived: archived });
        if (this.sessionId === sessionId) this.newChat();
        this.renderSessions();
    }
    async moveToFolder(sessionId, folderId) {
        const session = this.sessions.find(s => s.session_id === sessionId);
        if (session) session.folderId = folderId;
        await this.updateSession(sessionId, { folderId: folderId });
        this.renderSessions();
    }
    async deleteSession(sessionId) {
        try {
            await fetch(`${this.apiBase}/api/sessions/${sessionId}`, { method: 'DELETE' });
            this.sessions = this.sessions.filter(s => s.session_id !== sessionId);
            if (this.sessionId === sessionId) this.newChat();
            this.renderSessions();
        } catch (error) { console.error('Failed to delete session:', error); }
    }
    async updateSession(sessionId, updates) {
        try {
            await fetch(`${this.apiBase}/api/sessions/${sessionId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(updates)
            });
        } catch (error) {
            console.log('Session update not persisted (API may not support PATCH)');
            // Store locally as fallback
            const localSessions = JSON.parse(localStorage.getItem('jotty_session_meta') || '{}');
            localSessions[sessionId] = { ...localSessions[sessionId], ...updates };
            localStorage.setItem('jotty_session_meta', JSON.stringify(localSessions));
        }
    }
    showFolderModal() {
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#14b8a6', '#3b82f6', '#8b5cf6', '#ec4899'];
        const modal = document.createElement('div');
        modal.className = 'folder-modal-overlay';
        modal.innerHTML = `<div class="folder-modal">
            <h3>Create Folder</h3>
            <input type="text" id="folder-name-input" placeholder="Folder name" autofocus>
            <div class="color-picker">
                ${colors.map((c, i) => `<div class="color-option ${i===0?'selected':''}" data-color="${c}" style="background:${c}"></div>`).join('')}
            </div>
            <div class="modal-actions">
                <button class="cancel-btn">Cancel</button>
                <button class="create-btn">Create</button>
            </div>
        </div>`;
        document.body.appendChild(modal);
        let selectedColor = colors[0];
        modal.querySelectorAll('.color-option').forEach(opt => {
            opt.addEventListener('click', () => {
                modal.querySelectorAll('.color-option').forEach(o => o.classList.remove('selected'));
                opt.classList.add('selected');
                selectedColor = opt.dataset.color;
            });
        });
        modal.querySelector('.cancel-btn').addEventListener('click', () => modal.remove());
        modal.querySelector('.create-btn').addEventListener('click', () => {
            const name = modal.querySelector('#folder-name-input').value.trim();
            if (name) {
                this.createFolder(name, selectedColor);
                modal.remove();
            }
        });
        modal.querySelector('#folder-name-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') modal.querySelector('.create-btn').click();
            if (e.key === 'Escape') modal.remove();
        });
        modal.addEventListener('click', (e) => { if (e.target === modal) modal.remove(); });
    }
    async createFolder(name, color) {
        const folder = { id: 'folder_' + Date.now(), name, color, order: this.folders.length };
        this.folders.push(folder);
        // Store locally
        localStorage.setItem('jotty_folders', JSON.stringify(this.folders));
        // Try API
        try {
            await fetch(`${this.apiBase}/api/folders`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(folder)
            });
        } catch (error) { console.log('Folders stored locally'); }
        this.renderSessions();
    }

    // ===== FOLDER MANAGEMENT =====
    toggleFolderContextMenu(folderId, buttonElement) {
        // Close any existing menu
        this.closeFolderContextMenu();
        this.closeContextMenu();

        if (this.activeFolderMenu === folderId) {
            this.activeFolderMenu = null;
            return;
        }

        this.activeFolderMenu = folderId;
        const folder = this.folders.find(f => f.id === folderId);
        if (!folder) return;

        const rect = buttonElement.getBoundingClientRect();
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#14b8a6', '#3b82f6', '#8b5cf6', '#ec4899'];
        const folderIndex = this.folders.findIndex(f => f.id === folderId);

        const menu = document.createElement('div');
        menu.id = 'folder-context-menu';
        menu.className = 'folder-context-menu';
        menu.innerHTML = `
            <div class="menu-item" data-action="rename" data-folder-id="${folderId}">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                Rename
            </div>
            <div class="menu-divider"></div>
            <div style="padding:4px 12px;font-size:10px;color:var(--text-muted);text-transform:uppercase;">Color</div>
            <div class="color-row">
                ${colors.map(c => `<div class="color-dot ${folder.color === c ? 'active' : ''}" data-color="${c}" data-folder-id="${folderId}" style="background:${c}"></div>`).join('')}
            </div>
            <div class="menu-divider"></div>
            <div class="menu-item ${folderIndex === 0 ? 'disabled' : ''}" data-action="moveup" data-folder-id="${folderId}" ${folderIndex === 0 ? 'style="opacity:0.4;pointer-events:none;"' : ''}>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="18 15 12 9 6 15"/></svg>
                Move Up
            </div>
            <div class="menu-item ${folderIndex === this.folders.length - 1 ? 'disabled' : ''}" data-action="movedown" data-folder-id="${folderId}" ${folderIndex === this.folders.length - 1 ? 'style="opacity:0.4;pointer-events:none;"' : ''}>
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                Move Down
            </div>
            <div class="menu-divider"></div>
            <div class="menu-item danger" data-action="delete" data-folder-id="${folderId}">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                Delete Folder
            </div>
        `;

        menu.style.top = `${rect.bottom + 4}px`;
        menu.style.left = `${Math.min(rect.left, window.innerWidth - 190)}px`;
        document.body.appendChild(menu);

        // Menu item listeners
        menu.querySelectorAll('.menu-item[data-action]').forEach(item => {
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                const action = item.dataset.action;
                const id = item.dataset.folderId;
                this.handleFolderAction(action, id);
            });
        });

        // Color dot listeners
        menu.querySelectorAll('.color-dot').forEach(dot => {
            dot.addEventListener('click', (e) => {
                e.stopPropagation();
                this.changeFolderColor(dot.dataset.folderId, dot.dataset.color);
            });
        });
    }

    closeFolderContextMenu() {
        this.activeFolderMenu = null;
        const menu = document.getElementById('folder-context-menu');
        if (menu) menu.remove();
    }

    handleFolderAction(action, folderId) {
        switch (action) {
            case 'rename':
                this.startFolderRename(folderId);
                break;
            case 'delete':
                if (confirm('Delete this folder? Sessions inside will be moved to uncategorized.')) {
                    this.deleteFolder(folderId);
                }
                break;
            case 'moveup':
                this.moveFolderUp(folderId);
                break;
            case 'movedown':
                this.moveFolderDown(folderId);
                break;
        }
        this.closeFolderContextMenu();
    }

    startFolderRename(folderId) {
        this.renamingFolder = folderId;
        this.renderSessions();
    }

    cancelFolderRename() {
        this.renamingFolder = null;
        this.renderSessions();
    }

    async saveFolderRename(folderId, newName) {
        if (!newName.trim()) {
            this.cancelFolderRename();
            return;
        }
        const folder = this.folders.find(f => f.id === folderId);
        if (folder) {
            folder.name = newName.trim();
            await this.saveFolders();
        }
        this.renamingFolder = null;
        this.renderSessions();
    }

    async changeFolderColor(folderId, color) {
        const folder = this.folders.find(f => f.id === folderId);
        if (folder) {
            folder.color = color;
            await this.saveFolders();
        }
        this.closeFolderContextMenu();
        this.renderSessions();
    }

    showFolderColorPicker(folderId, element) {
        // Quick color picker popup
        const colors = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#14b8a6', '#3b82f6', '#8b5cf6', '#ec4899'];
        const folder = this.folders.find(f => f.id === folderId);
        if (!folder) return;

        // Remove any existing picker
        const existing = document.getElementById('quick-color-picker');
        if (existing) existing.remove();

        const rect = element.getBoundingClientRect();
        const picker = document.createElement('div');
        picker.id = 'quick-color-picker';
        picker.className = 'folder-context-menu';
        picker.style.cssText = `top:${rect.bottom + 4}px;left:${rect.left}px;width:auto;padding:8px;`;
        picker.innerHTML = `<div class="color-row" style="padding:0;">
            ${colors.map(c => `<div class="color-dot ${folder.color === c ? 'active' : ''}" data-color="${c}" style="background:${c}"></div>`).join('')}
        </div>`;

        document.body.appendChild(picker);

        picker.querySelectorAll('.color-dot').forEach(dot => {
            dot.addEventListener('click', (e) => {
                e.stopPropagation();
                this.changeFolderColor(folderId, dot.dataset.color);
                picker.remove();
            });
        });

        // Close on outside click
        setTimeout(() => {
            document.addEventListener('click', function handler(e) {
                if (!picker.contains(e.target)) {
                    picker.remove();
                    document.removeEventListener('click', handler);
                }
            });
        }, 10);
    }

    moveFolderUp(folderId) {
        const index = this.folders.findIndex(f => f.id === folderId);
        if (index > 0) {
            [this.folders[index], this.folders[index - 1]] = [this.folders[index - 1], this.folders[index]];
            this.saveFolders();
            this.renderSessions();
        }
    }

    moveFolderDown(folderId) {
        const index = this.folders.findIndex(f => f.id === folderId);
        if (index < this.folders.length - 1) {
            [this.folders[index], this.folders[index + 1]] = [this.folders[index + 1], this.folders[index]];
            this.saveFolders();
            this.renderSessions();
        }
    }

    async deleteFolder(folderId) {
        // Move sessions in this folder to uncategorized
        this.sessions.forEach(s => {
            if (s.folderId === folderId) {
                s.folderId = null;
                this.updateSession(s.session_id, { folderId: null });
            }
        });

        // Remove folder
        this.folders = this.folders.filter(f => f.id !== folderId);
        await this.saveFolders();

        // Try API
        try {
            await fetch(`${this.apiBase}/api/folders/${folderId}`, { method: 'DELETE' });
        } catch (e) { /* handled locally */ }

        this.renderSessions();
    }

    async saveFolders() {
        // Update order property
        this.folders.forEach((f, i) => f.order = i);
        // Save locally
        localStorage.setItem('jotty_folders', JSON.stringify(this.folders));
        // Try API
        try {
            await fetch(`${this.apiBase}/api/folders/bulk`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ folders: this.folders })
            });
        } catch (e) { console.log('Folders saved locally'); }
    }

    // ===== DOCUMENT MANAGEMENT & RAG =====

    async loadFolderDocuments() {
        // Load documents for all folders
        try {
            const response = await fetch(`${this.apiBase}/api/documents`);
            if (response.ok) {
                const data = await response.json();
                // Group by folder
                this.folderDocuments = {};
                (data.documents || []).forEach(doc => {
                    const folderId = doc.folder_id;
                    if (folderId) {
                        if (!this.folderDocuments[folderId]) this.folderDocuments[folderId] = [];
                        this.folderDocuments[folderId].push(doc);
                    }
                });
            }
        } catch (e) {
            console.log('Document API not available');
        }
    }

    async uploadDocument(file, folderId) {
        console.log('uploadDocument called:', file?.name, 'folder:', folderId);

        if (!file) {
            this.showNotification('No file selected', 'error');
            return;
        }

        const formData = new FormData();
        formData.append('file', file);
        if (folderId) formData.append('folder_id', folderId);

        try {
            // Show upload progress
            this.showUploadProgress(file.name, folderId);
            console.log('Uploading to:', `${this.apiBase}/api/documents/upload`);

            const response = await fetch(`${this.apiBase}/api/documents/upload`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const error = await response.json();
                let errorMsg = 'Upload failed';
                if (typeof error.detail === 'string') {
                    errorMsg = error.detail;
                } else if (Array.isArray(error.detail)) {
                    errorMsg = error.detail.map(e => e.msg || e).join(', ');
                } else if (error.message) {
                    errorMsg = error.message;
                }
                throw new Error(errorMsg);
            }

            const result = await response.json();

            // Update local state
            if (!this.folderDocuments[folderId]) this.folderDocuments[folderId] = [];
            this.folderDocuments[folderId].push(result.document);

            this.hideUploadProgress(folderId);
            this.renderSessions();

            // Show success notification
            this.showNotification(`Uploaded: ${file.name}`, 'success');

        } catch (error) {
            console.error('Upload failed:', error);
            this.hideUploadProgress(folderId);
            this.showNotification(`Upload failed: ${error.message}`, 'error');
        }
    }

    showUploadProgress(filename, folderId) {
        const dropzone = document.querySelector(`.upload-dropzone[data-folder-id="${folderId}"]`);
        if (dropzone) {
            dropzone.innerHTML = `
                <div class="upload-progress-header">
                    <span>Uploading ${filename}...</span>
                    <span class="upload-percent">Processing</span>
                </div>
                <div class="upload-progress-bar"><div class="upload-progress-fill" style="width:50%"></div></div>
            `;
        }
    }

    hideUploadProgress(folderId) {
        const dropzone = document.querySelector(`.upload-dropzone[data-folder-id="${folderId}"]`);
        if (dropzone) {
            dropzone.innerHTML = `
                <div class="upload-dropzone-icon">ðŸ“„</div>
                <div class="upload-dropzone-text">Drop files or click to upload</div>
                <div class="upload-dropzone-hint">PDF, DOCX, TXT, MD, CSV, JSON</div>
            `;
        }
    }

    async deleteDocument(docId) {
        if (!confirm('Delete this document?')) return;

        try {
            const response = await fetch(`${this.apiBase}/api/documents/${docId}`, { method: 'DELETE' });
            if (response.ok) {
                // Remove from local state
                Object.keys(this.folderDocuments).forEach(folderId => {
                    this.folderDocuments[folderId] = this.folderDocuments[folderId].filter(d => d.id !== docId);
                });
                this.renderSessions();
                this.showNotification('Document deleted', 'success');
            }
        } catch (error) {
            this.showNotification('Failed to delete document', 'error');
        }
    }

    async viewDocument(docId) {
        try {
            const response = await fetch(`${this.apiBase}/api/documents/${docId}?include_text=true`);
            if (!response.ok) throw new Error('Document not found');
            const data = await response.json();

            const modal = document.createElement('div');
            modal.className = 'doc-viewer-modal';
            modal.innerHTML = `
                <div class="doc-viewer-header">
                    <div class="doc-viewer-title">
                        ${this.getDocIcon(data.document.file_type).emoji}
                        ${data.document.filename}
                    </div>
                    <div class="doc-viewer-actions">
                        <button class="chat-context-btn active" onclick="jottyApp.setChatContext('document', '${docId}', '${data.document.filename}'); this.closest('.doc-viewer-modal').remove();">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/></svg>
                            Chat with Document
                        </button>
                        <button class="pdf-action-btn" onclick="this.closest('.doc-viewer-modal').remove();">Close</button>
                    </div>
                </div>
                <div class="doc-viewer-content">
                    <div class="doc-viewer-text">${this.escapeHtml(data.text || 'No text extracted')}</div>
                </div>
            `;
            document.body.appendChild(modal);

            // Close on escape
            const escHandler = (e) => { if (e.key === 'Escape') { modal.remove(); document.removeEventListener('keydown', escHandler); } };
            document.addEventListener('keydown', escHandler);
        } catch (error) {
            this.showNotification('Failed to load document', 'error');
        }
    }

    getDocIcon(fileType) {
        const icons = {
            '.pdf': { emoji: 'ðŸ“•', class: 'pdf' },
            '.docx': { emoji: 'ðŸ“˜', class: 'doc' },
            '.doc': { emoji: 'ðŸ“˜', class: 'doc' },
            '.txt': { emoji: 'ðŸ“„', class: 'txt' },
            '.md': { emoji: 'ðŸ“', class: 'txt' },
            '.csv': { emoji: 'ðŸ“Š', class: 'csv' },
            '.json': { emoji: 'ðŸ“‹', class: 'txt' },
            '.html': { emoji: 'ðŸŒ', class: 'txt' },
            '.pptx': { emoji: 'ðŸ“™', class: 'doc' },
        };
        return icons[fileType] || { emoji: 'ðŸ“„', class: 'default' };
    }

    formatFileSize(bytes) {
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    }

    // ===== CHAT CONTEXT (RAG) =====

    setChatContext(type, id, name) {
        this.chatContext = { type, id, name };
        this.renderChatContextBadge();
        this.showNotification(`Now chatting with: ${name}`, 'info');

        // Focus the input
        if (this.messageInput) {
            this.messageInput.focus();
            this.messageInput.placeholder = `Ask about ${name}...`;
        }
    }

    clearChatContext() {
        this.chatContext = null;
        this.renderChatContextBadge();
        if (this.messageInput) {
            this.messageInput.placeholder = 'Message Jotty...';
        }
    }

    renderChatContextBadge() {
        let badgeContainer = document.getElementById('context-badges');
        if (!badgeContainer) {
            // Create badge container above input
            const inputArea = document.querySelector('.input-area');
            if (inputArea) {
                badgeContainer = document.createElement('div');
                badgeContainer.id = 'context-badges';
                badgeContainer.className = 'context-badges';
                inputArea.insertBefore(badgeContainer, inputArea.firstChild);
            }
        }

        if (!badgeContainer) return;

        if (this.chatContext) {
            const icon = this.chatContext.type === 'folder' ? 'ðŸ“' : this.chatContext.type === 'document' ? 'ðŸ“„' : 'ðŸ’¬';
            badgeContainer.innerHTML = `
                <div class="context-badge">
                    <span>${icon}</span>
                    <span>Chatting with: ${this.chatContext.name}</span>
                    <span class="context-badge-remove" onclick="jottyApp.clearChatContext()">âœ•</span>
                </div>
            `;
        } else {
            badgeContainer.innerHTML = '';
        }
    }

    // ===== AGUI COMPONENTS =====

    showThinkingIndicator(step = '') {
        const indicator = document.createElement('div');
        indicator.id = 'thinking-indicator';
        indicator.className = 'thinking-indicator';
        indicator.innerHTML = `
            <div class="thinking-dots"><span></span><span></span><span></span></div>
            <div>
                <div class="thinking-text">Jotty is thinking...</div>
                <div class="thinking-step" id="thinking-step">${step}</div>
            </div>
        `;

        if (this.messagesContainer) {
            this.messagesContainer.appendChild(indicator);
            this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        }
    }

    updateThinkingStep(step) {
        const stepEl = document.getElementById('thinking-step');
        if (stepEl) stepEl.textContent = step;
    }

    hideThinkingIndicator() {
        const indicator = document.getElementById('thinking-indicator');
        if (indicator) indicator.remove();
    }

    renderSuggestedActions(actions) {
        if (!actions || actions.length === 0) return '';

        return `<div class="suggested-actions">
            ${actions.map(action => `
                <button class="action-chip ${action.primary ? 'primary' : ''}" onclick="jottyApp.handleSuggestedAction('${this.escapeHtml(action.text)}')">
                    ${action.icon ? `<span>${action.icon}</span>` : ''}
                    ${action.text}
                </button>
            `).join('')}
        </div>`;
    }

    handleSuggestedAction(text) {
        if (this.messageInput) {
            this.messageInput.value = text;
            this.sendMessage();
        }
    }

    generateSuggestedActions(content) {
        // AI-generated follow-up suggestions based on response content
        const actions = [];

        // Detect content patterns and suggest relevant follow-ups
        if (content.includes('```')) {
            actions.push({ icon: 'ðŸ’¡', text: 'Explain this code' });
            actions.push({ icon: 'ðŸ”§', text: 'How can I improve this?' });
        }

        if (content.match(/\d+%|\d+\.\d+/)) {
            actions.push({ icon: 'ðŸ“Š', text: 'Visualize this data' });
        }

        if (content.includes('http://') || content.includes('https://')) {
            actions.push({ icon: 'ðŸ”—', text: 'Summarize linked pages' });
        }

        // Generic follow-ups
        if (actions.length === 0) {
            actions.push({ icon: 'ðŸ”', text: 'Tell me more' });
            actions.push({ icon: 'ðŸ“', text: 'Create a summary' });
        }

        return actions.slice(0, 4);  // Max 4 suggestions
    }

    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.style.cssText = `
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            background: ${type === 'success' ? 'var(--success)' : type === 'error' ? 'var(--error)' : 'var(--accent)'};
            color: white;
            border-radius: 8px;
            font-size: 14px;
            z-index: 9999;
            animation: slideIn 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        notification.textContent = message;
        document.body.appendChild(notification);

        setTimeout(() => {
            notification.style.animation = 'fadeOut 0.3s ease';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }

    async loadSession(sessionId) {
        try {
            const response = await fetch(`${this.apiBase}/api/sessions/${sessionId}`);
            if (!response.ok) throw new Error('Session not found');
            const session = await response.json();
            this.sessionId = sessionId;
            this.messages = session.history || [];
            this.updateSessionDisplay();
            this.renderMessages();
            this.updateConnectionStatus(true);
            this.loadSessions();
            if (this.welcomeScreen) this.welcomeScreen.style.display = 'none';
            if (this.messagesContainer) this.messagesContainer.style.display = 'block';
        } catch (error) { console.error('Failed to load session:', error); }
    }
    newChat() {
        this.sessionId = this.generateSessionId();
        this.messages = [];
        this.updateSessionDisplay();
        this.renderMessages();
        this.updateConnectionStatus(true); // SSE is always "ready"
        if (this.welcomeScreen) this.welcomeScreen.style.display = 'flex';
        if (this.messagesContainer) this.messagesContainer.style.display = 'none';
        this.messageInput.focus();
    }
    updateSessionDisplay() { if (this.sessionIdDisplay) this.sessionIdDisplay.textContent = this.sessionId; }
    updateConnectionStatus(connected) {
        if (this.connectionStatus) {
            this.connectionStatus.className = `connection-status ${connected ? 'connected' : 'disconnected'}`;
            this.connectionStatus.innerHTML = `<span class="connection-dot"></span>${connected ? 'Ready' : 'Disconnected'}`;
        }
    }
    handleSSEMessage(data) {
        switch (data.type) {
            case 'connected': console.log('SSE connected, session:', data.session_id); break;
            case 'stream': this.handleStreamChunk(data.chunk); break;
            case 'status': this.updateStatus(data.stage, data.detail); break;
            case 'complete': this.handleCompleteSSE(data.result); break;
            case 'error': this.handleError(data.error); break;
        }
    }
    handleCompleteSSE(result) {
        if (result && result.success) {
            this.handleComplete({ content: result.content, output_path: result.output_path });
        } else {
            this.handleError(result?.error || 'Unknown error');
        }
    }
    handleStreamChunk(chunk) {
        this.streamingContent += chunk;
        this.updateStreamingMessage();
        console.log('Stream chunk received, total length:', this.streamingContent.length);
    }
    updateStreamingMessage(content = null) {
        const streamingEl = document.getElementById('streaming-message');
        if (streamingEl) {
            const textEl = streamingEl.querySelector('.message-text');
            if (textEl) {
                textEl.innerHTML = this.renderMarkdown(content || this.streamingContent);
                this.scrollToBottom();
            }
        }
    }
    handleComplete(data) {
        this.isProcessing = false;
        this.streamingContent = '';
        const statusEl = document.getElementById('status-indicator');
        if (statusEl) statusEl.remove();
        const streamingEl = document.getElementById('streaming-message');
        if (streamingEl) streamingEl.remove();  // Remove streaming element, will be re-rendered
        this.messages.push({ role: 'assistant', content: data.content, interface: 'web', output_path: data.output_path });
        this.renderMessages();  // Re-render to show download buttons
        this.setProcessing(false);
        this.loadSessions();
    }
    handleError(error) {
        this.isProcessing = false;
        this.streamingContent = '';
        this.setProcessing(false);
        const statusEl = document.getElementById('status-indicator');
        if (statusEl) statusEl.remove();
        const streamingEl = document.getElementById('streaming-message');
        if (streamingEl) streamingEl.remove();
        this.addErrorMessage(error);
    }
    updateStatus(stage, detail) {
        let statusEl = document.getElementById('status-indicator');
        if (!statusEl) { statusEl = document.createElement('div'); statusEl.id = 'status-indicator'; statusEl.className = 'status-indicator'; this.messagesContainer.appendChild(statusEl); }
        const emojis = { 'processing': 'âš™ï¸', 'analyzing': 'ðŸ”', 'searching': 'ðŸŒ', 'reading': 'ðŸ“–', 'generating': 'âœ¨', 'generated': 'âœ…', 'saving': 'ðŸ’¾', 'saved': 'ðŸ“', 'decision': 'ðŸ¤”' };
        const emoji = emojis[stage.toLowerCase()] || 'âš™ï¸';
        statusEl.innerHTML = `<div class="status-spinner"></div><span>${emoji} ${stage.charAt(0).toUpperCase() + stage.slice(1)}${detail ? ': ' + detail : ''}</span>`;
        this.scrollToBottom();
    }
    async sendMessage() {
        const content = this.messageInput.value.trim();
        if (!content && this.attachments.length === 0) return;
        if (this.isProcessing) return;
        if (this.welcomeScreen) this.welcomeScreen.style.display = 'none';
        if (this.messagesContainer) this.messagesContainer.style.display = 'block';

        // Include attachments in message
        const userMessage = { role: 'user', content: content, interface: 'web' };
        if (this.attachments.length > 0) {
            userMessage.attachments = [...this.attachments];
        }
        this.messages.push(userMessage);

        // Store attachments before clearing
        const messageAttachments = [...this.attachments];
        this.attachments = [];
        this.renderAttachments();

        this.renderMessages();
        this.messageInput.value = '';
        this.streamingContent = '';  // Reset streaming content
        this.autoResize();
        this.setProcessing(true);

        // Check if it's a slash command
        if (content.startsWith('/')) {
            await this.executeCommand(content);
        } else {
            this.addStreamingMessage();
            // Use context-aware SSE if chatContext is set
            if (this.chatContext) {
                this.sendViaContextSSE(content, messageAttachments);
            } else {
                this.sendViaSSE(content, messageAttachments);
            }
        }
    }

    sendViaContextSSE(content, attachments = []) {
        // SSE streaming with document/folder context (RAG)
        // Note: Attachments not yet supported in context SSE
        const url = new URL(`${this.apiBase}/api/chat/context/stream`, window.location.origin);
        url.searchParams.set('message', content);
        url.searchParams.set('context_type', this.chatContext.type);
        url.searchParams.set('context_id', this.chatContext.id);
        url.searchParams.set('session_id', this.sessionId);

        console.log('Context SSE URL:', url.toString());

        // Show thinking indicator with context
        this.showThinkingIndicator(`Searching ${this.chatContext.name}...`);

        const evtSource = new EventSource(url.toString());
        let receivedAnyContent = false;

        evtSource.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                console.log('Context SSE event:', data.type, data);

                if (data.type === 'context') {
                    // Update thinking indicator
                    if (data.has_context) {
                        this.updateThinkingStep(`Found ${Math.round(data.context_length / 4)} relevant tokens`);
                    } else {
                        this.updateThinkingStep('No matching context found, using general knowledge');
                    }
                } else if (data.type === 'status') {
                    this.updateThinkingStep(data.detail || data.stage);
                } else if (data.type === 'stream') {
                    // Hide thinking indicator on first content
                    if (!receivedAnyContent) {
                        this.hideThinkingIndicator();
                        receivedAnyContent = true;
                    }
                    this.streamingContent += data.chunk;
                    this.updateStreamingMessage(this.streamingContent);
                } else if (data.type === 'complete') {
                    this.hideThinkingIndicator();
                    evtSource.close();
                    this.handleCompleteSSE(data.result);
                } else if (data.type === 'error') {
                    this.hideThinkingIndicator();
                    evtSource.close();
                    this.handleError(data.error);
                }
            } catch (e) {
                console.warn('Failed to parse SSE data:', e);
            }
        };

        evtSource.onerror = (e) => {
            console.error('Context SSE error:', e);
            this.hideThinkingIndicator();
            evtSource.close();
            this.handleError('Connection error');
        };
    }
    async loadCommands() {
        try {
            const response = await fetch(`${this.apiBase}/api/commands`);
            const data = await response.json();
            this.commands = data.commands || [];
            console.log('Loaded commands:', this.commands.length);
        } catch (error) {
            console.error('Failed to load commands:', error);
        }
    }
    handleCommandAutocomplete(e) {
        const value = this.messageInput.value;
        let dropdown = document.getElementById('command-dropdown');

        // Show dropdown when typing /
        if (value.startsWith('/') && value.length >= 1) {
            const query = value.slice(1).toLowerCase();
            const matches = this.commands.filter(cmd =>
                cmd.name.toLowerCase().startsWith(query) ||
                (cmd.aliases && cmd.aliases.some(a => a.toLowerCase().startsWith(query)))
            ).slice(0, 8);

            if (matches.length > 0 && value.length < 20) {
                if (!dropdown) {
                    dropdown = document.createElement('div');
                    dropdown.id = 'command-dropdown';
                    dropdown.className = 'command-dropdown';
                    this.messageInput.parentNode.appendChild(dropdown);
                }
                dropdown.innerHTML = matches.map((cmd, i) => `
                    <div class="command-option ${i === 0 ? 'selected' : ''}" data-command="${cmd.name}">
                        <span class="command-name">/${cmd.name}</span>
                        <span class="command-desc">${cmd.description.slice(0, 50)}${cmd.description.length > 50 ? '...' : ''}</span>
                    </div>
                `).join('');
                dropdown.style.display = 'block';

                // Click handlers
                dropdown.querySelectorAll('.command-option').forEach(opt => {
                    opt.addEventListener('click', () => {
                        this.messageInput.value = '/' + opt.dataset.command + ' ';
                        dropdown.style.display = 'none';
                        this.messageInput.focus();
                    });
                });
            } else if (dropdown) {
                dropdown.style.display = 'none';
            }
        } else if (dropdown) {
            dropdown.style.display = 'none';
        }
    }
    async executeCommand(input) {
        // Parse command and args
        const parts = input.slice(1).split(/\s+/);
        const command = parts[0];
        const args = parts.slice(1).join(' ');

        this.updateStatus('executing', `Running /${command}...`);

        // Use SSE for streaming output
        const url = `${this.apiBase}/api/commands/stream?command=${encodeURIComponent(command)}&args=${encodeURIComponent(args)}&session_id=${encodeURIComponent(this.sessionId)}`;

        // Create streaming message element
        const messagesContainer = document.getElementById('messages-container');
        const streamingDiv = document.createElement('div');
        streamingDiv.id = 'command-streaming';
        streamingDiv.className = 'message assistant';
        streamingDiv.innerHTML = `
            <div class="message-avatar">ðŸ¤–</div>
            <div class="message-content">
                <div class="message-role">Jotty</div>
                <div class="message-text"><pre id="command-output" style="white-space: pre-wrap; background: var(--code-bg); padding: 16px; border-radius: 8px; max-height: 400px; overflow-y: auto;"></pre></div>
            </div>
        `;
        messagesContainer.appendChild(streamingDiv);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        const outputEl = document.getElementById('command-output');
        let fullOutput = '';

        const eventSource = new EventSource(url);

        eventSource.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                console.log('Command SSE event:', data.type);

                if (data.type === 'output') {
                    fullOutput += data.line + '\n';
                    outputEl.textContent = fullOutput;
                    // Auto-scroll
                    outputEl.scrollTop = outputEl.scrollHeight;
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                } else if (data.type === 'complete') {
                    eventSource.close();
                    const statusEl = document.getElementById('status-indicator');
                    if (statusEl) statusEl.remove();

                    // Finalize the message
                    this.messages.push({
                        role: 'assistant',
                        content: fullOutput || 'Command completed',
                        interface: 'web'
                    });
                    this.setProcessing(false);
                } else if (data.type === 'error') {
                    eventSource.close();
                    fullOutput += `\nâŒ Error: ${data.error}`;
                    outputEl.textContent = fullOutput;
                    this.setProcessing(false);
                }
            } catch (e) {
                console.error('Failed to parse command SSE:', e, event.data);
            }
        };

        eventSource.onerror = (error) => {
            console.error('Command SSE error:', error);
            eventSource.close();

            // Fallback to non-streaming
            if (this.isProcessing && !fullOutput) {
                this.executeCommandFallback(command, args);
            } else {
                this.setProcessing(false);
            }
        };
    }

    async executeCommandFallback(command, args) {
        // Non-streaming fallback for quick commands
        try {
            const response = await fetch(`${this.apiBase}/api/commands/execute`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ command, args, session_id: this.sessionId })
            });
            const result = await response.json();

            const statusEl = document.getElementById('status-indicator');
            if (statusEl) statusEl.remove();

            const streamingEl = document.getElementById('command-streaming');
            if (streamingEl) streamingEl.remove();

            if (result.success) {
                this.messages.push({
                    role: 'assistant',
                    content: result.output || 'Command executed successfully',
                    interface: 'web'
                });
            } else {
                this.messages.push({
                    role: 'assistant',
                    content: `Error: ${result.error}`,
                    interface: 'web'
                });
            }
            this.renderMessages();
        } catch (error) {
            console.error('Command fallback failed:', error);
            this.addErrorMessage(error.message);
        } finally {
            this.setProcessing(false);
        }
    }
    sendViaSSE(content, attachments = []) {
        // Use WebSocket instead of SSE to bypass proxy buffering
        this.sendViaWebSocket(content, attachments);
    }

    sendViaWebSocket(content, attachments = []) {
        // Build WebSocket URL (convert http to ws, handle proxy path)
        let wsUrl;
        if (this.apiBase.startsWith('http')) {
            wsUrl = this.apiBase.replace(/^http/, 'ws') + `/ws/chat/${this.sessionId}`;
        } else {
            // Relative path - use current page protocol
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            wsUrl = `${protocol}//${window.location.host}${this.apiBase}/ws/chat/${this.sessionId}`;
        }

        console.log('Connecting WebSocket:', wsUrl);
        const ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            console.log('WebSocket connected');
            // Send the message with attachments
            const payload = { type: 'message', content: content };
            if (attachments && attachments.length > 0) {
                payload.attachments = attachments;
            }
            ws.send(JSON.stringify(payload));
        };

        ws.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                console.log('WS event:', data.type);
                this.handleSSEMessage(data);  // Reuse same handler

                if (data.type === 'complete' || data.type === 'error') {
                    ws.close();
                }
            } catch (e) {
                console.error('Failed to parse WS message:', e, event.data);
            }
        };

        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            // Fallback to SSE
            if (this.isProcessing) {
                console.log('Falling back to SSE...');
                this.sendViaSSEDirect(content, this.pendingAttachments || []);
            }
        };

        ws.onclose = () => {
            console.log('WebSocket closed');
        };

        // Store attachments for fallback
        this.pendingAttachments = attachments;
    }

    sendViaSSEDirect(content, attachments = []) {
        // Original SSE implementation as fallback
        // Note: SSE via GET can't send attachments - would need POST endpoint for that
        const url = `${this.apiBase}/api/chat/stream?message=${encodeURIComponent(content)}&session_id=${encodeURIComponent(this.sessionId)}`;
        const eventSource = new EventSource(url);

        eventSource.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
                console.log('SSE event:', data.type);
                this.handleSSEMessage(data);

                if (data.type === 'complete' || data.type === 'error') {
                    eventSource.close();
                }
            } catch (e) {
                console.error('Failed to parse SSE message:', e, event.data);
            }
        };

        eventSource.onerror = (error) => {
            console.error('SSE error:', error);
            eventSource.close();
            if (this.isProcessing) {
                this.handleError('Connection lost. Retrying...');
                this.sendViaRest(content);
            }
        };
    }
    async sendViaRest(content) {
        try {
            const response = await fetch(`${this.apiBase}/api/chat`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: content, session_id: this.sessionId }) });
            const data = await response.json();
            const streamingEl = document.getElementById('streaming-message');
            if (streamingEl) streamingEl.remove();
            const statusEl = document.getElementById('status-indicator');
            if (statusEl) statusEl.remove();
            if (data.success) { this.messages.push({ role: 'assistant', content: data.content, interface: 'web', output_path: data.output_path }); this.renderMessages(); }
            else { this.addErrorMessage(data.error || 'Unknown error'); }
        } catch (error) { console.error('REST request failed:', error); this.addErrorMessage(error.message); }
        finally { this.setProcessing(false); }
    }
    addStreamingMessage() {
        const messageEl = document.createElement('div');
        messageEl.id = 'streaming-message';
        messageEl.className = 'message assistant';
        messageEl.innerHTML = `<div class="message-avatar">J</div><div class="message-content"><div class="message-role">Jotty</div><div class="message-text"></div><div class="message-meta"><span class="message-interface">web</span></div></div>`;
        this.messagesContainer.appendChild(messageEl);
        this.scrollToBottom();
    }
    addErrorMessage(error) {
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.textContent = `Error: ${error}`;
        this.messagesContainer.appendChild(errorEl);
        this.scrollToBottom();
    }
    renderMessages() {
        if (!this.messagesContainer) return;
        this.messagesContainer.innerHTML = this.messages.map((msg, idx) => {
            // Extract links for assistant messages
            let linksSection = '';
            if (msg.role === 'assistant' && msg.content) {
                const links = this.extractLinks(msg.content);
                if (links.length > 0) {
                    linksSection = `<div class="message-links">
                        <div class="message-links-header" onclick="this.parentElement.classList.toggle('expanded')">
                            <span>ðŸ”— ${links.length} link${links.length > 1 ? 's' : ''} found</span>
                            <svg class="expand-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>
                        </div>
                        <div class="message-links-list">${links.map(l => `<a href="${l.url}" onclick="jottyApp.openInlineBrowser('${l.url.replace(/'/g, "\\'")}', '${l.text.replace(/'/g, "\\'")}'); return false;" class="message-link-item" title="${l.url}"><span class="link-favicon">ðŸŒ</span><span class="link-text">${l.text}</span><span class="link-domain">${this.getDomain(l.url)}</span></a>`).join('')}</div>
                    </div>`;
                }
            }
            const downloadBtns = msg.role === 'assistant' && msg.content ? `
                <div class="download-buttons">
                    <button class="preview-btn" onclick="jottyApp.openPreview(${idx})" title="Preview Document">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></svg>
                        Preview
                    </button>
                    <button class="download-btn" onclick="jottyApp.exportContent(${idx}, 'md')" title="Download Markdown">â†“ MD</button>
                    <button class="download-btn" onclick="jottyApp.exportContent(${idx}, 'pdf')" title="Download PDF">â†“ PDF</button>
                    <button class="download-btn" onclick="jottyApp.exportContent(${idx}, 'docx')" title="Download Word">â†“ DOCX</button>
                    <button class="download-btn" onclick="jottyApp.exportContent(${idx}, 'html')" title="Download HTML">â†“ HTML</button>
                    <button class="download-btn" onclick="jottyApp.exportContent(${idx}, 'epub')" title="Download EPUB">â†“ EPUB</button>
                    <button class="download-btn" onclick="jottyApp.exportContent(${idx}, 'slides')" title="Download Slides">â†“ Slides</button>
                </div>` : '';
            // Render attachments for user messages
            let attachmentsHtml = '';
            if (msg.role === 'user' && msg.attachments && msg.attachments.length > 0) {
                attachmentsHtml = `<div class="message-attachments">${msg.attachments.map(att =>
                    att.type === 'image' ? `<div class="message-attachment"><img src="${att.data}" alt="${att.name}" title="${att.name}" /></div>` : ''
                ).join('')}</div>`;
            }
            // Add speak button for assistant messages
            const speakBtn = msg.role === 'assistant' ? `<button class="speak-btn" onclick="jottyApp.speakMessage(${index})" title="Read aloud">ðŸ”Š</button>` : '';
            return `<div class="message ${msg.role}" data-index="${index}"><div class="message-avatar">${msg.role === 'user' ? 'U' : 'J'}</div><div class="message-content"><div class="message-role">${msg.role === 'user' ? 'You' : 'Jotty'}${speakBtn}</div>${attachmentsHtml}<div class="message-text">${this.renderMarkdown(msg.content || '')}</div>${linksSection}<div class="message-meta"><span class="message-interface">${msg.interface || 'web'}</span></div>${downloadBtns}</div></div>`;
        }).join('');
        this.scrollToBottom();
    }

    getDomain(url) {
        try {
            return new URL(url).hostname.replace('www.', '');
        } catch {
            return url.substring(0, 30);
        }
    }
    renderMarkdown(text) {
        if (!text) return '';
        let html = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, (_, lang, code) => `<pre><code class="language-${lang || ''}">${code.trim()}</code></pre>`);
        html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
        html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
        html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
        html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
        html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
        html = html.replace(/^- \[x\] (.+)$/gm, '<li class="checked">â˜‘ $1</li>');
        html = html.replace(/^- \[ \] (.+)$/gm, '<li class="unchecked">â˜ $1</li>');
        html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
        html = html.replace(/^(\d+)\. (.+)$/gm, '<li>$2</li>');
        html = html.replace(/(<li[^>]*>.*<\/li>\n?)+/g, '<ul>$&</ul>');
        html = html.replace(/^(?!<[huplo]|$)(.+)$/gm, '<p>$1</p>');
        // Convert markdown links to inline browser links (onclick instead of target="_blank")
        html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
            const safeUrl = url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const safeText = text.replace(/'/g, "\\'");
            return `<a href="${url}" onclick="jottyApp.openInlineBrowser('${safeUrl}', '${safeText}'); return false;" class="inline-link" title="Open in preview">${text}</a>`;
        });
        // Convert bare URLs to inline browser links (match URLs not already in anchor tags)
        html = html.replace(/(?<!href="|onclick="[^"]*|<a[^>]*>)(https?:\/\/[^\s<>"']+)/g, (match, url) => {
            const safeUrl = url.replace(/'/g, "\\'").replace(/"/g, '&quot;');
            const displayUrl = url.length > 50 ? url.substring(0, 47) + '...' : url;
            return `<a href="${url}" onclick="jottyApp.openInlineBrowser('${safeUrl}', '${displayUrl}'); return false;" class="inline-link" title="${url}">${displayUrl}</a>`;
        });
        return html;
    }

    // Inline Browser - opens URLs in a modal overlay
    // Uses server-side proxy to bypass X-Frame-Options restrictions
    openInlineBrowser(url, title = '') {
        // Ensure URL has protocol
        let fullUrl = url;
        if (!url.startsWith('http://') && !url.startsWith('https://')) {
            fullUrl = url.startsWith('/') ? `${window.location.origin}${url}` : `https://${url}`;
        }

        // Use our server-side proxy to bypass X-Frame-Options
        const proxyUrl = `${this.apiBase}/api/proxy?url=${encodeURIComponent(fullUrl)}`;

        // Create modal
        const modal = document.createElement('div');
        modal.id = 'inline-browser-modal';
        modal.className = 'inline-browser-modal';
        modal.innerHTML = `
            <div class="inline-browser-header">
                <div class="inline-browser-actions">
                    <button class="inline-browser-btn" onclick="jottyApp.inlineBrowserBack()" title="Back">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
                    </button>
                    <button class="inline-browser-btn" onclick="jottyApp.inlineBrowserRefresh()" title="Refresh">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M23 4v6h-6M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"/></svg>
                    </button>
                </div>
                <div class="inline-browser-url" id="inline-browser-url">${fullUrl}</div>
                <div class="inline-browser-actions">
                    <button class="inline-browser-btn" onclick="window.open('${fullUrl}', '_blank')" title="Open in new tab">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
                        Open
                    </button>
                    <button class="inline-browser-btn close" onclick="jottyApp.closeInlineBrowser()" title="Close">
                        âœ• Close
                    </button>
                </div>
            </div>
            <div class="inline-browser-content">
                <div class="inline-browser-loading" style="display:flex; align-items:center; justify-content:center; height:100%; background:var(--bg-primary); color:var(--text-secondary);">
                    <div style="text-align:center;">
                        <div class="status-spinner" style="margin:0 auto 12px;"></div>
                        <div>Loading page via proxy...</div>
                    </div>
                </div>
                <iframe id="inline-browser-iframe" src="${proxyUrl}" style="width:100%; height:100%; border:none; display:none;"></iframe>
            </div>
        `;
        document.body.appendChild(modal);

        // Store URL for navigation
        this.inlineBrowserUrl = fullUrl;
        this.inlineBrowserHistory = [fullUrl];
        this.inlineBrowserHistoryIndex = 0;
        this.inlineBrowserProxyAttempted = false;

        // Close on escape
        this.inlineBrowserEscHandler = (e) => { if (e.key === 'Escape') this.closeInlineBrowser(); };
        document.addEventListener('keydown', this.inlineBrowserEscHandler);

        // Handle iframe load events
        const iframe = document.getElementById('inline-browser-iframe');
        const loading = modal.querySelector('.inline-browser-loading');

        if (iframe) {
            // Set up load timeout
            this.inlineBrowserTimeout = setTimeout(() => {
                this.tryExternalProxyFallback(fullUrl, modal);
            }, 15000);  // 15 second timeout for server proxy

            iframe.onload = () => {
                clearTimeout(this.inlineBrowserTimeout);
                // Hide loading, show iframe
                if (loading) loading.style.display = 'none';
                iframe.style.display = 'block';

                // Check if proxy returned an error (empty or error page)
                try {
                    const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
                    if (iframeDoc) {
                        const text = iframeDoc.body?.innerText || '';
                        // Check for common proxy error indicators
                        if (text.includes('502 Bad Gateway') || text.includes('504 Gateway') || text.includes('Failed to fetch')) {
                            this.tryExternalProxyFallback(fullUrl, modal);
                        }
                    }
                } catch (e) {
                    // Cross-origin - page loaded successfully
                }
            };

            iframe.onerror = () => {
                clearTimeout(this.inlineBrowserTimeout);
                this.tryExternalProxyFallback(fullUrl, modal);
            };
        }
    }

    tryExternalProxyFallback(url, modal) {
        // If server proxy failed, try allorigins as external fallback
        if (this.inlineBrowserProxyAttempted) {
            this.showInlineBrowserError(url, modal);
            return;
        }
        this.inlineBrowserProxyAttempted = true;

        const content = modal.querySelector('.inline-browser-content');
        const urlEl = document.getElementById('inline-browser-url');
        if (!content) return;

        // Try using allorigins.win as external proxy
        const externalProxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;

        content.innerHTML = `
            <div style="display:flex; align-items:center; justify-content:center; height:100%; background:var(--bg-primary); color:var(--text-secondary);">
                <div style="text-align:center;">
                    <div class="status-spinner" style="margin:0 auto 12px;"></div>
                    <div>Trying external proxy...</div>
                </div>
            </div>
        `;

        // Update URL bar to show proxy
        if (urlEl) urlEl.innerHTML = `<span style="color:var(--accent);">[via external proxy]</span> ${url}`;

        // Create new iframe with external proxy URL
        setTimeout(() => {
            content.innerHTML = `<iframe id="inline-browser-iframe" src="${externalProxyUrl}" style="width:100%; height:100%; border:none;"></iframe>`;

            const newIframe = document.getElementById('inline-browser-iframe');
            if (newIframe) {
                // Set timeout for external proxy attempt
                const proxyTimeout = setTimeout(() => {
                    this.showInlineBrowserError(url, modal);
                }, 10000);

                newIframe.onload = () => {
                    clearTimeout(proxyTimeout);
                };

                newIframe.onerror = () => {
                    clearTimeout(proxyTimeout);
                    this.showInlineBrowserError(url, modal);
                };
            }
        }, 500);
    }

    showInlineBrowserError(url, modal) {
        const content = modal.querySelector('.inline-browser-content');
        if (!content) return;

        content.innerHTML = `
            <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:100%; background:var(--bg-primary); color:var(--text-primary); padding:40px; text-align:center;">
                <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="opacity:0.5; margin-bottom:20px;">
                    <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/><line x1="9" y1="9" x2="15" y2="15"/><line x1="15" y1="9" x2="9" y2="15"/>
                </svg>
                <h3 style="margin:0 0 12px 0; font-size:18px;">Cannot Load in Preview</h3>
                <p style="margin:0 0 20px 0; color:var(--text-secondary); max-width:400px;">This site doesn't allow embedding and proxy connection failed. Click below to open in a new tab.</p>
                <a href="${url}" target="_blank" style="padding:12px 24px; background:var(--accent); color:white; border-radius:8px; text-decoration:none; font-weight:500;">Open in New Tab</a>
            </div>
        `;
    }

    closeInlineBrowser() {
        const modal = document.getElementById('inline-browser-modal');
        if (modal) modal.remove();
        if (this.inlineBrowserEscHandler) {
            document.removeEventListener('keydown', this.inlineBrowserEscHandler);
        }
    }

    inlineBrowserBack() {
        if (this.inlineBrowserHistoryIndex > 0) {
            this.inlineBrowserHistoryIndex--;
            const url = this.inlineBrowserHistory[this.inlineBrowserHistoryIndex];
            const proxyUrl = `${this.apiBase}/api/proxy?url=${encodeURIComponent(url)}`;
            const iframe = document.getElementById('inline-browser-iframe');
            const urlEl = document.getElementById('inline-browser-url');
            if (iframe) iframe.src = proxyUrl;
            if (urlEl) urlEl.textContent = url;
        }
    }

    inlineBrowserRefresh() {
        const iframe = document.getElementById('inline-browser-iframe');
        if (iframe) {
            // Re-fetch through proxy
            const currentUrl = this.inlineBrowserHistory[this.inlineBrowserHistoryIndex] || this.inlineBrowserUrl;
            const proxyUrl = `${this.apiBase}/api/proxy?url=${encodeURIComponent(currentUrl)}`;
            iframe.src = proxyUrl;
        }
    }
    openPreview(msgIndex) {
        const msg = this.messages[msgIndex];
        if (!msg || !msg.content) return;

        // Store current message index for format switching
        this.previewMsgIndex = msgIndex;

        // Create modal
        const modal = document.createElement('div');
        modal.id = 'preview-modal';
        modal.className = 'preview-modal';
        modal.innerHTML = `
            <div class="preview-header">
                <span class="preview-title">Document Preview</span>
                <div class="preview-actions">
                    <button class="preview-format-btn active" data-format="md">Markdown</button>
                    <button class="preview-format-btn" data-format="html">HTML</button>
                    <button class="preview-format-btn" data-format="pdf">PDF</button>
                    <button class="preview-format-btn" data-format="docx">DOCX</button>
                    <button class="preview-format-btn" data-format="slides">Slides</button>
                    <button class="preview-close" onclick="jottyApp.closePreview()">âœ• Close</button>
                </div>
            </div>
            <div class="preview-content" id="preview-content">
                <div class="preview-loading">Loading preview...</div>
            </div>
        `;
        document.body.appendChild(modal);

        // Add format button listeners
        modal.querySelectorAll('.preview-format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                modal.querySelectorAll('.preview-format-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                this.loadPreview(msgIndex, btn.dataset.format);
            });
        });

        // Close on escape
        this.previewEscHandler = (e) => { if (e.key === 'Escape') this.closePreview(); };
        document.addEventListener('keydown', this.previewEscHandler);

        // Load initial markdown preview
        this.loadPreview(msgIndex, 'md');
    }

    closePreview() {
        const modal = document.getElementById('preview-modal');
        if (modal) modal.remove();
        if (this.previewEscHandler) {
            document.removeEventListener('keydown', this.previewEscHandler);
        }
    }

    async loadPreview(msgIndex, format) {
        const msg = this.messages[msgIndex];
        const contentEl = document.getElementById('preview-content');
        if (!contentEl || !msg) return;

        contentEl.innerHTML = '<div class="preview-loading">Loading preview...</div>';

        try {
            if (format === 'md') {
                // Markdown - render with intelligent section detection
                const smartRendered = await this.renderSmartPreview(msg.content);
                const links = this.extractLinks(msg.content);
                let linksHtml = '';
                if (links.length > 0) {
                    linksHtml = `<div class="extracted-links">
                        <div class="links-header">ðŸ”— Links in this document (${links.length})</div>
                        <div class="links-list">${links.map(l => `<a href="${l.url}" onclick="jottyApp.openInlineBrowser('${l.url.replace(/'/g, "\\'")}', '${l.text.replace(/'/g, "\\'")}'); return false;" class="link-item" title="${l.url}"><span class="link-text">${l.text}</span><span class="link-url">${l.url}</span></a>`).join('')}</div>
                    </div>`;
                }
                contentEl.innerHTML = `<div class="smart-preview">${smartRendered}</div>${linksHtml}`;
            } else if (format === 'html') {
                // HTML - fetch converted and display in iframe
                const html = await this.fetchPreviewContent(msg.content, 'html');
                const blob = new Blob([html], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                contentEl.innerHTML = `<iframe src="${url}" sandbox="allow-same-origin"></iframe>`;
            } else if (format === 'pdf' || format === 'slides') {
                // PDF/Slides - fetch blob and display
                try {
                    const blob = await this.fetchPreviewBlob(msg.content, format);
                    const url = URL.createObjectURL(blob);
                    this.currentPdfUrl = url;
                    const formatLabel = format === 'slides' ? 'Slides (PDF)' : 'PDF';

                    // Create PDF viewer - iframe as primary with prominent actions
                    contentEl.innerHTML = `
                        <div class="pdf-viewer-container">
                            <div class="pdf-viewer-header">
                                <div class="pdf-info">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="pdf-icon"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>
                                    <span>${formatLabel} Document</span>
                                </div>
                                <div class="pdf-actions">
                                    <button class="pdf-action-btn primary" onclick="window.open('${url}', '_blank')">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><polyline points="15 3 21 3 21 9"/><line x1="10" y1="14" x2="21" y2="3"/></svg>
                                        Open in New Tab
                                    </button>
                                    <button class="pdf-action-btn" onclick="jottyApp.downloadPdf('${url}', '${format}')">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                                        Download
                                    </button>
                                </div>
                            </div>
                            <div class="pdf-embed-container">
                                <iframe src="${url}#toolbar=1&navpanes=1&scrollbar=1&view=FitH" class="pdf-iframe" id="pdf-iframe"></iframe>
                                <div class="pdf-fallback" id="pdf-fallback">
                                    <div class="pdf-fallback-content">
                                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
                                        <p>PDF preview may not display inline in your browser.</p>
                                        <button class="pdf-fallback-btn" onclick="window.open('${url}', '_blank')">
                                            Open PDF in New Tab
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;

                    // Check if iframe loaded PDF properly after a delay
                    setTimeout(() => {
                        const iframe = document.getElementById('pdf-iframe');
                        const fallback = document.getElementById('pdf-fallback');
                        if (iframe && fallback) {
                            try {
                                // Try to detect if PDF loaded (this may fail due to cross-origin)
                                const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
                                if (iframeDoc && iframeDoc.body && iframeDoc.body.innerHTML === '') {
                                    fallback.style.display = 'flex';
                                    iframe.style.display = 'none';
                                }
                            } catch (e) {
                                // Cross-origin - PDF might be loading, keep both visible
                                // Hide fallback if iframe seems to have content
                            }
                        }
                    }, 2000);
                } catch (pdfError) {
                    console.error('PDF generation failed:', pdfError);
                    contentEl.innerHTML = `<div class="preview-error">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="width:48px;height:48px;margin-bottom:16px;opacity:0.5;"><path d="M14 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="12" y1="18" x2="12" y2="12"/><line x1="12" y1="9" x2="12.01" y2="9"/></svg>
                        <h3>PDF Generation Failed</h3>
                        <p>${pdfError.message}</p>
                        <p style="font-size:12px;opacity:0.7;margin-top:12px;">Try downloading as HTML or DOCX instead.</p>
                    </div>`;
                }
            } else if (format === 'docx') {
                // DOCX - convert to HTML for preview
                const html = await this.fetchPreviewContent(msg.content, 'docx-preview');
                contentEl.innerHTML = `<div class="markdown-preview">${html}</div>`;
            }
        } catch (error) {
            console.error('Preview failed:', error);
            contentEl.innerHTML = `<div class="preview-loading" style="color: var(--error);">Preview failed: ${error.message}</div>`;
        }
    }

    downloadPdf(url, format) {
        const a = document.createElement('a');
        a.href = url;
        a.download = `document.${format === 'slides' ? 'pdf' : format}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    }

    extractLinks(text) {
        const links = [];
        // Match markdown links [text](url)
        const mdLinkRegex = /\[([^\]]+)\]\(([^)]+)\)/g;
        let match;
        while ((match = mdLinkRegex.exec(text)) !== null) {
            links.push({ text: match[1], url: match[2] });
        }
        // Match bare URLs
        const urlRegex = /(?<!\]\()https?:\/\/[^\s<>\[\]()]+/g;
        while ((match = urlRegex.exec(text)) !== null) {
            // Check if this URL is already captured as markdown link
            if (!links.some(l => l.url === match[0])) {
                const urlObj = new URL(match[0]);
                links.push({ text: urlObj.hostname, url: match[0] });
            }
        }
        return links;
    }

    // ===== INTELLIGENT SECTION RENDERERS =====
    // Detects and renders different content types: mermaid, plantuml, latex, charts, tables, code

    detectContentSections(text) {
        const sections = [];
        let remaining = text;
        let lastIndex = 0;

        // Patterns for different content types
        const patterns = [
            { type: 'mermaid', regex: /```mermaid\n([\s\S]*?)```/g },
            { type: 'plantuml', regex: /```(?:plantuml|puml)\n([\s\S]*?)```/g },
            { type: 'latex', regex: /```(?:latex|tex|math)\n([\s\S]*?)```/g },
            { type: 'chart', regex: /```(?:chart|vega|vegalite)\n([\s\S]*?)```/g },
            { type: 'json', regex: /```json\n([\s\S]*?)```/g },
            { type: 'python', regex: /```python\n([\s\S]*?)```/g },
            { type: 'javascript', regex: /```(?:javascript|js)\n([\s\S]*?)```/g },
            { type: 'code', regex: /```(\w*)\n([\s\S]*?)```/g },
        ];

        // Also detect inline math: $...$ and $$...$$
        const inlineMathRegex = /\$\$([^$]+)\$\$|\$([^$\n]+)\$/g;

        // Find all code blocks and their positions
        const allMatches = [];

        for (const pattern of patterns) {
            let match;
            const regex = new RegExp(pattern.regex.source, 'g');
            while ((match = regex.exec(text)) !== null) {
                allMatches.push({
                    type: pattern.type,
                    content: pattern.type === 'code' ? match[2] : match[1],
                    lang: pattern.type === 'code' ? match[1] : pattern.type,
                    start: match.index,
                    end: match.index + match[0].length,
                    full: match[0]
                });
            }
        }

        // Sort by position
        allMatches.sort((a, b) => a.start - b.start);

        // Build sections with text between code blocks
        let currentPos = 0;
        for (const match of allMatches) {
            // Add text before this match
            if (match.start > currentPos) {
                const textBefore = text.substring(currentPos, match.start).trim();
                if (textBefore) {
                    sections.push({ type: 'markdown', content: textBefore });
                }
            }
            sections.push(match);
            currentPos = match.end;
        }

        // Add remaining text
        if (currentPos < text.length) {
            const remaining = text.substring(currentPos).trim();
            if (remaining) {
                sections.push({ type: 'markdown', content: remaining });
            }
        }

        return sections.length > 0 ? sections : [{ type: 'markdown', content: text }];
    }

    async renderSmartPreview(text) {
        const sections = this.detectContentSections(text);
        const renderedSections = [];

        for (const section of sections) {
            const rendered = await this.renderSection(section);
            renderedSections.push(rendered);
        }

        return renderedSections.join('\n');
    }

    async renderSection(section) {
        switch (section.type) {
            case 'mermaid':
                return this.renderMermaid(section.content);
            case 'plantuml':
                return this.renderPlantUML(section.content);
            case 'latex':
                return this.renderLatex(section.content);
            case 'chart':
            case 'json':
                return this.renderJsonOrChart(section.content);
            case 'python':
            case 'javascript':
            case 'code':
                return this.renderCode(section.content, section.lang);
            case 'markdown':
            default:
                return `<div class="section-markdown">${this.renderMarkdown(section.content)}</div>`;
        }
    }

    renderMermaid(code) {
        // Use mermaid.ink API for rendering - requires pako for compression or use base64
        const cleanCode = code.trim();
        // mermaid.ink expects base64 of the raw code (not URI encoded)
        const encoded = this.base64EncodeUnicode(cleanCode);
        const imgUrl = `https://mermaid.ink/img/base64:${encoded}?theme=neutral&bgColor=!white`;

        return `<div class="section-mermaid">
            <div class="section-header"><span class="section-icon">ðŸ“Š</span> Mermaid Diagram</div>
            <div class="section-content">
                <img src="${imgUrl}" alt="Mermaid Diagram" class="mermaid-img"
                    onerror="this.onerror=null; this.parentElement.innerHTML=jottyApp.getMermaidFallback('${encoded}', \`${this.escapeHtml(cleanCode).replace(/`/g, '\\`')}\`);">
            </div>
            <details class="section-source"><summary>View Source</summary><pre><code>${this.escapeHtml(cleanCode)}</code></pre></details>
        </div>`;
    }

    base64EncodeUnicode(str) {
        // Properly encode unicode to base64
        return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (match, p1) => {
            return String.fromCharCode('0x' + p1);
        }));
    }

    getMermaidFallback(encoded, code) {
        // Try alternative rendering - use different mermaid.ink theme or show error
        const altUrl = `https://mermaid.ink/img/base64:${encoded}?theme=dark`;
        return `<img src="${altUrl}" alt="Mermaid Diagram" class="mermaid-img"
            onerror="this.onerror=null; this.parentElement.innerHTML='<div class=\\'render-error\\'>âš ï¸ Could not render diagram. The mermaid syntax may have errors. View source below.</div><pre style=\\'background:var(--code-bg);padding:16px;border-radius:8px;overflow-x:auto;\\'><code>${code}</code></pre>';">`;
    }

    renderPlantUML(code) {
        // Use PlantUML server for rendering
        const cleanCode = code.trim();
        // PlantUML uses deflate + base64 encoding
        const encoded = this.encodePlantUML(cleanCode);
        const imgUrl = `https://www.plantuml.com/plantuml/svg/${encoded}`;

        return `<div class="section-plantuml">
            <div class="section-header"><span class="section-icon">ðŸ—ï¸</span> PlantUML Diagram</div>
            <div class="section-content">
                <img src="${imgUrl}" alt="PlantUML Diagram" class="plantuml-img" onerror="this.parentElement.innerHTML='<div class=\\'render-error\\'>Failed to render diagram</div><pre>${this.escapeHtml(cleanCode)}</pre>'">
            </div>
            <details class="section-source"><summary>View Source</summary><pre><code>${this.escapeHtml(cleanCode)}</code></pre></details>
        </div>`;
    }

    encodePlantUML(text) {
        // Simple PlantUML encoding (hex-based for simplicity)
        // For production, use proper deflate encoding
        const encoder = new TextEncoder();
        const data = encoder.encode(text);
        let encoded = '';
        for (let i = 0; i < data.length; i++) {
            encoded += String.fromCharCode(data[i]);
        }
        return btoa(encoded).replace(/\+/g, '-').replace(/\//g, '_');
    }

    renderLatex(code) {
        const cleanCode = code.trim();
        // Use QuickLaTeX or KaTeX CDN
        const encoded = encodeURIComponent(cleanCode);
        const imgUrl = `https://latex.codecogs.com/svg.image?${encoded}`;

        return `<div class="section-latex">
            <div class="section-header"><span class="section-icon">âˆ‘</span> LaTeX / Math</div>
            <div class="section-content math-content">
                <img src="${imgUrl}" alt="LaTeX" class="latex-img" onerror="this.parentElement.innerHTML='<div class=\\'render-error\\'>Failed to render math</div><pre>${this.escapeHtml(cleanCode)}</pre>'">
            </div>
            <details class="section-source"><summary>View Source</summary><pre><code>${this.escapeHtml(cleanCode)}</code></pre></details>
        </div>`;
    }

    renderJsonOrChart(code) {
        const cleanCode = code.trim();
        try {
            const data = JSON.parse(cleanCode);

            // Check if it looks like chart data
            if (this.isChartData(data)) {
                return this.renderChartFromJson(data, cleanCode);
            }

            // Render as formatted JSON with syntax highlighting
            return `<div class="section-json">
                <div class="section-header"><span class="section-icon">ðŸ“‹</span> JSON Data</div>
                <div class="section-content">
                    <pre class="json-pretty"><code>${this.syntaxHighlightJson(data)}</code></pre>
                </div>
            </div>`;
        } catch (e) {
            return this.renderCode(cleanCode, 'json');
        }
    }

    isChartData(data) {
        // Detect common chart data patterns
        if (Array.isArray(data) && data.length > 0) {
            const first = data[0];
            // Array of objects with x/y or name/value
            if (typeof first === 'object' && (first.x !== undefined || first.name !== undefined || first.label !== undefined)) {
                return true;
            }
        }
        // Vega/Vega-Lite spec
        if (data.$schema && data.$schema.includes('vega')) {
            return true;
        }
        // Chart.js style
        if (data.type && data.data && data.data.datasets) {
            return true;
        }
        return false;
    }

    renderChartFromJson(data, rawCode) {
        // Simple table/chart visualization for data
        if (Array.isArray(data) && data.length > 0) {
            const keys = Object.keys(data[0]);
            const tableHtml = `
                <table class="data-table">
                    <thead><tr>${keys.map(k => `<th>${this.escapeHtml(k)}</th>`).join('')}</tr></thead>
                    <tbody>${data.slice(0, 20).map(row => `<tr>${keys.map(k => `<td>${this.escapeHtml(String(row[k] ?? ''))}</td>`).join('')}</tr>`).join('')}</tbody>
                </table>
                ${data.length > 20 ? `<div class="table-footer">Showing 20 of ${data.length} rows</div>` : ''}
            `;
            return `<div class="section-chart">
                <div class="section-header"><span class="section-icon">ðŸ“ˆ</span> Data Table</div>
                <div class="section-content">${tableHtml}</div>
                <details class="section-source"><summary>View JSON</summary><pre><code>${this.escapeHtml(rawCode)}</code></pre></details>
            </div>`;
        }
        return this.renderCode(rawCode, 'json');
    }

    renderCode(code, lang) {
        const cleanCode = code.trim();
        const langLabel = lang ? lang.charAt(0).toUpperCase() + lang.slice(1) : 'Code';
        const langIcon = { python: 'ðŸ', javascript: 'âš¡', js: 'âš¡', json: 'ðŸ“‹', sql: 'ðŸ—ƒï¸', bash: 'ðŸ’»', shell: 'ðŸ’»' }[lang?.toLowerCase()] || 'ðŸ“';

        return `<div class="section-code">
            <div class="section-header"><span class="section-icon">${langIcon}</span> ${langLabel}</div>
            <div class="section-content">
                <pre class="code-block"><code class="language-${lang || 'text'}">${this.escapeHtml(cleanCode)}</code></pre>
            </div>
        </div>`;
    }

    syntaxHighlightJson(obj, indent = 0) {
        const spaces = '  '.repeat(indent);
        if (obj === null) return '<span class="json-null">null</span>';
        if (typeof obj === 'boolean') return `<span class="json-boolean">${obj}</span>`;
        if (typeof obj === 'number') return `<span class="json-number">${obj}</span>`;
        if (typeof obj === 'string') return `<span class="json-string">"${this.escapeHtml(obj)}"</span>`;
        if (Array.isArray(obj)) {
            if (obj.length === 0) return '[]';
            const items = obj.map(item => spaces + '  ' + this.syntaxHighlightJson(item, indent + 1)).join(',\n');
            return `[\n${items}\n${spaces}]`;
        }
        if (typeof obj === 'object') {
            const keys = Object.keys(obj);
            if (keys.length === 0) return '{}';
            const items = keys.map(key =>
                `${spaces}  <span class="json-key">"${this.escapeHtml(key)}"</span>: ${this.syntaxHighlightJson(obj[key], indent + 1)}`
            ).join(',\n');
            return `{\n${items}\n${spaces}}`;
        }
        return String(obj);
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    async fetchPreviewContent(content, format) {
        const filename = 'preview';
        const response = await fetch(`${this.apiBase}/api/preview`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content, format, filename })
        });
        if (!response.ok) {
            const err = await response.json();
            throw new Error(err.detail || 'Preview failed');
        }
        return await response.text();
    }

    async fetchPreviewBlob(content, format) {
        const filename = 'preview';
        const response = await fetch(`${this.apiBase}/api/export`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ content, format, filename })
        });
        if (!response.ok) {
            const err = await response.json();
            throw new Error(err.detail || 'Preview failed');
        }
        return await response.blob();
    }

    async exportContent(msgIndex, format) {
        const msg = this.messages[msgIndex];
        if (!msg || !msg.content) return;

        // Find and disable the button
        const buttons = document.querySelectorAll('.download-btn');
        const btn = Array.from(buttons).find(b => b.textContent.trim().toUpperCase() === format.toUpperCase());
        if (btn) {
            btn.classList.add('loading');
            btn.disabled = true;
        }

        try {
            // Generate filename from first line or timestamp
            const firstLine = msg.content.split('\n')[0].replace(/^#+ /, '').replace(/[^a-zA-Z0-9 ]/g, '').trim();
            const filename = firstLine.substring(0, 50) || `export_${Date.now()}`;

            const response = await fetch(`${this.apiBase}/api/export`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    content: msg.content,
                    format: format,
                    filename: filename
                })
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Export failed');
            }

            // Get filename from Content-Disposition header or use default
            const contentDisposition = response.headers.get('Content-Disposition');
            let downloadFilename = `${filename}.${format}`;
            if (contentDisposition) {
                const match = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
                if (match) downloadFilename = match[1].replace(/['"]/g, '');
            }

            // Download the file
            const blob = await response.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = downloadFilename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);

        } catch (error) {
            console.error('Export failed:', error);
            alert(`Export failed: ${error.message}`);
        } finally {
            if (btn) {
                btn.classList.remove('loading');
                btn.disabled = false;
            }
        }
    }
    setProcessing(processing) { this.isProcessing = processing; this.sendBtn.disabled = processing; this.messageInput.disabled = processing; if (!processing) this.messageInput.focus(); }
    handleKeydown(e) { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); this.sendMessage(); } }
    autoResize() { this.messageInput.style.height = 'auto'; this.messageInput.style.height = Math.min(this.messageInput.scrollHeight, 200) + 'px'; }
    scrollToBottom() { if (this.chatArea) this.chatArea.scrollTop = this.chatArea.scrollHeight; }
    toggleSidebar() { if (this.sidebar) this.sidebar.classList.toggle('visible'); }

    // ==========================================================================
    // DRY: Load from unified registry API
    // ==========================================================================
    async loadCapabilities() {
        try {
            const resp = await fetch(`${this.apiBase}/api/capabilities`);
            if (!resp.ok) throw new Error('Failed to load capabilities');
            this.capabilities = await resp.json();

            // Use defaults from registry
            this.enabledWidgets = this.capabilities.defaults?.widgets || [];
            this.enabledTools = this.capabilities.defaults?.tools || [];

            // Override with localStorage if exists
            const savedWidgets = localStorage.getItem('jotty_widgets');
            if (savedWidgets) this.enabledWidgets = JSON.parse(savedWidgets);

            const savedTools = localStorage.getItem('jotty_tools');
            if (savedTools) this.enabledTools = JSON.parse(savedTools);

            // Update config badge count
            this.updateConfigBadge();
        } catch (e) {
            console.log('Capabilities API not available:', e.message);
        }
    }

    async loadAgents() {
        try {
            const resp = await fetch(`${this.apiBase}/api/agents`);
            if (!resp.ok) return;
            const data = await resp.json();
            this.agents = data.agents || [];
            this.renderAgentSelector();
        } catch (e) {
            console.log('Agents API not available');
        }
    }

    updateConfigBadge() {
        const badge = document.getElementById('config-btn');
        if (badge) {
            const count = this.enabledWidgets.length + this.enabledTools.length;
            badge.dataset.count = count > 0 ? count : '0';
        }
    }

    // ==========================================================================
    // Theme Support (JustJot.ai sync)
    // ==========================================================================
    applyTheme() {
        document.documentElement.setAttribute('data-theme', this.theme);
    }

    toggleTheme() {
        this.theme = this.theme === 'dark' ? 'light' : 'dark';
        localStorage.setItem('jotty_theme', this.theme);
        this.applyTheme();
        this.updateContextPanel();
    }

    syncThemeFromParent() {
        // Sync theme from JustJot.ai when embedded in iframe
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'theme-change') {
                this.theme = event.data.theme;
                this.applyTheme();
            }
        });
    }

    // ==========================================================================
    // Voice Recording (Web Speech API)
    // ==========================================================================
    initVoice() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            console.log('Voice input not supported in this browser');
            return;
        }

        this.recognition = new SpeechRecognition();
        this.recognition.continuous = true;
        this.recognition.interimResults = true;
        this.recognition.lang = 'en-US';

        this.recognition.onresult = (e) => {
            const transcript = Array.from(e.results)
                .map(r => r[0].transcript)
                .join('');
            this.messageInput.value = transcript;
            this.autoResize();
        };

        this.recognition.onerror = (e) => {
            console.error('Voice error:', e.error);
            this.stopVoice();
        };

        this.recognition.onend = () => {
            this.isListening = false;
            document.getElementById('voice-btn')?.classList.remove('listening');
        };
    }

    toggleVoice() {
        if (this.isListening) {
            this.stopVoice();
        } else {
            this.startVoice();
        }
    }

    startVoice() {
        if (!this.recognition) {
            this.showNotification('Voice input not supported in this browser', 'error');
            return;
        }
        try {
            this.recognition.start();
            this.isListening = true;
            document.getElementById('voice-btn')?.classList.add('listening');
            this.showNotification('Listening...', 'info');
        } catch (e) {
            console.error('Failed to start voice:', e);
        }
    }

    stopVoice() {
        if (this.recognition) {
            this.recognition.stop();
        }
        this.isListening = false;
        document.getElementById('voice-btn')?.classList.remove('listening');
    }

    // ==========================================================================
    // Voice-to-Voice Chat (Full Duplex)
    // ==========================================================================
    initVoiceChat() {
        this.voiceChatMode = false;
        this.isRecordingVoice = false;
        this.isPlayingResponse = false;
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.audioContext = null;
        this.currentAudio = null;

        // Voice picker
        this.availableVoices = {};
        this.selectedVoice = localStorage.getItem('jotty_voice') || 'en-US-AvaNeural';
        this.voicePickerOpen = false;
        this.loadAvailableVoices();

        // Speed control (0.5x to 2x)
        this.ttsSpeed = parseFloat(localStorage.getItem('jotty_tts_speed')) || 1.0;

        // Push-to-talk (hold spacebar)
        this.pushToTalkEnabled = true;
        this.spacebarHeld = false;
        this.initPushToTalk();

        // Wake word detection
        this.wakeWordEnabled = false;
        this.wakeWordListening = false;
        this.wakeWordRecognition = null;
        this.wakeWords = ['hey jotty', 'hey jody', 'hey jordy', 'ok jotty', 'hello jotty'];

        // Continuous conversation mode
        this.continuousMode = false;

        // Transcript panel
        this.voiceTranscript = [];

        // WebSocket voice mode (low latency)
        this.voiceWebSocket = null;
        this.voiceConfig = {
            localWhisper: false,
            speculativeTts: false,
            websocketVoice: false,
            whisperModel: 'base'
        };
        this.loadVoiceConfig();
    }

    async loadVoiceConfig() {
        // Load voice processing configuration from server
        try {
            const resp = await fetch(`${this.apiBase}/api/voice/config`);
            if (resp.ok) {
                const config = await resp.json();
                this.voiceConfig = {
                    localWhisper: config.local_whisper || false,
                    speculativeTts: config.speculative_tts || false,
                    websocketVoice: config.websocket_voice || false,
                    whisperModel: config.whisper_model || 'base'
                };
                console.log('Voice config loaded:', this.voiceConfig);

                // Auto-connect WebSocket if enabled
                if (this.voiceConfig.websocketVoice) {
                    this.connectVoiceWebSocket();
                }
            }
        } catch (e) {
            console.log('Voice config not available, using defaults');
        }
    }

    connectVoiceWebSocket() {
        // Connect to WebSocket for low-latency voice
        if (this.voiceWebSocket && this.voiceWebSocket.readyState === WebSocket.OPEN) {
            return;
        }

        const wsUrl = `${this.wsBase}/ws/voice/${this.sessionId}`;
        console.log('Connecting voice WebSocket:', wsUrl);

        this.voiceWebSocket = new WebSocket(wsUrl);

        this.voiceWebSocket.onopen = () => {
            console.log('Voice WebSocket connected');
            // Send config
            this.voiceWebSocket.send(JSON.stringify({
                type: 'config',
                voice: this.selectedVoice,
                speed: this.ttsSpeed,
                speculative: this.voiceConfig.speculativeTts
            }));
        };

        this.voiceWebSocket.onmessage = async (event) => {
            if (event.data instanceof Blob) {
                // Audio data - queue for playback
                const arrayBuffer = await event.data.arrayBuffer();
                this.audioQueue.push(arrayBuffer);
                if (!this.isPlayingQueue) {
                    this.playAudioQueue();
                }
            } else {
                // JSON message
                const data = JSON.parse(event.data);
                this.handleVoiceWebSocketMessage(data);
            }
        };

        this.voiceWebSocket.onerror = (e) => {
            console.error('Voice WebSocket error:', e);
        };

        this.voiceWebSocket.onclose = () => {
            console.log('Voice WebSocket closed');
            this.voiceWebSocket = null;
        };
    }

    handleVoiceWebSocketMessage(data) {
        switch (data.type) {
            case 'capabilities':
                console.log('Server capabilities:', data);
                this.voiceConfig.localWhisper = data.local_whisper;
                this.voiceConfig.speculativeTts = data.speculative_tts;
                break;

            case 'config_ack':
                console.log('Config acknowledged:', data);
                break;

            case 'transcription':
                // User's transcribed text
                this.showCaption(data.text, 'user');
                setTimeout(() => this.hideCaption(), 2000);
                this.addMessage('user', data.text);
                this.addToTranscript('user', data.text);
                // Show confidence if available
                if (data.confidence !== undefined) {
                    const lastMsg = this.messagesContainer.lastElementChild;
                    if (lastMsg) {
                        const meta = lastMsg.querySelector('.message-meta');
                        if (meta) this.showConfidenceIndicator(data.confidence, meta);
                    }
                }
                break;

            case 'response_text':
                this.showCaption(data.text.slice(-100), 'assistant');
                break;

            case 'audio_start':
                this.updateVoiceChatUI('playing');
                this.startBargeInDetection();
                break;

            case 'audio_end':
                this.hideCaption();
                // Don't stop barge-in detection yet - wait for queue to finish
                break;

            case 'error':
                this.showNotification(`Voice error: ${data.message}`, 'error');
                this.updateVoiceChatUI('idle');
                break;

            case 'cancelled':
                this.updateVoiceChatUI('idle');
                break;
        }
    }

    disconnectVoiceWebSocket() {
        if (this.voiceWebSocket) {
            this.voiceWebSocket.close();
            this.voiceWebSocket = null;
        }
    }

    toggleWakeWord() {
        if (this.wakeWordListening) {
            this.stopWakeWordDetection();
        } else {
            this.startWakeWordDetection();
        }
    }

    startWakeWordDetection() {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            this.showNotification('Wake word not supported in this browser', 'error');
            return;
        }

        this.wakeWordRecognition = new SpeechRecognition();
        this.wakeWordRecognition.continuous = true;
        this.wakeWordRecognition.interimResults = true;
        this.wakeWordRecognition.lang = 'en-US';

        this.wakeWordRecognition.onresult = (event) => {
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript.toLowerCase().trim();

                // Check for wake word
                for (const wakeWord of this.wakeWords) {
                    if (transcript.includes(wakeWord)) {
                        console.log('Wake word detected:', transcript);
                        this.onWakeWordDetected();
                        return;
                    }
                }
            }
        };

        this.wakeWordRecognition.onerror = (event) => {
            if (event.error !== 'no-speech') {
                console.error('Wake word error:', event.error);
            }
        };

        this.wakeWordRecognition.onend = () => {
            // Restart if still enabled
            if (this.wakeWordListening && !this.isRecordingVoice) {
                setTimeout(() => {
                    if (this.wakeWordListening) {
                        this.wakeWordRecognition.start();
                    }
                }, 100);
            }
        };

        this.wakeWordRecognition.start();
        this.wakeWordListening = true;
        this.wakeWordEnabled = true;
        this.updateWakeWordUI(true);
        this.showNotification('ðŸŽ¤ Listening for "Hey Jotty"...', 'info');
    }

    stopWakeWordDetection() {
        if (this.wakeWordRecognition) {
            this.wakeWordListening = false;
            this.wakeWordRecognition.stop();
            this.wakeWordRecognition = null;
        }
        this.wakeWordEnabled = false;
        this.updateWakeWordUI(false);
    }

    onWakeWordDetected() {
        // Stop wake word detection temporarily
        if (this.wakeWordRecognition) {
            this.wakeWordRecognition.stop();
        }

        // Play activation sound (optional beep)
        this.playActivationBeep();

        // Start voice recording
        this.showNotification('ðŸŽ¤ Yes? I\'m listening...', 'info');
        this.startVoiceRecording();
    }

    playActivationBeep() {
        try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = ctx.createOscillator();
            const gainNode = ctx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(ctx.destination);

            oscillator.frequency.value = 880; // A5 note
            oscillator.type = 'sine';
            gainNode.gain.value = 0.1;

            oscillator.start();
            oscillator.stop(ctx.currentTime + 0.1); // 100ms beep
        } catch (e) {}
    }

    updateWakeWordUI(active) {
        const btn = document.getElementById('wake-word-btn');
        if (btn) {
            btn.classList.toggle('active', active);
            btn.title = active ? 'Wake word active (click to disable)' : 'Enable wake word ("Hey Jotty")';
        }
    }

    toggleContinuousMode() {
        this.continuousMode = !this.continuousMode;
        const btn = document.getElementById('continuous-btn');
        if (btn) {
            btn.classList.toggle('active', this.continuousMode);
            btn.title = this.continuousMode ? 'Continuous mode ON (click to disable)' : 'Enable continuous conversation';
        }
        this.showNotification(
            this.continuousMode ? 'ðŸ”„ Continuous mode ON' : 'â¹ï¸ Continuous mode OFF',
            'info'
        );
    }

    // Transcript panel functions
    toggleTranscriptPanel() {
        const panel = document.getElementById('transcript-panel');
        panel?.classList.toggle('open');
    }

    addToTranscript(role, text) {
        const timestamp = new Date().toLocaleTimeString();
        this.voiceTranscript.push({ role, text, timestamp });
        this.renderTranscript();
    }

    renderTranscript() {
        const content = document.getElementById('transcript-content');
        if (!content) return;

        if (this.voiceTranscript.length === 0) {
            content.innerHTML = '<p class="transcript-empty">Voice transcripts will appear here...</p>';
            return;
        }

        content.innerHTML = this.voiceTranscript.map(entry => `
            <div class="transcript-entry ${entry.role}">
                <span class="transcript-time">${entry.timestamp}</span>
                <span class="transcript-role">${entry.role === 'user' ? 'You' : 'Jotty'}:</span>
                <span class="transcript-text">${entry.text}</span>
            </div>
        `).join('');

        // Scroll to bottom
        content.scrollTop = content.scrollHeight;
    }

    copyTranscript() {
        const text = this.voiceTranscript.map(e =>
            `[${e.timestamp}] ${e.role === 'user' ? 'You' : 'Jotty'}: ${e.text}`
        ).join('\n');

        navigator.clipboard.writeText(text).then(() => {
            this.showNotification('ðŸ“‹ Transcript copied!', 'info');
        });
    }

    clearTranscript() {
        this.voiceTranscript = [];
        this.renderTranscript();
        this.showNotification('ðŸ—‘ï¸ Transcript cleared', 'info');
    }

    // Export audio as MP3
    async exportConversationAudio() {
        if (this.voiceTranscript.length === 0) {
            this.showNotification('No transcript to export', 'error');
            return;
        }

        this.showNotification('ðŸŽµ Generating audio export...', 'info');

        try {
            // Combine all text
            const fullText = this.voiceTranscript.map(e =>
                `${e.role === 'user' ? 'User says:' : 'Assistant says:'} ${e.text}`
            ).join('. ');

            // Generate TTS
            const formData = new FormData();
            formData.append('text', fullText.slice(0, 5000));
            formData.append('voice', this.selectedVoice || 'en-US-AvaNeural');

            const response = await fetch(`${this.apiBase}/api/voice/tts`, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `jotty-conversation-${Date.now()}.mp3`;
                a.click();
                URL.revokeObjectURL(url);
                this.showNotification('âœ… Audio exported!', 'info');
            }
        } catch (e) {
            console.error('Export failed:', e);
            this.showNotification('Export failed', 'error');
        }
    }

    exportTranscriptText() {
        if (this.voiceTranscript.length === 0) {
            this.showNotification('No transcript to export', 'error');
            return;
        }

        const text = this.voiceTranscript.map(e =>
            `[${e.timestamp}] ${e.role === 'user' ? 'You' : 'Jotty'}: ${e.text}`
        ).join('\n\n');

        const blob = new Blob([text], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `jotty-transcript-${Date.now()}.txt`;
        a.click();
        URL.revokeObjectURL(url);
        this.showNotification('âœ… Transcript exported!', 'info');
    }

    // #24 Recording tab indicator
    setTabRecordingIndicator(recording) {
        const originalTitle = document.title.replace(/^ðŸ”´ /, '');
        document.title = recording ? `ðŸ”´ ${originalTitle}` : originalTitle;
    }

    // #25 Live captions during playback
    showCaption(text) {
        let caption = document.getElementById('live-caption');
        if (!caption) {
            caption = document.createElement('div');
            caption.id = 'live-caption';
            caption.className = 'live-caption';
            document.body.appendChild(caption);
        }
        caption.textContent = text;
        caption.classList.add('visible');

        // Hide after 3 seconds
        clearTimeout(this.captionTimeout);
        this.captionTimeout = setTimeout(() => {
            caption.classList.remove('visible');
        }, 3000);
    }

    hideCaption() {
        const caption = document.getElementById('live-caption');
        if (caption) {
            caption.classList.remove('visible');
        }
    }

    // #22 Confidence indicator - shows STT confidence level
    showConfidenceIndicator(confidence, element) {
        if (!element || typeof confidence !== 'number') return;

        const percent = Math.round(confidence * 100);
        let level = 'high';
        if (percent < 70) level = 'low';
        else if (percent < 85) level = 'medium';

        const indicator = document.createElement('span');
        indicator.className = 'confidence-indicator';
        indicator.innerHTML = `
            <span class="confidence-bar">
                <span class="confidence-fill ${level}" style="width: ${percent}%"></span>
            </span>
            <span class="confidence-text">${percent}%</span>
        `;
        indicator.title = `STT Confidence: ${percent}%`;
        element.appendChild(indicator);
    }

    // #23 Retry on failure - auto-retry voice operations
    async retryWithBackoff(fn, maxRetries = 3, baseDelay = 500) {
        let lastError;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            try {
                return await fn();
            } catch (err) {
                lastError = err;
                console.log(`Attempt ${attempt + 1} failed:`, err.message);
                if (attempt < maxRetries - 1) {
                    const delay = baseDelay * Math.pow(2, attempt); // Exponential backoff
                    this.showNotification(`Retrying... (${attempt + 2}/${maxRetries})`, 'info');
                    await new Promise(r => setTimeout(r, delay));
                }
            }
        }
        throw lastError;
    }

    initPushToTalk() {
        // Keydown handler for push-to-talk and shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger if typing in input/textarea
            const activeEl = document.activeElement;
            const isTyping = activeEl && (
                activeEl.tagName === 'INPUT' ||
                activeEl.tagName === 'TEXTAREA' ||
                activeEl.isContentEditable
            );

            if (isTyping) return;

            // Push-to-talk: Hold spacebar
            if (e.code === 'Space' && !this.spacebarHeld && this.pushToTalkEnabled) {
                if (!this.isRecordingVoice) {
                    e.preventDefault();
                    this.spacebarHeld = true;
                    this.startPushToTalk();
                }
            }

            // Keyboard shortcuts (without modifiers to keep it simple)
            switch (e.key.toLowerCase()) {
                case 'r': // R = Start recording
                    if (!e.ctrlKey && !e.metaKey && !this.isRecordingVoice) {
                        e.preventDefault();
                        this.toggleVoiceChat();
                    }
                    break;
                case 's': // S = Stop
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        if (this.isRecordingVoice) {
                            this.stopVoiceRecording();
                        } else if (this.isPlayingQueue || this.isPlayingResponse) {
                            this.interruptPlayback();
                        }
                    }
                    break;
                case 'm': // M = Mute/stop playback
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        this.interruptPlayback();
                    }
                    break;
                case 'c': // C = Continuous mode
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        this.toggleContinuousMode();
                    }
                    break;
                case 't': // T = Transcript panel
                    if (!e.ctrlKey && !e.metaKey) {
                        e.preventDefault();
                        this.toggleTranscriptPanel();
                    }
                    break;
                case 'escape': // ESC = Stop everything
                    this.interruptPlayback();
                    if (this.isRecordingVoice) {
                        this.stopVoiceRecording();
                    }
                    break;
            }
        });

        // Keyup - stop recording when spacebar released
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space' && this.spacebarHeld) {
                e.preventDefault();
                this.spacebarHeld = false;
                this.stopPushToTalk();
            }
        });
    }

    async startPushToTalk() {
        // Interrupt any playing audio
        if (this.isPlayingQueue || this.isPlayingResponse) {
            this.interruptPlayback();
        }

        // Start recording without VAD auto-stop (manual release)
        try {
            // Audio with noise suppression
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true
                }
            });

            const mimeType = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4';
            this.mediaRecorder = new MediaRecorder(stream, { mimeType });
            this.audioChunks = [];
            this.voiceStream = stream;

            this.mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    this.audioChunks.push(e.data);
                }
            };

            this.mediaRecorder.onstop = async () => {
                stream.getTracks().forEach(track => track.stop());
                await this.processVoiceRecording();
            };

            this.mediaRecorder.start(100);
            this.isRecordingVoice = true;
            this.updateVoiceChatUI('recording');
            this.showNotification('ðŸŽ¤ Hold spacebar... release to send', 'info');

        } catch (err) {
            console.error('Push-to-talk error:', err);
            this.spacebarHeld = false;
        }
    }

    stopPushToTalk() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
            this.mediaRecorder.stop();
            this.isRecordingVoice = false;
            this.updateVoiceChatUI('processing');
        }
    }

    async loadAvailableVoices() {
        try {
            const resp = await fetch(`${this.apiBase}/api/voice/voices`);
            const data = await resp.json();
            this.availableVoices = data.voices || {};
        } catch (e) {
            console.error('Failed to load voices:', e);
            // Fallback
            this.availableVoices = {
                'en-us-female': 'en-US-AvaNeural',
                'en-us-male': 'en-US-AndrewNeural'
            };
        }
    }

    toggleVoicePicker() {
        this.voicePickerOpen = !this.voicePickerOpen;
        const dropdown = document.getElementById('voice-picker-dropdown');
        if (!dropdown) return;

        if (this.voicePickerOpen) {
            const voicesHtml = Object.entries(this.availableVoices).map(([key, value]) => `
                <div class="voice-option ${this.selectedVoice === value ? 'selected' : ''}"
                     onclick="jottyApp.selectVoice('${value}', '${key}')">
                    <span class="voice-icon">${key.includes('female') ? 'ðŸ‘©' : 'ðŸ‘¨'}</span>
                    <span class="voice-name">${this.formatVoiceName(key)}</span>
                    ${this.selectedVoice === value ? '<span class="voice-check">âœ“</span>' : ''}
                </div>
            `).join('');

            // Add speed control slider
            const speedHtml = `
                <div class="voice-speed-control">
                    <label>Speed: <span id="speed-value">${this.ttsSpeed.toFixed(1)}x</span></label>
                    <input type="range" id="speed-slider" min="0.5" max="2.0" step="0.1"
                           value="${this.ttsSpeed}" onchange="jottyApp.setTTSSpeed(this.value)"
                           oninput="document.getElementById('speed-value').textContent = parseFloat(this.value).toFixed(1) + 'x'">
                    <div class="speed-labels"><span>0.5x</span><span>1x</span><span>2x</span></div>
                </div>
            `;

            dropdown.innerHTML = voicesHtml + speedHtml;
            dropdown.classList.add('open');
        } else {
            dropdown.classList.remove('open');
        }
    }

    setTTSSpeed(speed) {
        this.ttsSpeed = parseFloat(speed);
        localStorage.setItem('jotty_tts_speed', this.ttsSpeed);
    }

    // Voice commands detection and execution
    detectVoiceCommand(text) {
        const lowerText = text.toLowerCase().trim();

        // Command patterns
        const commands = {
            'stop': ['stop', 'stop it', 'shut up', 'be quiet', 'silence', 'cancel'],
            'repeat': ['repeat', 'repeat that', 'say that again', 'what did you say', 'again please', 'come again'],
            'slower': ['slower', 'slow down', 'speak slower', 'too fast', 'more slowly'],
            'faster': ['faster', 'speed up', 'speak faster', 'too slow', 'quicker'],
            'louder': ['louder', 'speak up', 'can\'t hear', 'volume up'],
            'help': ['help', 'what can you do', 'voice commands', 'what commands']
        };

        for (const [command, phrases] of Object.entries(commands)) {
            for (const phrase of phrases) {
                if (lowerText.includes(phrase) || lowerText === phrase) {
                    return command;
                }
            }
        }
        return null;
    }

    async executeVoiceCommand(command, originalText) {
        this.updateVoiceChatUI('idle');

        switch (command) {
            case 'stop':
                this.interruptPlayback();
                this.showNotification('â¹ï¸ Stopped', 'info');
                break;

            case 'repeat':
                // Repeat the last assistant message
                const lastAssistant = [...this.messages].reverse().find(m => m.role === 'assistant');
                if (lastAssistant && lastAssistant.content) {
                    this.showNotification('ðŸ”„ Repeating...', 'info');
                    await this.speakText(lastAssistant.content);
                } else {
                    this.showNotification('Nothing to repeat', 'info');
                }
                break;

            case 'slower':
                this.ttsSpeed = Math.max(0.5, this.ttsSpeed - 0.2);
                localStorage.setItem('jotty_tts_speed', this.ttsSpeed);
                this.showNotification(`ðŸ¢ Speed: ${this.ttsSpeed.toFixed(1)}x`, 'info');
                await this.speakText(`Speaking slower now at ${this.ttsSpeed.toFixed(1)} times speed`);
                break;

            case 'faster':
                this.ttsSpeed = Math.min(2.0, this.ttsSpeed + 0.2);
                localStorage.setItem('jotty_tts_speed', this.ttsSpeed);
                this.showNotification(`ðŸ‡ Speed: ${this.ttsSpeed.toFixed(1)}x`, 'info');
                await this.speakText(`Speaking faster now at ${this.ttsSpeed.toFixed(1)} times speed`);
                break;

            case 'louder':
                this.showNotification('ðŸ”Š Volume is at maximum', 'info');
                await this.speakText('Volume is already at maximum. Please adjust your device volume.');
                break;

            case 'help':
                const helpText = 'You can say: Stop, Repeat that, Slower, Faster, or just talk to me normally.';
                this.showNotification('Voice commands', 'info');
                await this.speakText(helpText);
                break;
        }

        // Restart wake word if enabled
        if (this.wakeWordEnabled && !this.wakeWordListening) {
            setTimeout(() => this.startWakeWordDetection(), 1000);
        }
    }

    formatVoiceName(key) {
        // Convert 'en-us-female' to 'US Female'
        const parts = key.split('-');
        const region = parts[1]?.toUpperCase() || '';
        const gender = parts[2]?.charAt(0).toUpperCase() + parts[2]?.slice(1) || '';
        return `${region} ${gender}`;
    }

    selectVoice(voiceId, key) {
        this.selectedVoice = voiceId;
        localStorage.setItem('jotty_voice', voiceId);
        this.voicePickerOpen = false;
        document.getElementById('voice-picker-dropdown')?.classList.remove('open');
        this.showNotification(`Voice: ${this.formatVoiceName(key)}`, 'info');
    }

    async toggleVoiceChat() {
        if (this.isRecordingVoice) {
            await this.stopVoiceRecording();
        } else {
            // Interrupt: Stop any playing audio before recording
            if (this.isPlayingQueue || this.isPlayingResponse) {
                this.interruptPlayback();
            }
            await this.startVoiceRecording();
        }
    }

    interruptPlayback() {
        // Stop audio queue playback
        this.isPlayingQueue = false;
        this.audioQueue = [];

        // Stop current audio source
        if (this.currentAudioSource) {
            try {
                this.currentAudioSource.stop();
            } catch (e) {}
            this.currentAudioSource = null;
        }

        // Stop HTML5 audio fallback
        if (this.currentAudio) {
            this.currentAudio.pause();
            this.currentAudio = null;
        }

        this.isPlayingResponse = false;
        this.updateVoiceChatUI('idle');
        console.log('Playback interrupted for new recording');
    }

    async startVoiceRecording() {
        try {
            // Audio constraints with noise suppression and echo cancellation
            const audioConstraints = {
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true,
                    channelCount: 1,
                    sampleRate: 16000
                }
            };
            const stream = await navigator.mediaDevices.getUserMedia(audioConstraints);

            // Use webm for better compatibility
            const mimeType = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4';
            this.mediaRecorder = new MediaRecorder(stream, { mimeType });
            this.audioChunks = [];
            this.voiceStream = stream;

            // VAD (Voice Activity Detection) setup
            this.vadContext = new (window.AudioContext || window.webkitAudioContext)();
            const source = this.vadContext.createMediaStreamSource(stream);
            this.vadAnalyser = this.vadContext.createAnalyser();
            this.vadAnalyser.fftSize = 512;
            this.vadAnalyser.smoothingTimeConstant = 0.5;
            source.connect(this.vadAnalyser);

            // VAD parameters
            const silenceThreshold = 15;      // Audio level below this = silence
            const silenceDuration = 1500;     // Stop after 1.5s of silence
            const minRecordingTime = 500;     // Minimum 0.5s recording
            let silenceStart = null;
            let recordingStart = Date.now();
            let hasDetectedSpeech = false;

            this.mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    this.audioChunks.push(e.data);
                    // Stream audio to WebSocket if connected (lower latency)
                    if (this.voiceWebSocket && this.voiceWebSocket.readyState === WebSocket.OPEN) {
                        this.voiceWebSocket.send(e.data);
                    }
                }
            };

            this.mediaRecorder.onstop = async () => {
                this.stopVAD();
                stream.getTracks().forEach(track => track.stop());

                // Use WebSocket if connected, otherwise HTTP
                if (this.voiceWebSocket && this.voiceWebSocket.readyState === WebSocket.OPEN) {
                    // Signal end of audio to WebSocket
                    this.voiceWebSocket.send(JSON.stringify({ type: 'end_audio' }));
                    this.updateVoiceChatUI('processing');
                } else {
                    // Fallback to HTTP
                    await this.processVoiceRecording();
                }
            };

            // VAD monitoring loop
            const dataArray = new Uint8Array(this.vadAnalyser.frequencyBinCount);
            const levelBar = document.getElementById('level-bar');
            const wrapper = document.querySelector('.voice-chat-wrapper');
            wrapper?.classList.add('recording');

            this.vadInterval = setInterval(() => {
                if (!this.isRecordingVoice) return;

                this.vadAnalyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                // Update audio level meter (0-100%)
                const level = Math.min(100, (average / 128) * 100);
                if (levelBar) {
                    levelBar.style.height = `${level}%`;
                }

                const elapsed = Date.now() - recordingStart;

                if (average > silenceThreshold) {
                    // Speech detected
                    hasDetectedSpeech = true;
                    silenceStart = null;
                } else if (hasDetectedSpeech && elapsed > minRecordingTime) {
                    // Silence after speech
                    if (!silenceStart) {
                        silenceStart = Date.now();
                    } else if (Date.now() - silenceStart > silenceDuration) {
                        // Auto-stop after silence threshold
                        console.log('VAD: Auto-stopping after silence');
                        this.stopVoiceRecording();
                    }
                }
            }, 100);

            this.mediaRecorder.start(100); // Collect data every 100ms
            this.isRecordingVoice = true;
            this.updateVoiceChatUI('recording');
            this.setTabRecordingIndicator(true);
            this.showNotification('ðŸŽ¤ Listening... (auto-stops when you pause)', 'info');

        } catch (err) {
            console.error('Microphone access error:', err);
            this.showNotification('Could not access microphone', 'error');
        }
    }

    stopVAD() {
        if (this.vadInterval) {
            clearInterval(this.vadInterval);
            this.vadInterval = null;
        }
        if (this.vadContext && this.vadContext.state !== 'closed') {
            this.vadContext.close().catch(() => {});
            this.vadContext = null;
        }
        // Reset level meter
        const levelBar = document.getElementById('level-bar');
        if (levelBar) levelBar.style.height = '0%';
        document.querySelector('.voice-chat-wrapper')?.classList.remove('recording');
    }

    async stopVoiceRecording() {
        if (this.mediaRecorder && this.mediaRecorder.state === 'recording') {
            this.mediaRecorder.stop();
            this.isRecordingVoice = false;
            this.setTabRecordingIndicator(false);
            this.updateVoiceChatUI('processing');
        }
    }

    async processVoiceRecording() {
        if (this.audioChunks.length === 0) {
            this.updateVoiceChatUI('idle');
            return;
        }

        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });
        this.audioChunks = [];

        try {
            this.showNotification('ðŸ”„ Processing voice...', 'info');

            // Use retry wrapper for resilience (#23)
            await this.retryWithBackoff(async () => {
                // Send to turbo streaming voice chat API for lowest latency
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');
                formData.append('session_id', this.sessionId);
                formData.append('voice', this.selectedVoice || 'en-US-AvaNeural');
                formData.append('speed', this.ttsSpeed || 1.0);

                const response = await fetch(`${this.apiBase}/api/voice/chat/stream/ultra`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`Voice chat failed: ${response.status}`);
                }

                // Process SSE stream - play audio chunks as they arrive
                await this.processStreamingVoiceResponse(response);
            }, 2); // Max 2 retries

        } catch (err) {
            console.error('Voice processing error:', err);
            this.showNotification('Voice processing failed. Please try again.', 'error');
            this.updateVoiceChatUI('idle');
        }
    }

    async processStreamingVoiceResponse(response) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';
        let fullText = '';
        let userText = '';
        let isFirstChunk = true;

        // Audio queue for seamless playback
        this.audioQueue = [];
        this.isPlayingQueue = false;

        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') {
                            // Add final message to chat and transcript
                            if (fullText) {
                                this.addMessage('assistant', fullText);
                                this.addToTranscript('assistant', fullText);
                            }
                            // Hide live caption when done
                            this.hideCaption();
                            continue;
                        }

                        try {
                            const chunk = JSON.parse(data);

                            // First chunk contains user text
                            if (isFirstChunk && chunk.user_text) {
                                userText = chunk.user_text;

                                // Show live caption for user text (#25)
                                this.showCaption(userText, 'user');
                                setTimeout(() => this.hideCaption(), 2000);

                                // Check for voice commands before processing
                                const command = this.detectVoiceCommand(userText);
                                if (command) {
                                    await this.executeVoiceCommand(command, userText);
                                    reader.cancel(); // Stop reading the stream
                                    return;
                                }

                                this.addMessage('user', userText);
                                this.addToTranscript('user', userText);

                                // Show confidence indicator if available (#22)
                                if (chunk.confidence !== undefined) {
                                    const lastMsg = this.messagesContainer.lastElementChild;
                                    if (lastMsg) {
                                        const meta = lastMsg.querySelector('.message-meta');
                                        if (meta) this.showConfidenceIndicator(chunk.confidence, meta);
                                    }
                                }
                                isFirstChunk = false;
                            }

                            // Accumulate response text and show live caption (#25)
                            if (chunk.text) {
                                fullText += chunk.text;
                                // Show last 100 chars of response as live caption
                                const captionText = fullText.length > 100
                                    ? '...' + fullText.slice(-100)
                                    : fullText;
                                this.showCaption(captionText, 'assistant');
                            }

                            // Queue audio for playback
                            if (chunk.audio_base64) {
                                const audioData = this.base64ToArrayBuffer(chunk.audio_base64);
                                this.audioQueue.push(audioData);

                                // Start playing if not already
                                if (!this.isPlayingQueue) {
                                    this.playAudioQueue();
                                }
                            }
                        } catch (e) {
                            console.error('Failed to parse SSE chunk:', e);
                        }
                    }
                }
            }
        } finally {
            reader.releaseLock();
        }
    }

    base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    async playAudioQueue() {
        if (this.isPlayingQueue) return;
        this.isPlayingQueue = true;
        this.updateVoiceChatUI('playing');

        // Start barge-in detection while playing
        this.startBargeInDetection();

        while (this.audioQueue.length > 0 || this.isPlayingQueue) {
            // Check if barge-in interrupted playback
            if (this.bargeInTriggered) {
                this.bargeInTriggered = false;
                break;
            }

            if (this.audioQueue.length === 0) {
                // Wait for more audio
                await new Promise(r => setTimeout(r, 50));
                continue;
            }

            const audioData = this.audioQueue.shift();
            await this.playAudioChunk(audioData);
        }

        this.stopBargeInDetection();
        this.updateVoiceChatUI('idle');

        // Continuous mode: auto-start recording after response finishes
        if (this.continuousMode && !this.bargeInTriggered) {
            setTimeout(() => {
                if (this.continuousMode && !this.isRecordingVoice) {
                    this.showNotification('ðŸŽ¤ Listening...', 'info');
                    this.startVoiceRecording();
                }
            }, 500); // Small delay before next listen
        }
    }

    async startBargeInDetection() {
        if (this.bargeInStream) return;

        try {
            this.bargeInStream = await navigator.mediaDevices.getUserMedia({
                audio: { echoCancellation: true, noiseSuppression: true }
            });

            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const source = ctx.createMediaStreamSource(this.bargeInStream);
            const analyser = ctx.createAnalyser();
            analyser.fftSize = 256;
            source.connect(analyser);

            const dataArray = new Uint8Array(analyser.frequencyBinCount);
            const threshold = 40; // Higher threshold to avoid echo
            let consecutiveHits = 0;

            this.bargeInInterval = setInterval(() => {
                if (!this.isPlayingQueue) return;

                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                if (average > threshold) {
                    consecutiveHits++;
                    if (consecutiveHits >= 3) { // Need 300ms of speech
                        console.log('Barge-in detected!');
                        this.triggerBargeIn();
                    }
                } else {
                    consecutiveHits = 0;
                }
            }, 100);

            this.bargeInContext = ctx;

        } catch (e) {
            console.log('Barge-in detection not available:', e);
        }
    }

    stopBargeInDetection() {
        if (this.bargeInInterval) {
            clearInterval(this.bargeInInterval);
            this.bargeInInterval = null;
        }
        if (this.bargeInStream) {
            this.bargeInStream.getTracks().forEach(t => t.stop());
            this.bargeInStream = null;
        }
        if (this.bargeInContext) {
            this.bargeInContext.close().catch(() => {});
            this.bargeInContext = null;
        }
    }

    triggerBargeIn() {
        // Stop current playback
        this.bargeInTriggered = true;
        this.interruptPlayback();
        this.stopBargeInDetection();

        // Start new recording
        this.showNotification('ðŸŽ¤ Barge-in: Listening...', 'info');
        this.startVoiceRecording();
    }

    async playAudioChunk(audioData) {
        return new Promise(async (resolve) => {
            try {
                // Create audio context if needed
                if (!this.audioContext) {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }

                const audioBuffer = await this.audioContext.decodeAudioData(audioData.slice(0));
                const source = this.audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(this.audioContext.destination);

                source.onended = () => resolve();
                source.start(0);
                this.currentAudioSource = source;

            } catch (err) {
                console.error('Audio chunk playback error:', err);
                // Fallback to HTML5 Audio
                try {
                    const blob = new Blob([audioData], { type: 'audio/mpeg' });
                    const url = URL.createObjectURL(blob);
                    const audio = new Audio(url);
                    audio.onended = () => {
                        URL.revokeObjectURL(url);
                        resolve();
                    };
                    audio.onerror = () => resolve();
                    await audio.play();
                } catch (e) {
                    resolve();
                }
            }
        });
    }

    async playAudioResponse(audioData) {
        try {
            this.updateVoiceChatUI('playing');

            // Create audio context if needed
            if (!this.audioContext) {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            // Resume if suspended
            if (this.audioContext.state === 'suspended') {
                await this.audioContext.resume();
            }

            // Decode and play
            const audioBuffer = await this.audioContext.decodeAudioData(audioData);
            const source = this.audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(this.audioContext.destination);

            source.onended = () => {
                this.isPlayingResponse = false;
                this.updateVoiceChatUI('idle');
            };

            this.isPlayingResponse = true;
            source.start(0);
            this.currentAudioSource = source;

        } catch (err) {
            console.error('Audio playback error:', err);
            // Fallback: use HTML5 Audio
            try {
                const blob = new Blob([audioData], { type: 'audio/mpeg' });
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                audio.onended = () => {
                    URL.revokeObjectURL(url);
                    this.updateVoiceChatUI('idle');
                };
                await audio.play();
            } catch (e) {
                console.error('Fallback audio failed:', e);
                this.updateVoiceChatUI('idle');
            }
        }
    }

    stopAudioPlayback() {
        if (this.currentAudioSource) {
            try {
                this.currentAudioSource.stop();
            } catch (e) {}
        }
        if (this.currentAudio) {
            this.currentAudio.pause();
            this.currentAudio = null;
        }
        this.isPlayingResponse = false;
        this.updateVoiceChatUI('idle');
    }

    updateVoiceChatUI(state, level = 0) {
        const btn = document.getElementById('voice-chat-btn');
        if (!btn) return;

        btn.classList.remove('recording', 'playing', 'processing');

        switch (state) {
            case 'recording':
                btn.classList.add('recording');
                // Animated waveform bars
                btn.innerHTML = `
                    <div class="voice-waveform">
                        <span class="bar" style="animation-delay: 0s"></span>
                        <span class="bar" style="animation-delay: 0.1s"></span>
                        <span class="bar" style="animation-delay: 0.2s"></span>
                        <span class="bar" style="animation-delay: 0.1s"></span>
                        <span class="bar" style="animation-delay: 0s"></span>
                    </div>`;
                btn.title = 'Listening... (click to send now)';
                break;
            case 'processing':
                btn.classList.add('processing');
                btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="spin"><circle cx="12" cy="12" r="10"/><path d="M12 6v6l4 2"/></svg>`;
                btn.title = 'Processing...';
                break;
            case 'playing':
                btn.classList.add('playing');
                btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>`;
                btn.title = 'Playing... (click to interrupt)';
                break;
            default:
                btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>`;
                btn.title = 'Start voice chat';
        }
    }

    // Text-to-Speech for any message (read response aloud)
    async speakText(text) {
        try {
            // Use selected voice
            const formData = new FormData();
            formData.append('text', text.slice(0, 2000));
            formData.append('voice', this.selectedVoice || 'en-US-AvaNeural');

            const response = await fetch(`${this.apiBase}/api/voice/tts`, {
                method: 'POST',
                body: formData
            });

            if (response.ok) {
                const audioData = await response.arrayBuffer();
                await this.playAudioResponse(audioData);
            }
        } catch (err) {
            console.error('TTS error:', err);
            // Fallback to browser TTS
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                speechSynthesis.speak(utterance);
            }
        }
    }

    async speakMessage(index) {
        // Get message by index and speak it
        if (index >= 0 && index < this.messages.length) {
            const msg = this.messages[index];
            if (msg && msg.content) {
                // Stop any current playback
                this.interruptPlayback();

                // Visual feedback
                const msgEl = document.querySelector(`.message[data-index="${index}"]`);
                const speakBtn = msgEl?.querySelector('.speak-btn');
                if (speakBtn) {
                    speakBtn.textContent = 'ðŸ”‰';
                    speakBtn.classList.add('speaking');
                }

                await this.speakText(msg.content);

                // Reset button
                if (speakBtn) {
                    speakBtn.textContent = 'ðŸ”Š';
                    speakBtn.classList.remove('speaking');
                }
            }
        }
    }

    // ==========================================================================
    // File Attachments (Images + Documents)
    // ==========================================================================
    initFileInput() {
        const fileInput = document.getElementById('file-input');
        if (fileInput) {
            fileInput.addEventListener('change', (e) => this.handleFileSelect(e.target.files));
        }
    }

    getFileIcon(filename) {
        const ext = filename.split('.').pop().toLowerCase();
        const icons = {
            'pdf': 'ðŸ“•', 'doc': 'ðŸ“˜', 'docx': 'ðŸ“˜', 'pptx': 'ðŸ“™',
            'txt': 'ðŸ“„', 'md': 'ðŸ“', 'csv': 'ðŸ“Š', 'json': 'ðŸ“‹',
            'html': 'ðŸŒ', 'jpg': 'ðŸ–¼ï¸', 'jpeg': 'ðŸ–¼ï¸', 'png': 'ðŸ–¼ï¸',
            'gif': 'ðŸ–¼ï¸', 'webp': 'ðŸ–¼ï¸', 'svg': 'ðŸ–¼ï¸'
        };
        return icons[ext] || 'ðŸ“„';
    }

    isImageFile(file) {
        return file.type.startsWith('image/');
    }

    handleFileSelect(files) {
        if (!files) return;
        Array.from(files).forEach(file => {
            if (file.size > 20 * 1024 * 1024) {
                this.showNotification(`${file.name} is too large (max 20MB)`, 'error');
                return;
            }

            if (this.isImageFile(file)) {
                // Images: read as base64 for vision API
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.attachments.push({
                        type: 'image',
                        name: file.name,
                        data: e.target.result,
                        size: file.size
                    });
                    this.renderAttachments();
                };
                reader.readAsDataURL(file);
            } else {
                // Documents: upload to server for text extraction
                this.uploadDocument(file);
            }
        });
        // Reset input
        document.getElementById('file-input').value = '';
    }

    async uploadDocument(file) {
        this.showNotification(`Uploading ${file.name}...`, 'info');

        const formData = new FormData();
        formData.append('file', file);

        try {
            const response = await fetch(`${this.apiBase}/api/documents/upload`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.detail || 'Upload failed');
            }

            const result = await response.json();
            const doc = result.document;

            // Add document as attachment with extracted text reference
            this.attachments.push({
                type: 'document',
                name: file.name,
                docId: doc.id,
                size: file.size,
                textLength: doc.text_length,
                icon: this.getFileIcon(file.name)
            });
            this.renderAttachments();
            this.showNotification(`${file.name} ready for chat`, 'success');

        } catch (error) {
            console.error('Upload failed:', error);
            this.showNotification(`Failed to upload ${file.name}: ${error.message}`, 'error');
        }
    }

    renderAttachments() {
        const container = document.getElementById('attachment-previews');
        if (!container) return;

        if (this.attachments.length === 0) {
            container.style.display = 'none';
            return;
        }

        container.style.display = 'flex';
        container.innerHTML = this.attachments.map((att, i) => {
            if (att.type === 'image') {
                return `<div class="attachment-preview">
                    <img src="${att.data}" alt="${att.name}" />
                    <button class="remove-attachment" onclick="jottyApp.removeAttachment(${i})">&times;</button>
                    <span class="attachment-name">${att.name}</span>
                </div>`;
            } else {
                return `<div class="attachment-preview doc-preview">
                    <div class="doc-icon">${att.icon || 'ðŸ“„'}</div>
                    <button class="remove-attachment" onclick="jottyApp.removeAttachment(${i})">&times;</button>
                    <span class="attachment-name">${att.name}</span>
                </div>`;
            }
        }).join('');
    }

    removeAttachment(index) {
        this.attachments.splice(index, 1);
        this.renderAttachments();
    }

    // ==========================================================================
    // Agent/Swarm Mode Selector
    // ==========================================================================
    setChatMode(mode) {
        this.chatMode = mode;
        this.renderAgentSelector();
        if (mode !== 'raw' && this.agents.length === 0) {
            this.loadAgents();
        }
    }

    setSwarmMode(mode) {
        this.swarmMode = mode;
        this.renderAgentSelector();
    }

    selectAgent(agentId) {
        this.selectedAgent = agentId;
        this.renderAgentSelector();
    }

    renderAgentSelector() {
        const container = document.getElementById('agent-selector');
        if (!container) return;

        container.innerHTML = `
            <div class="mode-toggle">
                <button class="${this.chatMode === 'raw' ? 'active' : ''}" onclick="jottyApp.setChatMode('raw')">LLM</button>
                <button class="${this.chatMode === 'agent' ? 'active' : ''}" onclick="jottyApp.setChatMode('agent')">Agent</button>
                <button class="${this.chatMode === 'swarm' ? 'active' : ''}" onclick="jottyApp.setChatMode('swarm')">Swarm</button>
            </div>
            ${this.chatMode === 'agent' ? `
                <select class="agent-dropdown" onchange="jottyApp.selectAgent(this.value)">
                    <option value="">Select agent...</option>
                    ${this.agents.map(a => `
                        <option value="${a.id}" ${this.selectedAgent === a.id ? 'selected' : ''}>
                            ${a.name || a.id}
                        </option>
                    `).join('')}
                </select>
            ` : ''}
            ${this.chatMode === 'swarm' ? `
                <div class="swarm-modes">
                    <button class="${this.swarmMode === 'auto' ? 'active' : ''}" onclick="jottyApp.setSwarmMode('auto')">Auto</button>
                    <button class="${this.swarmMode === 'manual' ? 'active' : ''}" onclick="jottyApp.setSwarmMode('manual')">Manual</button>
                    <button class="${this.swarmMode === 'workflow' ? 'active' : ''}" onclick="jottyApp.setSwarmMode('workflow')">Workflow</button>
                </div>
            ` : ''}
        `;
    }

    // ==========================================================================
    // Configuration Modal
    // ==========================================================================
    showConfigModal() {
        const modal = document.getElementById('config-modal');
        if (modal) {
            modal.classList.add('open');
            this.renderConfigTabs();
        }
    }

    hideConfigModal() {
        const modal = document.getElementById('config-modal');
        if (modal) modal.classList.remove('open');
    }

    showConfigTab(tabName) {
        // Update tab buttons
        document.querySelectorAll('.config-tabs button').forEach(btn => {
            btn.classList.toggle('active', btn.textContent.toLowerCase() === tabName);
        });
        // Update tab content
        document.querySelectorAll('.config-tab-content').forEach(content => {
            content.classList.toggle('active', content.id === `config-${tabName}`);
        });
    }

    renderConfigTabs() {
        if (!this.capabilities) {
            document.getElementById('config-widgets').innerHTML = '<p style="color:var(--text-muted);">Loading capabilities...</p>';
            this.loadCapabilities().then(() => this.renderConfigTabs());
            return;
        }

        // Render widgets tab
        const widgetsHtml = this.renderWidgetConfig();
        document.getElementById('config-widgets').innerHTML = widgetsHtml;

        // Render tools tab
        const toolsHtml = this.renderToolConfig();
        document.getElementById('config-tools').innerHTML = toolsHtml;

        // Render models tab
        this.renderModelConfig();
    }

    async renderModelConfig() {
        const container = document.getElementById('config-models');
        if (!container) return;

        container.innerHTML = '<div class="config-category"><h4>Loading models...</h4></div>';

        try {
            const resp = await fetch(`${this.apiBase}/api/models`);
            if (!resp.ok) throw new Error('Failed to load models');
            const data = await resp.json();

            const models = data.models || [];
            const currentModel = data.current;

            if (models.length === 0) {
                container.innerHTML = `
                    <div class="config-category">
                        <h4>No Models Available</h4>
                        <p style="color:var(--text-muted);font-size:13px;">
                            Configure API keys to enable LLM providers:
                            <br>â€¢ ANTHROPIC_API_KEY for Claude
                            <br>â€¢ OPENAI_API_KEY for GPT-4
                            <br>â€¢ Or install Claude CLI for local access
                        </p>
                    </div>`;
                return;
            }

            // Group models by provider
            const byProvider = {};
            models.forEach(m => {
                if (!byProvider[m.provider]) {
                    byProvider[m.provider] = {
                        name: m.provider_name,
                        icon: m.provider_icon,
                        models: []
                    };
                }
                byProvider[m.provider].models.push(m);
            });

            container.innerHTML = Object.entries(byProvider).map(([providerId, provider]) => `
                <div class="config-category model-provider">
                    <h4>${provider.icon} ${provider.name}</h4>
                    <div class="config-items model-list">
                        ${provider.models.map(m => `
                            <label class="config-item model-item ${currentModel && m.model_id.includes(currentModel) ? 'active' : ''}">
                                <input type="radio" name="model" value="${m.id}"
                                       ${currentModel && m.model_id.includes(currentModel) ? 'checked' : ''}
                                       onchange="jottyApp.setModel('${providerId}', '${m.model_id}')" />
                                <span class="model-info">
                                    <span class="model-name">${m.name}</span>
                                    <span class="model-badges">
                                        ${m.recommended ? '<span class="badge recommended">â­</span>' : ''}
                                        ${m.vision ? '<span class="badge vision">ðŸ‘ï¸</span>' : ''}
                                        ${m.fast ? '<span class="badge fast">âš¡</span>' : ''}
                                        ${m.free ? '<span class="badge free">Free</span>' : ''}
                                        ${m.local ? '<span class="badge local">Local</span>' : ''}
                                        <span class="badge context">${m.context}</span>
                                    </span>
                                </span>
                            </label>
                        `).join('')}
                    </div>
                </div>
            `).join('');

        } catch (e) {
            console.error('Failed to load models:', e);
            container.innerHTML = `
                <div class="config-category">
                    <h4>Failed to Load Models</h4>
                    <p style="color:var(--error);font-size:13px;">${e.message}</p>
                </div>`;
        }
    }

    async setModel(provider, modelId) {
        try {
            this.showNotification(`Switching to ${provider}/${modelId}...`, 'info');

            const resp = await fetch(`${this.apiBase}/api/models/set`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ provider, model: modelId })
            });

            const result = await resp.json();
            if (result.success) {
                this.showNotification(`Model set to ${result.model}`, 'success');
                this.renderModelConfig();
            } else {
                throw new Error(result.error || 'Failed to set model');
            }
        } catch (e) {
            this.showNotification(`Failed: ${e.message}`, 'error');
        }
    }

    renderWidgetConfig() {
        // Handle both array and object with .available key
        const widgetData = this.capabilities.widgets || {};
        const widgets = Array.isArray(widgetData) ? widgetData : (widgetData.available || []);
        if (widgets.length === 0) {
            return '<p style="color:var(--text-muted);">No widgets available</p>';
        }

        const categories = [...new Set(widgets.map(w => w.category || 'General'))];
        return categories.map(cat => `
            <div class="config-category">
                <h4>${cat}</h4>
                <div class="config-items">
                    ${widgets.filter(w => (w.category || 'General') === cat).map(w => `
                        <label class="config-item">
                            <input type="checkbox"
                                   ${this.enabledWidgets.includes(w.value || w.name) ? 'checked' : ''}
                                   onchange="jottyApp.toggleWidget('${w.value || w.name}')" />
                            <span class="item-icon">${w.icon || 'ðŸ“¦'}</span>
                            <span class="item-label">${w.label || w.name}</span>
                        </label>
                    `).join('')}
                </div>
            </div>
        `).join('');
    }

    renderToolConfig() {
        // Handle both array and object with .available key
        const toolData = this.capabilities.tools || {};
        const tools = Array.isArray(toolData) ? toolData : (toolData.available || []);
        if (tools.length === 0) {
            return '<p style="color:var(--text-muted);">No tools available</p>';
        }

        const categories = [...new Set(tools.map(t => t.category || 'General'))];
        return categories.map(cat => `
            <div class="config-category">
                <h4>${cat}</h4>
                <div class="config-items">
                    ${tools.filter(t => (t.category || 'General') === cat).map(t => `
                        <label class="config-item">
                            <input type="checkbox"
                                   ${this.enabledTools.includes(t.name) ? 'checked' : ''}
                                   onchange="jottyApp.toggleTool('${t.name}')" />
                            <span class="item-label">${t.name}</span>
                        </label>
                    `).join('')}
                </div>
            </div>
        `).join('');
    }

    toggleWidget(value) {
        const idx = this.enabledWidgets.indexOf(value);
        if (idx >= 0) {
            this.enabledWidgets.splice(idx, 1);
        } else {
            this.enabledWidgets.push(value);
        }
        localStorage.setItem('jotty_widgets', JSON.stringify(this.enabledWidgets));
        this.updateConfigBadge();
        this.renderConfigTabs();
    }

    toggleTool(name) {
        const idx = this.enabledTools.indexOf(name);
        if (idx >= 0) {
            this.enabledTools.splice(idx, 1);
        } else {
            this.enabledTools.push(name);
        }
        localStorage.setItem('jotty_tools', JSON.stringify(this.enabledTools));
        this.updateConfigBadge();
        this.renderConfigTabs();
    }

    // ==========================================================================
    // Context Panel
    // ==========================================================================
    toggleContextPanel() {
        const panel = document.getElementById('context-panel');
        if (panel) {
            panel.classList.toggle('open');
            if (panel.classList.contains('open')) {
                this.updateContextPanel();
            }
        }
    }

    updateContextPanel() {
        const content = document.getElementById('context-panel-content');
        if (!content) return;

        const modeLabel = this.chatMode === 'raw' ? 'Direct LLM' :
                          this.chatMode === 'agent' ? 'Single Agent' : 'Multi-Agent Swarm';

        content.innerHTML = `
            <div class="context-section">
                <h4>ðŸ’¬ Conversation</h4>
                <p>Messages: ${this.messages.length}</p>
                <p>Session: ${this.sessionId || 'None'}</p>
            </div>

            <div class="context-section">
                <h4>âš¡ Execution Mode</h4>
                <p>Mode: ${modeLabel}</p>
                ${this.selectedAgent ? `<p>Agent: ${this.selectedAgent}</p>` : ''}
                ${this.chatMode === 'swarm' ? `<p>Swarm: ${this.swarmMode}</p>` : ''}
            </div>

            <div class="context-section">
                <h4>ðŸŽ›ï¸ Capabilities</h4>
                <p>Widgets: ${this.enabledWidgets.length} enabled</p>
                <p>Tools: ${this.enabledTools.length} enabled</p>
            </div>

            ${this.chatContext ? `
            <div class="context-section">
                <h4>ðŸ“„ Chat Context</h4>
                <p>Type: ${this.chatContext.type}</p>
                <p>Name: ${this.chatContext.name}</p>
            </div>
            ` : ''}

            <div class="context-section">
                <h4>ðŸŽ¨ Theme</h4>
                <button onclick="jottyApp.toggleTheme()">
                    ${this.theme === 'dark' ? 'â˜€ï¸ Switch to Light' : 'ðŸŒ™ Switch to Dark'}
                </button>
            </div>
        `;
    }

}
document.addEventListener('DOMContentLoaded', () => { window.jottyApp = new JottyApp(); });
    </script>
    <!-- AG-UI Protocol Client (CopilotKit compatible) -->
    <script src="/static/agui-client.js"></script>
</body>
</html>
