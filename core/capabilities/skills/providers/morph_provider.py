"""
Morph App-Builder Provider for Jotty V2
=======================================

**NOTE: Requires Morph Cloud credentials to run apps.**
For a fully open-source alternative, use StreamlitProvider instead.

Integrates the Morph framework for building AI apps with Python + MDX.
https://github.com/morph-data/morph

Capabilities:
- Create new Morph projects
- Generate Python workflows with @morph.func decorators
- Generate MDX pages with components
- Start/stop development server (requires cloud credentials)
- Deploy to Morph cloud

Requirements:
- morph-data package
- Morph cloud account and credentials (morph init)
- npm/node for frontend components
"""

import asyncio
import logging
import os
import subprocess
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Dict, List, Optional

from .base import ProviderCapability, ProviderResult, SkillCategory, SkillProvider

logger = logging.getLogger(__name__)

# Check if morph-data is available
try:
    import morph

    MORPH_AVAILABLE = True
except ImportError:
    MORPH_AVAILABLE = False
    morph = None


# =============================================================================
# Templates for Code Generation
# =============================================================================

WORKFLOW_TEMPLATE = '''"""
{description}

Auto-generated by Jotty V2 Swarm using Morph framework.
"""
import morph
from morph import MorphGlobalContext
{imports}


@morph.func
def {name}(context: MorphGlobalContext{params}):
    """
    {docstring}

    Args:
        context: Morph global context with request data
{param_docs}
    Returns:
        {return_doc}
    """
{body}
'''

PAGE_TEMPLATE = """---
title: {title}
description: {description}
---

# {title}

{content}

{components}
"""

COMPONENT_TEMPLATES = {
    "chat": '<Chat postData="{workflow}" height={{300}} />',
    "form": '<Form postData="{workflow}" />',
    "table": '<DataTable postData="{workflow}" />',
    "chart": '<Chart postData="{workflow}" type="{chart_type}" />',
    "input": '<Input name="{name}" label="{label}" />',
    "button": '<Button onClick={{() => run("{workflow}")}}>{{children}}</Button>',
    "markdown": "<Markdown>{content}</Markdown>",
}

DEFAULT_PROJECT_STRUCTURE = {
    "src": [],  # Morph source directory
    "src/python": [],  # Python workflows
    "src/pages": [],  # MDX pages
    "morph_project.yml": None,  # Required config
}

MORPH_PROJECT_YML_TEMPLATE = """version: '1'

# Framework Settings
default_connection: morph-duckdb
source_paths:
- src

# Cloud Settings
# profile: default
# project_id: null

# Build Settings
build:
    runtime: python3.11
    framework: morph
    package_manager: pip

# Deployment Settings
deployment:
    provider: aws
"""


@dataclass
class MorphProject:
    """Represents a Morph project."""

    name: str
    path: Path
    workflows: List[str] = field(default_factory=list)
    pages: List[str] = field(default_factory=list)
    server_process: Optional[subprocess.Popen] = None
    server_port: int = 8080

    def is_running(self) -> bool:
        """Check if server is running."""
        return self.server_process is not None and self.server_process.poll() is None


class MorphProvider(SkillProvider):
    """
    Provider for building AI apps using Morph framework.

    **IMPORTANT: Requires Morph Cloud credentials.**
    For fully open-source local-only apps, use StreamlitProvider instead.

    Morph enables building full-stack AI apps with:
    - Python workflows using @morph.func decorators
    - MDX pages with pre-built components
    - Built-in streaming support
    - Deployment to Morph cloud

    Requirements:
    - Run `morph init` to configure cloud credentials
    - npm/node installed for frontend

    Usage:
        provider = MorphProvider()
        await provider.initialize()

        # Create a new app
        result = await provider.execute("Build a stock analysis dashboard")

        # Or use specific methods
        result = await provider.create_project("my_app")
        result = await provider.generate_workflow("analyze_stock", {...})
        result = await provider.serve()  # Requires cloud credentials!
    """

    name = "morph"
    version = "1.0.0"
    description = "Build AI apps with Morph (requires cloud credentials)"

    def __init__(self, config: Dict[str, Any] = None) -> None:
        """
        Initialize MorphProvider.

        Args:
            config: Provider configuration
                - workspace_dir: Directory for Morph projects (default: ./morph_apps)
                - api_key: Optional Morph API key for cloud deployment
                - workspace_id: Optional Morph workspace ID
                - default_port: Default dev server port (default: 8080)
        """
        super().__init__(config)

        self.capabilities = [
            ProviderCapability(
                category=SkillCategory.APP_BUILDING,
                actions=["create_project", "generate_workflow", "generate_page", "serve", "deploy"],
                max_concurrent=1,
                requires_network=True,
                estimated_latency_ms=5000,
            ),
        ]

        # Configuration
        self.workspace_dir = (
            Path(config.get("workspace_dir", "./morph_apps")) if config else Path("./morph_apps")
        )
        self.api_key = (
            config.get("api_key", os.getenv("MORPH_API_KEY"))
            if config
            else os.getenv("MORPH_API_KEY")
        )
        self.workspace_id = (
            config.get("workspace_id", os.getenv("MORPH_WORKSPACE_ID"))
            if config
            else os.getenv("MORPH_WORKSPACE_ID")
        )
        self.default_port = config.get("default_port", 8080) if config else 8080

        # Active projects
        self._projects: Dict[str, MorphProject] = {}
        self._current_project: Optional[MorphProject] = None

        # CLI availability
        self._cli_available = False

    async def initialize(self) -> bool:
        """
        Initialize Morph provider.

        Checks for morph-data installation and CLI availability.
        Auto-installs if not present.

        Returns:
            True if initialization successful
        """
        try:
            # Check if morph-data is installed
            if not MORPH_AVAILABLE:
                logger.info("morph-data not found, attempting to install...")
                install_result = await self._install_morph()
                if not install_result:
                    logger.warning("Could not install morph-data. Some features may be limited.")

            # Check CLI availability
            self._cli_available = await self._check_cli()

            # Create workspace directory
            self.workspace_dir.mkdir(parents=True, exist_ok=True)

            self.is_initialized = True
            self.is_available = True

            status = "with CLI" if self._cli_available else "without CLI"
            logger.info(f"Morph provider initialized ({status})")
            return True

        except Exception as e:
            logger.error(f"Failed to initialize Morph provider: {e}")
            self.is_initialized = True
            self.is_available = False
            return False

    async def _install_morph(self) -> bool:
        """Install morph-data package."""
        try:
            process = await asyncio.create_subprocess_exec(
                "pip",
                "install",
                "morph-data",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )
            stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=120)

            if process.returncode == 0:
                logger.info("Successfully installed morph-data")
                return True
            else:
                logger.warning(f"Failed to install morph-data: {stderr.decode()}")
                return False

        except asyncio.TimeoutError:
            logger.warning("morph-data installation timed out")
            return False
        except Exception as e:
            logger.warning(f"Could not install morph-data: {e}")
            return False

    async def _check_cli(self) -> bool:
        """Check if morph CLI is available."""
        try:
            process = await asyncio.create_subprocess_exec(
                "morph", "--version", stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
            )
            await asyncio.wait_for(process.communicate(), timeout=10)
            return process.returncode == 0
        except Exception:
            return False

    def get_categories(self) -> List[SkillCategory]:
        """Get supported skill categories."""
        return [SkillCategory.APP_BUILDING]

    async def execute(self, task: str, context: Dict[str, Any] = None) -> ProviderResult:
        """
        Execute a Morph-related task.

        Routes task to appropriate handler based on keywords.

        Args:
            task: Natural language task description
            context: Additional context (project name, specs, etc.)

        Returns:
            ProviderResult with execution output
        """
        start_time = time.time()
        context = context or {}
        task_lower = task.lower()

        try:
            # Route to appropriate handler
            if any(
                kw in task_lower for kw in ["new", "create", "build", "start project", "make app"]
            ):
                result = await self._create_full_app(task, context)
            elif any(kw in task_lower for kw in ["workflow", "function", "backend", "api"]):
                result = await self._generate_workflow_from_task(task, context)
            elif any(
                kw in task_lower for kw in ["page", "ui", "frontend", "interface", "component"]
            ):
                result = await self._generate_page_from_task(task, context)
            elif any(kw in task_lower for kw in ["serve", "run", "start server", "launch"]):
                result = await self._serve(context)
            elif any(kw in task_lower for kw in ["stop", "shutdown", "kill server"]):
                result = await self._stop_server(context)
            elif any(kw in task_lower for kw in ["deploy", "publish", "cloud"]):
                result = await self._deploy(context)
            else:
                # Default: create full app
                result = await self._create_full_app(task, context)

            result.execution_time = time.time() - start_time
            result.provider_name = self.name
            self.record_execution(result)
            return result

        except Exception as e:
            logger.error(f"Morph provider error: {e}")
            result = ProviderResult(
                success=False,
                output=None,
                error=str(e),
                execution_time=time.time() - start_time,
                provider_name=self.name,
                retryable=True,
            )
            self.record_execution(result)
            return result

    async def _create_full_app(self, task: str, context: Dict[str, Any]) -> ProviderResult:
        """
        Create a complete Morph app from a task description.

        This is the main entry point for app creation.
        """
        # Extract project name from task or context
        project_name = context.get("project_name") or self._extract_project_name(task)

        # Create project structure
        project_result = await self.create_project(project_name)
        if not project_result.success:
            return project_result

        project = self._current_project

        # Analyze task to determine what to build
        app_spec = self._analyze_task_for_app(task)

        # Generate workflows
        for workflow_spec in app_spec.get("workflows", []):
            workflow_result = await self.generate_workflow(
                workflow_name=workflow_spec["name"],
                workflow_spec=workflow_spec,
            )
            if workflow_result.success:
                project.workflows.append(workflow_spec["name"])

        # Generate pages
        for page_spec in app_spec.get("pages", []):
            page_result = await self.generate_page(
                page_name=page_spec["name"],
                workflows=page_spec.get("workflows", project.workflows),
                components=page_spec.get("components", []),
                title=page_spec.get("title", project_name),
            )
            if page_result.success:
                project.pages.append(page_spec["name"])

        # Start server if requested
        auto_serve = context.get("auto_serve", True)
        if auto_serve:
            serve_result = await self._serve(context)
            if not serve_result.success:
                logger.warning(f"Could not start server: {serve_result.error}")

        return ProviderResult(
            success=True,
            output={
                "project_name": project_name,
                "project_path": str(project.path),
                "workflows": project.workflows,
                "pages": project.pages,
                "server_running": project.is_running(),
                "server_url": (
                    f"http://localhost:{project.server_port}" if project.is_running() else None
                ),
                "message": f"Created Morph app '{project_name}' at {project.path}",
            },
            category=SkillCategory.APP_BUILDING,
            metadata={"task": task},
        )

    def _extract_project_name(self, task: str) -> str:
        """Extract project name from task description."""
        import re

        # Look for quoted names
        quoted = re.search(r'["\']([^"\']+)["\']', task)
        if quoted:
            return quoted.group(1).lower().replace(" ", "_")

        # Look for "called X" or "named X"
        named = re.search(r"(?:called|named)\s+(\w+)", task, re.IGNORECASE)
        if named:
            return named.group(1).lower()

        # Extract key nouns
        words = task.lower().split()
        keywords = ["app", "dashboard", "chat", "analyzer", "tool", "interface"]
        for i, word in enumerate(words):
            if word in keywords and i > 0:
                return f"{words[i-1]}_{word}"

        # Default name
        return "morph_app"

    def _analyze_task_for_app(self, task: str) -> Dict[str, Any]:
        """
        Analyze task description to determine app structure.

        Returns spec with workflows and pages to generate.
        """
        task_lower = task.lower()

        # Default spec
        spec = {
            "workflows": [],
            "pages": [{"name": "index", "title": "Home", "components": []}],
        }

        # Detect app type and add appropriate workflows/components
        if any(kw in task_lower for kw in ["chat", "conversation", "assistant", "chatbot"]):
            spec["workflows"].append(
                {
                    "name": "chat",
                    "description": "Chat workflow for conversational AI",
                    "streaming": True,
                    "type": "chat",
                }
            )
            spec["pages"][0]["components"].append(
                {
                    "type": "chat",
                    "workflow": "chat",
                }
            )

        if any(kw in task_lower for kw in ["stock", "finance", "trading", "market"]):
            spec["workflows"].append(
                {
                    "name": "analyze_stock",
                    "description": "Analyze stock data and provide insights",
                    "streaming": True,
                    "type": "analysis",
                    "params": ["ticker", "period"],
                }
            )
            spec["pages"][0]["components"].extend(
                [
                    {"type": "input", "name": "ticker", "label": "Stock Ticker"},
                    {"type": "chart", "workflow": "analyze_stock", "chart_type": "line"},
                ]
            )

        if any(kw in task_lower for kw in ["dashboard", "analytics", "metrics", "visualization"]):
            spec["workflows"].append(
                {
                    "name": "get_metrics",
                    "description": "Get dashboard metrics and data",
                    "streaming": False,
                    "type": "data",
                }
            )
            spec["pages"][0]["components"].extend(
                [
                    {"type": "chart", "workflow": "get_metrics", "chart_type": "bar"},
                    {"type": "table", "workflow": "get_metrics"},
                ]
            )

        if any(kw in task_lower for kw in ["form", "input", "submit", "data entry"]):
            spec["workflows"].append(
                {
                    "name": "process_form",
                    "description": "Process form submission",
                    "streaming": False,
                    "type": "form",
                }
            )
            spec["pages"][0]["components"].append(
                {
                    "type": "form",
                    "workflow": "process_form",
                }
            )

        # Default: add a basic chat if nothing detected
        if not spec["workflows"]:
            spec["workflows"].append(
                {
                    "name": "main",
                    "description": "Main workflow",
                    "streaming": True,
                    "type": "chat",
                }
            )
            spec["pages"][0]["components"].append(
                {
                    "type": "chat",
                    "workflow": "main",
                }
            )

        return spec

    async def create_project(self, name: str, path: Path = None) -> ProviderResult:
        """
        Create a new Morph project.

        Args:
            name: Project name
            path: Optional custom path (default: workspace_dir/name)

        Returns:
            ProviderResult with project info
        """
        project_path = path or (self.workspace_dir / name)

        try:
            # Create directory structure (Morph expects src/python and src/pages)
            project_path.mkdir(parents=True, exist_ok=True)
            (project_path / "src").mkdir(exist_ok=True)
            (project_path / "src" / "python").mkdir(exist_ok=True)
            (project_path / "src" / "pages").mkdir(exist_ok=True)

            # Create morph_project.yml (required by Morph CLI)
            project_yml = project_path / "morph_project.yml"
            project_yml.write_text(MORPH_PROJECT_YML_TEMPLATE)

            # Create project object
            project = MorphProject(
                name=name,
                path=project_path,
                server_port=self._find_available_port(),
            )

            # Register project
            self._projects[name] = project
            self._current_project = project

            logger.info(f"Created Morph project: {name} at {project_path}")

            return ProviderResult(
                success=True,
                output={
                    "name": name,
                    "path": str(project_path),
                    "structure": list(DEFAULT_PROJECT_STRUCTURE.keys()),
                },
                category=SkillCategory.APP_BUILDING,
            )

        except Exception as e:
            return ProviderResult(
                success=False,
                output=None,
                error=f"Failed to create project: {e}",
                category=SkillCategory.APP_BUILDING,
            )

    async def generate_workflow(
        self,
        workflow_name: str,
        workflow_spec: Dict[str, Any],
        project: MorphProject = None,
    ) -> ProviderResult:
        """
        Generate a Python workflow file for Morph.

        Args:
            workflow_name: Name of the workflow function
            workflow_spec: Workflow specification
                - description: What the workflow does
                - streaming: Whether to use streaming (default: True)
                - type: Workflow type (chat, analysis, data, form)
                - params: Additional parameters
            project: Target project (default: current project)

        Returns:
            ProviderResult with generated code
        """
        project = project or self._current_project
        if not project:
            return ProviderResult(
                success=False,
                output=None,
                error="No active project. Create a project first.",
            )

        try:
            # Build workflow code
            workflow_type = workflow_spec.get("type", "chat")
            streaming = workflow_spec.get("streaming", True)
            description = workflow_spec.get("description", f"{workflow_name} workflow")
            params = workflow_spec.get("params", [])

            # Generate imports based on type
            imports = self._generate_workflow_imports(workflow_type)

            # Generate body based on type
            body = self._generate_workflow_body(workflow_type, workflow_name, streaming)

            # Generate parameter annotations
            param_str = ""
            param_docs = ""
            if params:
                param_annotations = [f"{p}: str = None" for p in params]
                param_str = ", " + ", ".join(param_annotations)
                param_docs = "\n".join([f"        {p}: Parameter description" for p in params])

            # Apply template
            return_doc = "Streamed response chunks" if streaming else "Result dictionary"

            code = WORKFLOW_TEMPLATE.format(
                name=workflow_name,
                description=description,
                imports=imports,
                params=param_str,
                docstring=description,
                param_docs=param_docs or "        None",
                return_doc=return_doc,
                body=body,
            )

            # Write to file (Morph expects src/python/)
            workflow_file = project.path / "src" / "python" / f"{workflow_name}.py"
            workflow_file.write_text(code)

            logger.info(f"Generated workflow: {workflow_name}")

            return ProviderResult(
                success=True,
                output={
                    "workflow_name": workflow_name,
                    "file_path": str(workflow_file),
                    "code": code,
                    "streaming": streaming,
                },
                category=SkillCategory.APP_BUILDING,
            )

        except Exception as e:
            return ProviderResult(
                success=False,
                output=None,
                error=f"Failed to generate workflow: {e}",
            )

    def _generate_workflow_imports(self, workflow_type: str) -> str:
        """Generate import statements based on workflow type."""
        imports = []

        if workflow_type == "chat":
            imports.append("from morph_lib.stream import stream_chat")
        elif workflow_type == "analysis":
            imports.extend(
                [
                    "import json",
                    "import pandas as pd",
                    "from typing import Dict, Any",
                ]
            )
        elif workflow_type == "data":
            imports.extend(
                [
                    "import json",
                    "from typing import Dict, Any, List",
                ]
            )

        return "\n".join(imports)

    def _generate_workflow_body(self, workflow_type: str, name: str, streaming: bool) -> str:
        """Generate workflow body based on type."""
        indent = "    "

        if workflow_type == "chat":
            if streaming:
                return f"""{indent}# Get user message from context
{indent}user_message = context.vars.get("message", "Hello")
{indent}
{indent}# Stream chat response
{indent}# Task List: Integrate with your LLM (e.g., OpenAI, Anthropic)
{indent}# Example with simple response:
{indent}response = f"You said: {{user_message}}"
{indent}for word in response.split():
{indent}    yield stream_chat(word + " ")"""
            else:
                return f"""{indent}# Get user message from context
{indent}user_message = context.vars.get("message", "Hello")
{indent}
{indent}# Return response
{indent}return {{"response": f"Received: {{user_message}}"}}"""

        elif workflow_type == "analysis":
            if streaming:
                return f"""{indent}# Get parameters from context
{indent}ticker = context.vars.get("ticker", "AAPL")
{indent}period = context.vars.get("period", "1mo")
{indent}
{indent}# Task List: Implement actual analysis
{indent}# Example: Use yfinance, pandas, etc.
{indent}
{indent}result = {{
{indent}    "ticker": ticker,
{indent}    "period": period,
{indent}    "analysis": "Analysis placeholder",
{indent}    "data": [],
{indent}}}
{indent}
{indent}yield json.dumps(result)"""
            else:
                return f"""{indent}# Get parameters from context
{indent}ticker = context.vars.get("ticker", "AAPL")
{indent}period = context.vars.get("period", "1mo")
{indent}
{indent}# Task List: Implement actual analysis
{indent}# Example: Use yfinance, pandas, etc.
{indent}
{indent}result = {{
{indent}    "ticker": ticker,
{indent}    "period": period,
{indent}    "analysis": "Analysis placeholder",
{indent}    "data": [],
{indent}}}
{indent}
{indent}return result"""

        elif workflow_type == "data":
            return f"""{indent}# Get data based on context
{indent}
{indent}# Task List: Implement data fetching
{indent}data = {{
{indent}    "metrics": [],
{indent}    "charts": [],
{indent}}}
{indent}
{indent}return data"""

        elif workflow_type == "form":
            return f"""{indent}# Get form data from context
{indent}form_data = context.vars
{indent}
{indent}# Task List: Process form submission
{indent}
{indent}return {{"success": True, "message": "Form submitted", "data": form_data}}"""

        else:
            return f"""{indent}# Default workflow implementation
{indent}return {{"message": "Workflow executed successfully"}}"""

    async def generate_page(
        self,
        page_name: str,
        workflows: List[str],
        components: List[Dict[str, Any]],
        title: str = None,
        description: str = None,
        project: MorphProject = None,
    ) -> ProviderResult:
        """
        Generate an MDX page for Morph.

        Args:
            page_name: Name of the page file (without extension)
            workflows: List of workflow names to connect
            components: List of component specs
                - type: Component type (chat, form, table, chart, etc.)
                - workflow: Workflow to connect
                - Additional type-specific options
            title: Page title
            description: Page description
            project: Target project (default: current project)

        Returns:
            ProviderResult with generated MDX
        """
        project = project or self._current_project
        if not project:
            return ProviderResult(
                success=False,
                output=None,
                error="No active project. Create a project first.",
            )

        try:
            title = title or page_name.title()
            description = description or f"{title} page"

            # Generate component MDX
            component_mdx = []
            for comp in components:
                comp_type = comp.get("type", "chat")
                template = COMPONENT_TEMPLATES.get(comp_type, "")

                if template:
                    # Fill in template
                    filled = template.format(
                        workflow=comp.get("workflow", workflows[0] if workflows else "main"),
                        chart_type=comp.get("chart_type", "line"),
                        name=comp.get("name", "input"),
                        label=comp.get("label", "Input"),
                        content=comp.get("content", ""),
                        children=comp.get("children", "Click"),
                    )
                    component_mdx.append(filled)

            # Build content based on components
            content = self._generate_page_content(title, components)

            # Apply template
            mdx = PAGE_TEMPLATE.format(
                title=title,
                description=description,
                content=content,
                components="\n\n".join(component_mdx),
            )

            # Write to file (Morph expects src/pages/)
            page_file = project.path / "src" / "pages" / f"{page_name}.mdx"
            page_file.write_text(mdx)

            logger.info(f"Generated page: {page_name}")

            return ProviderResult(
                success=True,
                output={
                    "page_name": page_name,
                    "file_path": str(page_file),
                    "mdx": mdx,
                    "workflows": workflows,
                    "components": [c.get("type") for c in components],
                },
                category=SkillCategory.APP_BUILDING,
            )

        except Exception as e:
            return ProviderResult(
                success=False,
                output=None,
                error=f"Failed to generate page: {e}",
            )

    def _generate_page_content(self, title: str, components: List[Dict[str, Any]]) -> str:
        """Generate page content description based on components."""
        content_parts = []

        has_chat = any(c.get("type") == "chat" for c in components)
        has_chart = any(c.get("type") == "chart" for c in components)
        has_form = any(c.get("type") == "form" for c in components)
        has_table = any(c.get("type") == "table" for c in components)

        if has_chat:
            content_parts.append("Start a conversation below:")
        if has_form:
            content_parts.append("Fill in the form to get started:")
        if has_chart or has_table:
            content_parts.append("View your data and insights:")

        return "\n\n".join(content_parts) if content_parts else f"Welcome to {title}!"

    async def _serve(self, context: Dict[str, Any] = None) -> ProviderResult:
        """Start the Morph development server."""
        project = self._current_project
        if not project:
            return ProviderResult(
                success=False,
                output=None,
                error="No active project to serve.",
            )

        if project.is_running():
            return ProviderResult(
                success=True,
                output={
                    "message": "Server already running",
                    "url": f"http://localhost:{project.server_port}",
                },
                category=SkillCategory.APP_BUILDING,
            )

        try:
            # Find available port
            port = self._find_available_port(project.server_port)
            project.server_port = port

            # Start server
            if self._cli_available:
                project.server_process = subprocess.Popen(
                    ["morph", "serve", "--port", str(port)],
                    cwd=str(project.path),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                )
            else:
                # Fallback: try python -m morph
                project.server_process = subprocess.Popen(
                    ["python", "-m", "morph", "serve", "--port", str(port)],
                    cwd=str(project.path),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                )

            # Wait a bit for server to start
            await asyncio.sleep(2)

            if project.is_running():
                logger.info(f"Morph server started at http://localhost:{port}")
                return ProviderResult(
                    success=True,
                    output={
                        "message": "Server started",
                        "url": f"http://localhost:{port}",
                        "project": project.name,
                    },
                    category=SkillCategory.APP_BUILDING,
                )
            else:
                stdout, stderr = project.server_process.communicate(timeout=5)
                error_msg = stderr.decode() if stderr else "Unknown error"
                return ProviderResult(
                    success=False,
                    output=None,
                    error=f"Server failed to start: {error_msg}",
                )

        except Exception as e:
            return ProviderResult(
                success=False,
                output=None,
                error=f"Failed to start server: {e}",
            )

    async def _stop_server(self, context: Dict[str, Any] = None) -> ProviderResult:
        """Stop the Morph development server."""
        project = self._current_project
        if not project or not project.is_running():
            return ProviderResult(
                success=True,
                output={"message": "No server running"},
                category=SkillCategory.APP_BUILDING,
            )

        try:
            project.server_process.terminate()
            project.server_process.wait(timeout=5)
            project.server_process = None

            logger.info("Morph server stopped")

            return ProviderResult(
                success=True,
                output={"message": "Server stopped"},
                category=SkillCategory.APP_BUILDING,
            )

        except Exception as e:
            return ProviderResult(
                success=False,
                output=None,
                error=f"Failed to stop server: {e}",
            )

    async def _deploy(self, context: Dict[str, Any] = None) -> ProviderResult:
        """Deploy to Morph cloud."""
        if not self.api_key:
            return ProviderResult(
                success=False,
                output=None,
                error="MORPH_API_KEY not configured. Set environment variable or provide in config.",
            )

        project = self._current_project
        if not project:
            return ProviderResult(
                success=False,
                output=None,
                error="No active project to deploy.",
            )

        try:
            if self._cli_available:
                process = await asyncio.create_subprocess_exec(
                    "morph",
                    "deploy",
                    cwd=str(project.path),
                    env={**os.environ, "MORPH_API_KEY": self.api_key},
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE,
                )
                stdout, stderr = await asyncio.wait_for(process.communicate(), timeout=120)

                if process.returncode == 0:
                    return ProviderResult(
                        success=True,
                        output={
                            "message": "Deployed successfully",
                            "output": stdout.decode(),
                        },
                        category=SkillCategory.APP_BUILDING,
                    )
                else:
                    return ProviderResult(
                        success=False,
                        output=None,
                        error=f"Deploy failed: {stderr.decode()}",
                    )
            else:
                return ProviderResult(
                    success=False,
                    output=None,
                    error="Morph CLI not available for deployment.",
                )

        except asyncio.TimeoutError:
            return ProviderResult(
                success=False,
                output=None,
                error="Deployment timed out.",
            )
        except Exception as e:
            return ProviderResult(
                success=False,
                output=None,
                error=f"Deploy failed: {e}",
            )

    async def _generate_workflow_from_task(
        self, task: str, context: Dict[str, Any]
    ) -> ProviderResult:
        """Generate workflow from natural language task."""
        # Extract workflow name
        import re

        name_match = re.search(
            r'(?:workflow|function|api)\s+(?:called|named)?\s*["\']?(\w+)', task, re.IGNORECASE
        )
        workflow_name = name_match.group(1) if name_match else "workflow"

        # Determine type from task
        task_lower = task.lower()
        if "chat" in task_lower:
            workflow_type = "chat"
        elif "analyz" in task_lower or "data" in task_lower:
            workflow_type = "analysis"
        elif "form" in task_lower:
            workflow_type = "form"
        else:
            workflow_type = "chat"

        spec = {
            "name": workflow_name,
            "description": task,
            "streaming": "stream" in task_lower or workflow_type == "chat",
            "type": workflow_type,
        }

        return await self.generate_workflow(workflow_name, spec)

    async def _generate_page_from_task(self, task: str, context: Dict[str, Any]) -> ProviderResult:
        """Generate page from natural language task."""
        import re

        # Extract page name
        name_match = re.search(
            r'(?:page|ui|interface)\s+(?:called|named)?\s*["\']?(\w+)', task, re.IGNORECASE
        )
        page_name = name_match.group(1) if name_match else "page"

        # Determine components from task
        task_lower = task.lower()
        components = []

        if "chat" in task_lower:
            components.append({"type": "chat", "workflow": "chat"})
        if "form" in task_lower:
            components.append({"type": "form", "workflow": "form"})
        if "chart" in task_lower or "graph" in task_lower:
            components.append({"type": "chart", "workflow": "data", "chart_type": "line"})
        if "table" in task_lower:
            components.append({"type": "table", "workflow": "data"})

        if not components:
            components.append({"type": "chat", "workflow": "main"})

        workflows = list(set(c.get("workflow", "main") for c in components))

        return await self.generate_page(
            page_name=page_name,
            workflows=workflows,
            components=components,
            title=page_name.replace("_", " ").title(),
        )

    def _find_available_port(self, start_port: int = None) -> int:
        """Find an available port starting from start_port."""
        import socket

        port = start_port or self.default_port
        max_attempts = 100

        for _ in range(max_attempts):
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.bind(("localhost", port))
                    return port
            except OSError:
                port += 1

        return port

    async def health_check(self) -> bool:
        """Check if provider is healthy."""
        return self.is_available and self.is_initialized

    def get_project(self, name: str) -> Optional[MorphProject]:
        """Get a project by name."""
        return self._projects.get(name)

    def list_projects(self) -> List[str]:
        """List all known projects."""
        return list(self._projects.keys())

    async def cleanup(self) -> Any:
        """Clean up resources (stop servers, etc.)."""
        for project in self._projects.values():
            if project.is_running():
                try:
                    project.server_process.terminate()
                    project.server_process.wait(timeout=5)
                except Exception:
                    pass

        self._projects.clear()
        self._current_project = None


# Factory function for registration
def create_provider(config: Dict[str, Any] = None) -> MorphProvider:
    """Create and return a MorphProvider instance."""
    return MorphProvider(config)
