"""
Skills Registry - DRY Implementation for Jotty Framework

Skills are dynamically loaded tools that extend agent capabilities.
This is framework-level infrastructure, reusable across all Jotty clients.

Architecture:
- Skills live in ~/jotty/skills/<name>/SKILL.md and tools.py
- Skills registry loads and registers tools dynamically
- Skills can be GENERATED by AI (like Clawd.bot) or manually written
- Tools integrate with existing Jotty tool system (no duplication)
- Clients (like JustJot.ai) use Jotty's skills system

Key Features:
- Load existing skills from disk
- Generate new skills using AI (via SkillGenerator)
- Hot-reload skills on changes
- Validate skills before registration

Note: This is framework code, not client-specific.
"""

import os
import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
import importlib.util

# Load environment variables from .env file
try:
    from dotenv import load_dotenv
    # Load .env from Jotty root directory
    current_file = Path(__file__).resolve()
    jotty_root = current_file.parent.parent.parent  # core/registry -> core -> Jotty
    env_file = jotty_root / ".env"
    if env_file.exists():
        load_dotenv(env_file, override=False)  # Don't override existing env vars
except ImportError:
    pass  # python-dotenv not available, fall back to os.getenv

logger = logging.getLogger(__name__)


# =============================================================================
# BASE SKILL CLASS
# =============================================================================

class BaseSkill:
    """
    Base class for all Jotty skills.

    Skills extend this class to gain:
    - Status callback support for progress reporting
    - Lifecycle hooks (setup, execute, cleanup)
    - Consistent interface across all skills
    - Context sharing (session, user, metadata)

    Usage:
        class ResearchSkill(BaseSkill):
            name = "research-to-pdf"
            description = "Research topics and create PDF reports"

            def setup(self):
                # Initialize resources
                pass

            async def execute(self, params: dict) -> dict:
                self.status("Searching", "ðŸ” Searching the web...")
                results = await self.search(params['query'])

                self.status("Analyzing", "ðŸ§  Analyzing results...")
                analysis = self.analyze(results)

                self.status("Creating", "ðŸ“„ Creating PDF...")
                pdf_path = self.create_pdf(analysis)

                return {"success": True, "pdf_path": pdf_path}

    The status() method emits progress updates that flow to the CLI/UI.
    """

    # Class attributes - override in subclasses
    name: str = "base-skill"
    description: str = "Base skill class"
    version: str = "1.0.0"
    category: str = "general"
    tags: List[str] = []

    def __init__(self, status_callback: Optional[Callable] = None):
        """
        Initialize skill with optional status callback.

        Args:
            status_callback: Callable(stage, detail) for progress updates
        """
        self._status_callback = status_callback
        self._context: Dict[str, Any] = {}

    def set_status_callback(self, callback: Callable):
        """Set status callback for progress reporting."""
        self._status_callback = callback

    def set_context(self, **context):
        """Set execution context (session_id, user_id, metadata, etc.)."""
        self._context.update(context)

    def status(self, stage: str, detail: str = ""):
        """
        Emit a status update for progress reporting.

        Args:
            stage: Stage name (e.g., "Searching", "Analyzing")
            detail: Detail message with emoji (e.g., "ðŸ” Searching web...")
        """
        if self._status_callback:
            try:
                self._status_callback(stage, detail)
            except Exception:
                pass
        logger.debug(f"[{self.name}] {stage}: {detail}")

    def setup(self):
        """
        Setup hook called before execution.
        Override in subclasses for initialization.
        """
        pass

    def cleanup(self):
        """
        Cleanup hook called after execution.
        Override in subclasses for resource cleanup.
        """
        pass

    async def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the skill with given parameters.

        Override in subclasses to implement skill logic.

        Args:
            params: Skill parameters

        Returns:
            Result dict with 'success' key
        """
        raise NotImplementedError("Subclasses must implement execute()")

    def get_tools(self) -> Dict[str, Callable]:
        """
        Get tool functions for this skill.

        Returns dict mapping tool names to callables.
        Default implementation wraps execute() as the main tool.
        Override for skills with multiple tools.
        """
        async def main_tool(params: dict) -> dict:
            self.setup()
            try:
                return await self.execute(params)
            finally:
                self.cleanup()

        return {f"{self.name}_tool": main_tool}

    def to_definition(self) -> "SkillDefinition":
        """Convert to SkillDefinition for registry compatibility."""
        return SkillDefinition(
            name=self.name,
            description=self.description,
            tools=self.get_tools(),
            category=self.category,
            tags=self.tags,
            version=self.version,
        )


# =============================================================================
# TOOL METADATA (Absorbed from ToolsRegistry)
# =============================================================================

@dataclass
class ToolMetadata:
    """
    Metadata for a tool within a skill.

    This consolidates ToolSchema from the old ToolsRegistry into SkillsRegistry,
    providing rich metadata for each tool including MCP support, parameters, etc.

    The SkillsRegistry is now the single source of truth for tools.
    """
    name: str  # Tool name within the skill
    description: str  # What this tool does
    category: str = "general"  # Category grouping
    mcp_enabled: bool = False  # Available via MCP protocol
    parameters: Dict[str, Any] = field(default_factory=dict)  # Parameter schema (JSON Schema)
    returns: Optional[str] = None  # Return type description
    examples: List[Dict[str, Any]] = field(default_factory=list)  # Usage examples
    tags: List[str] = field(default_factory=list)  # Searchable tags

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API responses."""
        return {
            'name': self.name,
            'description': self.description,
            'category': self.category,
            'mcp_enabled': self.mcp_enabled,
            'parameters': self.parameters,
            'returns': self.returns,
            'examples': self.examples,
            'tags': self.tags,
        }

    def to_claude_tool(self) -> Dict[str, Any]:
        """Convert to Claude API tool format."""
        return {
            'name': self.name,
            'description': self.description,
            'input_schema': {
                'type': 'object',
                'properties': self.parameters.get('properties', {}),
                'required': self.parameters.get('required', []),
            }
        }


# =============================================================================
# SKILL DEFINITION (Enhanced with Tool Metadata)
# =============================================================================

class SkillDefinition:
    """
    Definition of a skill with its tools (supports lazy loading).

    Skills are the "Hands" of the Jotty system - they represent what the
    swarm can DO. Each skill contains multiple tools with rich metadata.

    Architecture:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                       SKILL DEFINITION (Hands)                       â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  â”‚                          Tools                                   â”‚ â”‚
    â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚ â”‚
    â”‚  â”‚  â”‚   tool_1    â”‚  â”‚   tool_2    â”‚  â”‚   tool_N    â”‚             â”‚ â”‚
    â”‚  â”‚  â”‚  callable   â”‚  â”‚  callable   â”‚  â”‚  callable   â”‚             â”‚ â”‚
    â”‚  â”‚  â”‚  metadata   â”‚  â”‚  metadata   â”‚  â”‚  metadata   â”‚             â”‚ â”‚
    â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”‚  Metadata: name, description, category, path, mcp_enabled, tags     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    """

    def __init__(
        self,
        name: str,
        description: str,
        tools: Optional[Dict[str, Callable]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        _tool_loader: Optional[Callable] = None,
        # New: Tool metadata for each tool
        tool_metadata: Optional[Dict[str, ToolMetadata]] = None,
        # Skill-level attributes (from ToolSchema patterns)
        category: str = "general",
        mcp_enabled: bool = False,
        tags: Optional[List[str]] = None,
        version: str = "1.0.0",
    ):
        self.name = name
        self.description = description
        self._tools = tools  # None until loaded (lazy) or pre-populated (eager)
        self._tool_loader = _tool_loader  # Callable that returns Dict[str, Callable]
        self.metadata = metadata or {}

        # New: Enhanced metadata from ToolsRegistry patterns
        self._tool_metadata: Dict[str, ToolMetadata] = tool_metadata or {}
        self.category = category
        self.mcp_enabled = mcp_enabled
        self.tags = tags or []
        self.version = version

    @property
    def tools(self) -> Dict[str, Callable]:
        """Lazy-load tools on first access."""
        if self._tools is None:
            if self._tool_loader:
                try:
                    self._tools = self._tool_loader()
                    logger.debug(f"Lazy-loaded {len(self._tools)} tools for skill '{self.name}'")
                except Exception as e:
                    logger.error(f"Failed to lazy-load tools for skill '{self.name}': {e}")
                    self._tools = {}
            else:
                self._tools = {}
        return self._tools

    @tools.setter
    def tools(self, value: Dict[str, Callable]):
        self._tools = value

    def get_tool_metadata(self, tool_name: str) -> Optional[ToolMetadata]:
        """Get metadata for a specific tool."""
        return self._tool_metadata.get(tool_name)

    def set_tool_metadata(self, tool_name: str, metadata: ToolMetadata):
        """Set metadata for a specific tool."""
        self._tool_metadata[tool_name] = metadata

    def list_tools(self) -> List[str]:
        """List all tool names in this skill."""
        return list(self.tools.keys())

    def get_tool(self, tool_name: str) -> Optional[Callable]:
        """Get a specific tool callable."""
        return self.tools.get(tool_name)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API responses."""
        return {
            'name': self.name,
            'description': self.description,
            'category': self.category,
            'mcp_enabled': self.mcp_enabled,
            'tags': self.tags,
            'version': self.version,
            'tools': self.list_tools(),
            'tool_count': len(self.tools),
            'metadata': self.metadata,
        }

    def to_claude_tools(self) -> List[Dict[str, Any]]:
        """Convert all tools to Claude API tool format."""
        claude_tools = []
        for tool_name in self.list_tools():
            meta = self._tool_metadata.get(tool_name)
            if meta:
                claude_tools.append(meta.to_claude_tool())
            else:
                # Generate basic tool definition from callable
                tool = self.tools.get(tool_name)
                if tool:
                    doc = tool.__doc__ or f"Tool: {tool_name}"
                    claude_tools.append({
                        'name': tool_name,
                        'description': doc.strip().split('\n')[0],
                        'input_schema': {'type': 'object', 'properties': {}},
                    })
        return claude_tools


class SkillsRegistry:
    """
    Skills Registry for Jotty Framework
    
    Loads skills from disk and registers tools dynamically.
    Integrates with Jotty's existing tool system (no duplication).
    
    Supports both:
    - Manual skills (written by developers)
    - AI-generated skills (created on-demand via SkillGenerator)
    """
    
    def __init__(self, skills_dir: Optional[str] = None, skill_generator=None):
        """
        Initialize skills registry.
        
        Args:
            skills_dir: Directory containing skills (default: ~/jotty/skills)
            skill_generator: Optional SkillGenerator for AI-powered skill creation
        """
        if skills_dir is None:
            # Priority: env var > repo-relative > user home
            skills_dir = os.getenv("JOTTY_SKILLS_DIR")
            
            if not skills_dir:
                # Try repo-relative (for development)
                # __file__ is core/registry/skills_registry.py
                # Go up: core/registry -> core -> Jotty -> skills
                current_file = Path(__file__).resolve()
                repo_root = current_file.parent.parent.parent  # core/registry -> core -> Jotty
                repo_skills = repo_root / "skills"
                if repo_skills.exists() or repo_root.name == "Jotty":
                    # Create if doesn't exist (we're in repo)
                    repo_skills.mkdir(exist_ok=True)
                    skills_dir = str(repo_skills)
                else:
                    # Fallback to user home (for installed packages)
                    home = os.path.expanduser("~")
                    skills_dir = os.path.join(home, "jotty", "skills")
        
        self.skills_dir = Path(skills_dir)
        self.skills_dir.mkdir(parents=True, exist_ok=True)
        
        # Also check Claude Code skills directory (~/.claude/skills)
        self.claude_skills_dir = Path.home() / ".claude" / "skills"
        
        self.loaded_skills: Dict[str, SkillDefinition] = {}
        self.composite_skills: Dict[str, Any] = {}  # Store composite skills
        self.loaded_collections: Dict[str, Any] = {}  # Store loaded tool collections
        self.initialized = False
        self.skill_generator = skill_generator  # For AI-powered skill generation
        
        # Dependency management
        from .skill_dependency_manager import get_dependency_manager
        self.dependency_manager = get_dependency_manager()
        
        # Tool collections
        self.loaded_collections: Dict[str, Any] = {}  # Store loaded collections
    
    def init(self) -> None:
        """Initialize registry by scanning skill directories for metadata only.

        Tools are NOT imported here - they are lazy-loaded on first access
        via SkillDefinition.tools property. This makes init() fast (no imports,
        no subprocess calls, no dependency checks).
        """
        if self.initialized:
            return

        self._scan_skills_metadata()
        self.initialized = True
        logger.info(f"SkillsRegistry initialized with {len(self.loaded_skills)} skills (lazy)")

    def _scan_skills_metadata(self) -> None:
        """Scan skill directories and register lazy SkillDefinitions (metadata only)."""
        excluded_dirs = {'composite-templates', '__pycache__', '.git', '.DS_Store'}

        # Scan Jotty skills directory
        if self.skills_dir.exists():
            for skill_dir in self.skills_dir.iterdir():
                if skill_dir.is_dir() and skill_dir.name not in excluded_dirs:
                    try:
                        skill = self._register_lazy_skill(skill_dir.name, self.skills_dir)
                        if skill:
                            self.loaded_skills[skill.name] = skill
                    except Exception as e:
                        logger.error(f"Failed to register skill {skill_dir.name}: {e}")
        else:
            logger.warning(f"Skills directory not found: {self.skills_dir}")

        # Scan Claude Code skills directory
        if self.claude_skills_dir.exists():
            for skill_dir in self.claude_skills_dir.iterdir():
                if skill_dir.is_dir() and skill_dir.name not in excluded_dirs:
                    if skill_dir.name in self.loaded_skills:
                        logger.debug(f"Skipping {skill_dir.name} from Claude directory (already registered)")
                        continue
                    try:
                        skill = self._register_lazy_skill(skill_dir.name, self.claude_skills_dir)
                        if skill:
                            self.loaded_skills[skill.name] = skill
                    except Exception as e:
                        logger.error(f"Failed to register Claude Code skill {skill_dir.name}: {e}")

    def _register_lazy_skill(self, skill_name: str, base_dir: Path) -> Optional[SkillDefinition]:
        """Register a skill with metadata only - tools loaded lazily on first access."""
        skill_dir = base_dir / skill_name
        skill_md = skill_dir / "SKILL.md"
        tools_py = skill_dir / "tools.py"
        scripts_dir = skill_dir / "scripts"

        is_claude_code_skill = scripts_dir.exists() and scripts_dir.is_dir()

        if not tools_py.exists() and not is_claude_code_skill:
            logger.debug(f"Skipping {skill_name}: no tools.py or scripts/")
            return None

        # Read SKILL.md for metadata (lightweight - just text parsing)
        description = self._read_skill_description(skill_md)

        # Create a loader closure that captures the skill directory info
        registry = self  # capture reference for closure
        def make_tool_loader(s_dir, s_name, is_cc_skill, s_md):
            def loader() -> Dict[str, Callable]:
                # Dependency check deferred to first tool load
                dep_result = registry.dependency_manager.ensure_skill_dependencies(s_name, s_dir)
                if dep_result["success"] and dep_result.get("installed"):
                    logger.info(f"Installed dependencies for {s_name}: {dep_result['installed']}")
                elif not dep_result["success"]:
                    logger.warning(f"Dependency install failed for {s_name}: {dep_result.get('error')}")

                if is_cc_skill:
                    md_content = s_md.read_text() if s_md.exists() else ""
                    return registry._load_claude_code_skill(s_dir, s_name, md_content)
                else:
                    tools_file = s_dir / "tools.py"
                    if tools_file.exists():
                        return registry._load_tools_from_file(tools_file)
                    return {}
            return loader

        return SkillDefinition(
            name=skill_name,
            description=description or f"Skill: {skill_name}",
            _tool_loader=make_tool_loader(skill_dir, skill_name, is_claude_code_skill, skill_md),
            metadata={"path": str(skill_dir), "is_claude_code_skill": is_claude_code_skill}
        )

    def _read_skill_description(self, skill_md: Path) -> str:
        """Read description from SKILL.md (lightweight metadata parsing)."""
        description = ""
        title = ""
        if skill_md.exists():
            try:
                content = skill_md.read_text()
                lines = content.split("\n")
                in_description = False

                for i, line in enumerate(lines):
                    # Get title from first heading
                    if line.startswith("# ") and not title:
                        title = line[2:].strip()
                        # Also check if next line is a one-liner description
                        if i + 1 < len(lines) and lines[i + 1].strip() and not lines[i + 1].startswith("#"):
                            description = lines[i + 1].strip()
                        continue

                    # Look for ## Description section
                    if line.strip().lower() in ["## description", "**description**", "description:"]:
                        in_description = True
                        continue

                    # Collect description content (until next heading or empty lines)
                    if in_description:
                        if line.startswith("#") or line.startswith("##"):
                            break  # Stop at next section
                        if line.strip():
                            if description:
                                description += " " + line.strip()
                            else:
                                description = line.strip()
                        elif description:
                            break  # Stop at empty line after content

                # Fallback to title if no description found
                if not description:
                    description = title

            except Exception as e:
                logger.debug(f"Could not read {skill_md}: {e}")
        return description[:500] if description else ""  # Limit length

    def load_all_skills(self) -> Dict[str, Callable]:
        """
        Eagerly load all skills and return tools.

        This forces all lazy skills to load their tools immediately.
        Prefer using init() + lazy access for better startup performance.
        """
        self.init()  # Ensure metadata is scanned
        all_tools: Dict[str, Callable] = {}
        for skill in self.loaded_skills.values():
            all_tools.update(skill.tools)  # Triggers lazy load
        return all_tools
    
    def _load_skill(self, skill_name: str, base_dir: Optional[Path] = None) -> SkillDefinition:
        """
        Eagerly load a single skill from disk (tools imported immediately).

        Used by load_collection and other callers that need tools right away.
        For lazy loading, use _register_lazy_skill() instead.
        """
        if base_dir is None:
            base_dir = self.skills_dir

        skill_dir = base_dir / skill_name
        skill_md = skill_dir / "SKILL.md"
        tools_py = skill_dir / "tools.py"
        scripts_dir = skill_dir / "scripts"

        is_claude_code_skill = scripts_dir.exists() and scripts_dir.is_dir()

        if not tools_py.exists() and not is_claude_code_skill:
            raise FileNotFoundError(f"Skill {skill_name} missing tools.py and no scripts/ directory found")

        description = self._read_skill_description(skill_md)

        # Load tools eagerly
        if is_claude_code_skill:
            content = skill_md.read_text() if skill_md.exists() else ""
            tools = self._load_claude_code_skill(skill_dir, skill_name, content)
        elif tools_py.exists():
            tools = self._load_tools_from_file(tools_py)
        else:
            tools = {}

        return SkillDefinition(
            name=skill_name,
            description=description or f"Skill: {skill_name}",
            tools=tools,
            metadata={"path": str(skill_dir), "is_claude_code_skill": is_claude_code_skill}
        )
    
    def _load_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Load tools from a Python file.
        
        For TypeScript/JavaScript skills, would need compilation step.
        This is a simplified version for Python tools.
        
        Args:
            tools_file: Path to tools.py file
            
        Returns:
            Dict mapping tool names to execute functions
        """
        tools: Dict[str, Callable] = {}
        
        try:
            # Add venv site-packages to sys.path if available
            import sys
            if hasattr(self, 'dependency_manager') and self.dependency_manager:
                venv_manager = self.dependency_manager.venv_manager
                if venv_manager and venv_manager.shared_venv_path:
                    # Detect Python version dynamically
                    python_version = f"{sys.version_info.major}.{sys.version_info.minor}"
                    venv_site_packages = venv_manager.shared_venv_path / 'lib' / f'python{python_version}' / 'site-packages'
                    
                    # If not found, try to find any pythonX.Y directory
                    if not venv_site_packages.exists():
                        lib_dir = venv_manager.shared_venv_path / 'lib'
                        if lib_dir.exists():
                            for subdir in lib_dir.iterdir():
                                if subdir.is_dir() and subdir.name.startswith('python'):
                                    potential_site_packages = subdir / 'site-packages'
                                    if potential_site_packages.exists():
                                        venv_site_packages = potential_site_packages
                                        break
                    
                    if venv_site_packages.exists() and str(venv_site_packages) not in sys.path:
                        sys.path.insert(0, str(venv_site_packages))
                        logger.debug(f"Added venv site-packages to sys.path: {venv_site_packages}")
            
            # Dynamically import the module
            spec = importlib.util.spec_from_file_location("skill_tools", tools_file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Extract tool functions (functions decorated with @tool or named *_tool)
                for attr_name in dir(module):
                    if not attr_name.startswith("_"):
                        attr = getattr(module, attr_name)
                        if callable(attr):
                            # Check if it's a tool (has execute method or is tool-like)
                            if hasattr(attr, "execute") or attr_name.endswith("_tool"):
                                tools[attr_name] = attr
        except Exception as e:
            logger.error(f"Error loading tools from {tools_file}: {e}")
            # Fallback: create mock tools based on file content
            tools = self._create_mock_tools_from_file(tools_file)
        
        return tools
    
    def _create_mock_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Create mock tools from file content (for testing/fallback).
        
        In production, proper tool loading would be used.
        This is for testing integration only.
        """
        content = tools_file.read_text()
        tools: Dict[str, Callable] = {}
        
        # Extract tool names from file (simplified)
        import re
        tool_matches = re.findall(r'def\s+(\w+)\s*\(|(\w+)\s*=\s*tool\(', content)
        
        for match in tool_matches:
            tool_name = match[0] or match[1]
            if tool_name:
                # Create mock execute function
                tools[tool_name] = self._create_mock_executor(tool_name)
        
        return tools
    
    def _create_mock_executor(self, tool_name: str) -> Callable:
        """Create mock executor for testing."""
        async def mock_execute(params: Dict[str, Any]) -> Dict[str, Any]:
            return {
                "success": True,
                "tool": tool_name,
                "params": params,
                "message": f"Tool {tool_name} executed (mock - implement in tools.py)",
            }
        return mock_execute
    
    def _load_claude_code_skill(self, skill_dir: Path, skill_name: str, skill_md_content: str) -> Dict[str, Callable]:
        """
        Load Python-based Claude Code skill (e.g., last30days).
        
        Claude Code skills have Python scripts in scripts/ directory instead of tools.py.
        This method creates wrapper tools that execute the Python scripts.
        
        Args:
            skill_dir: Skill directory path
            skill_name: Skill name
            skill_md_content: Content of SKILL.md for metadata extraction
            
        Returns:
            Dict mapping tool names to execute functions
        """
        tools: Dict[str, Callable] = {}
        scripts_dir = skill_dir / "scripts"
        
        if not scripts_dir.exists():
            logger.warning(f"Claude Code skill {skill_name} has no scripts/ directory")
            return tools
        
        # Look for main script (skill_name.py) or any .py files
        main_script = scripts_dir / f"{skill_name}.py"
        
        if main_script.exists():
            # Create wrapper tool for main script
            tool_name = skill_name.replace("-", "_")
            tools[tool_name] = self._create_claude_code_executor(main_script, skill_dir, skill_md_content)
        else:
            # Look for other Python scripts
            for script_file in scripts_dir.glob("*.py"):
                tool_name = script_file.stem.replace("-", "_")
                tools[tool_name] = self._create_claude_code_executor(script_file, skill_dir, skill_md_content)
        
        return tools
    
    def _create_claude_code_executor(self, script_path: Path, skill_dir: Path, skill_md_content: str) -> Callable:
        """
        Create executor function for Claude Code Python script.
        
        Args:
            script_path: Path to Python script
            skill_dir: Skill directory
            skill_md_content: SKILL.md content for description extraction
            
        Returns:
            Callable tool executor function
        """
        async def execute_claude_code_skill(params: Dict[str, Any]) -> Dict[str, Any]:
            """
            Execute Claude Code Python skill script.
            
            Supports common parameters:
            - topic: Research topic
            - tool: Target tool (e.g., "ChatGPT")
            - quick: Faster research
            - deep: Comprehensive research
            - sources: Source selection (auto, reddit, x, both)
            - emit: Output format (compact, json, md, context, path)
            - refresh: Bypass cache
            """
            try:
                # Build command arguments
                args = []
                
                if params.get("topic"):
                    args.append(f'"{params["topic"]}"')
                
                if params.get("tool"):
                    args.append(f'for {params["tool"]}')
                
                if params.get("quick"):
                    args.append("--quick")
                
                if params.get("deep"):
                    args.append("--deep")
                
                if params.get("sources"):
                    args.append(f"--sources={params['sources']}")
                
                if params.get("emit"):
                    args.append(f"--emit={params['emit']}")
                
                if params.get("refresh"):
                    args.append("--refresh")
                
                # Execute Python script
                cmd = ["python3", str(script_path)] + args
                
                result = subprocess.run(
                    cmd,
                    cwd=str(skill_dir),
                    capture_output=True,
                    text=True,
                    timeout=120,  # 2 minutes timeout
                )
                
                if result.returncode != 0:
                    logger.error(f"Claude Code skill execution failed: {result.stderr}")
                    return {
                        "success": False,
                        "error": result.stderr or "Script execution failed",
                        "stdout": result.stdout,
                    }
                
                # Parse output based on emit format
                if params.get("emit") == "json":
                    try:
                        output = json.loads(result.stdout)
                        return {"success": True, **output}
                    except json.JSONDecodeError:
                        return {
                            "success": True,
                            "output": result.stdout,
                            "format": "json",
                            "raw": True,
                        }
                
                return {
                    "success": True,
                    "output": result.stdout,
                    "format": params.get("emit", "compact"),
                }
            except subprocess.TimeoutExpired:
                return {
                    "success": False,
                    "error": "Script execution timed out (120s limit)",
                }
            except Exception as e:
                logger.error(f"Error executing Claude Code skill: {e}")
                return {
                    "success": False,
                    "error": str(e),
                }
        
        return execute_claude_code_skill
    
    def get_registered_tools(self) -> Dict[str, Callable]:
        """
        Get all registered tools from loaded skills.
        
        Returns:
            Dict mapping tool names to execute functions
            (for merging into Jotty's tool registry)
        """
        tools: Dict[str, Callable] = {}
        for skill in self.loaded_skills.values():
            tools.update(skill.tools)
        
        # Add package management tools
        from .skill_package_tools import create_package_management_tools
        from .skill_venv_manager import get_venv_manager
        venv_manager = get_venv_manager()
        package_tools = create_package_management_tools(venv_manager)
        tools.update(package_tools)
        
        return tools
    
    def get_tool_metadata(self) -> Dict[str, Dict[str, str]]:
        """
        Get tool metadata for all skill tools.
        
        Returns:
            Dict mapping tool names to metadata
            (for merging into Jotty's tool metadata)
        """
        metadata: Dict[str, Dict[str, str]] = {}
        
        for skill in self.loaded_skills.values():
            for tool_name in skill.tools.keys():
                metadata[tool_name] = {
                    "category": "skill",
                    "description": f"Tool from skill: {skill.name}",
                    "skill": skill.name,
                }
        
        return metadata
    
    def list_skills(self) -> List[Dict[str, Any]]:
        """List all registered skills.

        Returns tool names if tools are already loaded, otherwise
        triggers lazy load to provide accurate tool lists.
        """
        return [
            {
                "name": skill.name,
                "description": skill.description,
                "tools": list(skill.tools.keys()),
                "metadata": skill.metadata,
            }
            for skill in self.loaded_skills.values()
        ]
    
    def get_skill(self, name: str) -> Optional[SkillDefinition]:
        """Get a specific skill by name."""
        return self.loaded_skills.get(name)
    
    def load_collection(self, collection: 'ToolCollection', collection_name: Optional[str] = None) -> Dict[str, Callable]:
        """
        Load a tool collection into the registry.
        
        Args:
            collection: ToolCollection instance
            collection_name: Optional name for the collection (default: auto-generated)
            
        Returns:
            Dict mapping tool names to execute functions
            
        Example:
            from core.registry.tool_collection import ToolCollection
            
            collection = ToolCollection.from_hub("collection-slug", trust_remote_code=True)
            registry.load_collection(collection)
        """
        from .tool_collection import ToolCollection
        
        if not isinstance(collection, ToolCollection):
            raise TypeError(f"Expected ToolCollection, got {type(collection)}")
        
        # Generate collection name if not provided
        if collection_name is None:
            collection_name = f"collection_{len(self.loaded_collections)}"
        
        # Convert tools to SkillDefinitions
        skill_definitions = collection.to_skill_definitions()
        
        # Register each skill
        all_tools: Dict[str, Callable] = {}
        for skill_def in skill_definitions:
            if skill_def:
                # Add collection prefix to avoid conflicts
                prefixed_name = f"{collection_name}_{skill_def.name}"
                
                # Register skill
                self.loaded_skills[prefixed_name] = skill_def
                all_tools.update(skill_def.tools)
                
                logger.info(f"Loaded tool from collection: {prefixed_name}")
        
        # Store collection
        self.loaded_collections[collection_name] = {
            "collection": collection,
            "tools": all_tools,
            "source": collection.source,
            "metadata": collection.metadata
        }
        
        logger.info(f"Loaded collection '{collection_name}' with {len(skill_definitions)} tools")
        
        return all_tools
    
    def list_collections(self) -> List[Dict[str, Any]]:
        """
        List all loaded collections.
        
        Returns:
            List of collection metadata dicts
        """
        return [
            {
                "name": name,
                "source": info["source"],
                "tool_count": len(info["tools"]),
                "metadata": info["metadata"]
            }
            for name, info in self.loaded_collections.items()
        ]
    
    def get_collection(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get a loaded collection by name.
        
        Args:
            name: Collection name
            
        Returns:
            Collection info dict or None
        """
        return self.loaded_collections.get(name)
    
    # =============================================================================
    # Agent Conversion (Refactoring #4)
    # =============================================================================
    
    async def get_agent_for_skill(
        self,
        skill_name: str,
        agent_name: Optional[str] = None
    ):
        """
        Get or create AgentConfig for a skill.
        
        Args:
            skill_name: Name of skill
            agent_name: Optional custom agent name
            
        Returns:
            AgentConfig or None
        """
        try:
            from .skill_to_agent_converter import SkillToAgentConverter
            converter = SkillToAgentConverter()
            return await converter.create_agent_from_skill_name(skill_name, agent_name)
        except Exception as e:
            logger.warning(f"Failed to convert skill '{skill_name}' to agent: {e}")
            return None
    
    async def list_agents_from_skills(
        self,
        agent_name_prefix: Optional[str] = None
    ) -> List[Any]:
        """
        List all agents created from skills.
        
        Args:
            agent_name_prefix: Optional prefix for agent names
            
        Returns:
            List of AgentConfig
        """
        try:
            from .skill_to_agent_converter import SkillToAgentConverter
            converter = SkillToAgentConverter()
            
            skills = list(self.loaded_skills.values())
            return await converter.convert_skills_to_agents(skills, agent_name_prefix)
        except Exception as e:
            logger.warning(f"Failed to convert skills to agents: {e}")
            return []


# Singleton instance
_registry_instance: Optional[SkillsRegistry] = None


def get_skills_registry(skills_dir: Optional[str] = None) -> SkillsRegistry:
    """Get singleton skills registry instance (auto-initialized)."""
    global _registry_instance
    if _registry_instance is None:
        _registry_instance = SkillsRegistry(skills_dir)
        _registry_instance.init()  # Auto-initialize to load skills
    return _registry_instance
