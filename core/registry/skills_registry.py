"""
Skills Registry - DRY Implementation for Jotty Framework

Skills are dynamically loaded tools that extend agent capabilities.
This is framework-level infrastructure, reusable across all Jotty clients.

Architecture:
- Skills live in ~/jotty/skills/<name>/SKILL.md and tools.py
- Skills registry loads and registers tools dynamically
- Skills can be GENERATED by AI (like Clawd.bot) or manually written
- Tools integrate with existing Jotty tool system (no duplication)
- Clients (like JustJot.ai) use Jotty's skills system

Key Features:
- Load existing skills from disk
- Generate new skills using AI (via SkillGenerator)
- Hot-reload skills on changes
- Validate skills before registration

Note: This is framework code, not client-specific.
"""

import os
import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
import importlib.util

# Load environment variables from .env file
try:
    from dotenv import load_dotenv
    # Load .env from Jotty root directory
    current_file = Path(__file__).resolve()
    jotty_root = current_file.parent.parent.parent  # core/registry -> core -> Jotty
    env_file = jotty_root / ".env"
    if env_file.exists():
        load_dotenv(env_file, override=False)  # Don't override existing env vars
except ImportError:
    pass  # python-dotenv not available, fall back to os.getenv

logger = logging.getLogger(__name__)


# =============================================================================
# SKILL TYPE ENUM
# =============================================================================

class SkillType(Enum):
    """
    Classification of skills by their composition pattern.

    BASE:      Fundamental atomic skill. Does one thing, no dependency on other skills.
               Examples: web-search, calculator, telegram-sender, file-operations

    DERIVED:   Extends a single base skill for a specific domain.
               Has ONE primary base skill it specializes.
               Examples: stock-research (derives from web-search),
                         investing-commodities (derives from web-scraper)

    COMPOSITE: Combines 2+ base or derived skills in a workflow.
               Supports sequential, parallel, or mixed execution.
               Examples: search-summarize-pdf-telegram (web-search + claude-cli-llm +
                         document-converter + telegram-sender)
    """
    BASE = "base"
    DERIVED = "derived"
    COMPOSITE = "composite"


# =============================================================================
# BASE SKILL CLASS
# =============================================================================

class BaseSkill:
    """
    Base class for all Jotty skills.

    Skills extend this class to gain:
    - Status callback support for progress reporting
    - Lifecycle hooks (setup, execute, cleanup)
    - Consistent interface across all skills
    - Context sharing (session, user, metadata)

    Usage:
        class ResearchSkill(BaseSkill):
            name = "research-to-pdf"
            description = "Research topics and create PDF reports"

            def setup(self):
                # Initialize resources
                pass

            async def execute(self, params: dict) -> dict:
                self.status("Searching", "ðŸ” Searching the web...")
                results = await self.search(params['query'])

                self.status("Analyzing", "ðŸ§  Analyzing results...")
                analysis = self.analyze(results)

                self.status("Creating", "ðŸ“„ Creating PDF...")
                pdf_path = self.create_pdf(analysis)

                return {"success": True, "pdf_path": pdf_path}

    The status() method emits progress updates that flow to the CLI/UI.
    """

    # Class attributes - override in subclasses
    name: str = "base-skill"
    description: str = "Base skill class"
    version: str = "1.0.0"
    category: str = "general"
    tags: List[str] = []

    def __init__(self, status_callback: Optional[Callable] = None):
        """
        Initialize skill with optional status callback.

        Args:
            status_callback: Callable(stage, detail) for progress updates
        """
        self._status_callback = status_callback
        self._context: Dict[str, Any] = {}

    def set_status_callback(self, callback: Callable):
        """Set status callback for progress reporting."""
        self._status_callback = callback

    def set_context(self, **context):
        """Set execution context (session_id, user_id, metadata, etc.)."""
        self._context.update(context)

    def status(self, stage: str, detail: str = ""):
        """
        Emit a status update for progress reporting.

        Args:
            stage: Stage name (e.g., "Searching", "Analyzing")
            detail: Detail message with emoji (e.g., "ðŸ” Searching web...")
        """
        if self._status_callback:
            try:
                self._status_callback(stage, detail)
            except Exception:
                pass
        logger.debug(f"[{self.name}] {stage}: {detail}")

    def setup(self):
        """
        Setup hook called before execution.
        Override in subclasses for initialization.
        """
        pass

    def cleanup(self):
        """
        Cleanup hook called after execution.
        Override in subclasses for resource cleanup.
        """
        pass

    async def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the skill with given parameters.

        Override in subclasses to implement skill logic.

        Args:
            params: Skill parameters

        Returns:
            Result dict with 'success' key
        """
        raise NotImplementedError("Subclasses must implement execute()")

    def get_tools(self) -> Dict[str, Callable]:
        """
        Get tool functions for this skill.

        Returns dict mapping tool names to callables.
        Default implementation wraps execute() as the main tool.
        Override for skills with multiple tools.
        """
        async def main_tool(params: dict) -> dict:
            self.setup()
            try:
                return await self.execute(params)
            finally:
                self.cleanup()

        return {f"{self.name}_tool": main_tool}

    def to_definition(self) -> "SkillDefinition":
        """Convert to SkillDefinition for registry compatibility."""
        return SkillDefinition(
            name=self.name,
            description=self.description,
            tools=self.get_tools(),
            category=self.category,
            tags=self.tags,
            version=self.version,
        )


# =============================================================================
# TOOL METADATA (Absorbed from ToolsRegistry)
# =============================================================================

@dataclass
class ToolMetadata:
    """
    Metadata for a tool within a skill.

    This consolidates ToolSchema from the old ToolsRegistry into SkillsRegistry,
    providing rich metadata for each tool including MCP support, parameters, etc.

    The SkillsRegistry is now the single source of truth for tools.
    """
    name: str  # Tool name within the skill
    description: str  # What this tool does
    category: str = "general"  # Category grouping
    mcp_enabled: bool = False  # Available via MCP protocol
    parameters: Dict[str, Any] = field(default_factory=dict)  # Parameter schema (JSON Schema)
    returns: Optional[str] = None  # Return type description
    examples: List[Dict[str, Any]] = field(default_factory=list)  # Usage examples
    tags: List[str] = field(default_factory=list)  # Searchable tags

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API responses."""
        return {
            'name': self.name,
            'description': self.description,
            'category': self.category,
            'mcp_enabled': self.mcp_enabled,
            'parameters': self.parameters,
            'returns': self.returns,
            'examples': self.examples,
            'tags': self.tags,
        }

    def to_claude_tool(self) -> Dict[str, Any]:
        """Convert to Claude API tool format."""
        return {
            'name': self.name,
            'description': self.description,
            'input_schema': {
                'type': 'object',
                'properties': self.parameters.get('properties', {}),
                'required': self.parameters.get('required', []),
            }
        }


# =============================================================================
# SKILL DEFINITION (Enhanced with Tool Metadata)
# =============================================================================

class SkillDefinition:
    """
    Definition of a skill with its tools (supports lazy loading).

    Skills are the "Hands" of the Jotty system - they represent what the
    swarm can DO. Each skill contains multiple tools with rich metadata.

    Architecture:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                       SKILL DEFINITION (Hands)                       â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  â”‚                          Tools                                   â”‚ â”‚
    â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚ â”‚
    â”‚  â”‚  â”‚   tool_1    â”‚  â”‚   tool_2    â”‚  â”‚   tool_N    â”‚             â”‚ â”‚
    â”‚  â”‚  â”‚  callable   â”‚  â”‚  callable   â”‚  â”‚  callable   â”‚             â”‚ â”‚
    â”‚  â”‚  â”‚  metadata   â”‚  â”‚  metadata   â”‚  â”‚  metadata   â”‚             â”‚ â”‚
    â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”‚  Metadata: name, description, category, path, mcp_enabled, tags     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    """

    def __init__(
        self,
        name: str,
        description: str,
        tools: Optional[Dict[str, Callable]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        _tool_loader: Optional[Callable] = None,
        # New: Tool metadata for each tool
        tool_metadata: Optional[Dict[str, ToolMetadata]] = None,
        # Skill-level attributes (from ToolSchema patterns)
        category: str = "general",
        mcp_enabled: bool = False,
        tags: Optional[List[str]] = None,
        version: str = "1.0.0",
        # Capability-based discovery fields
        capabilities: Optional[List[str]] = None,
        is_composite: bool = False,
        combines: Optional[List[str]] = None,
        use_when: Optional[str] = None,
        # Skill type classification (base/derived/composite)
        skill_type: Optional[SkillType] = None,
        base_skills: Optional[List[str]] = None,
        execution_mode: Optional[str] = None,
    ):
        self.name = name
        self.description = description
        self._tools = tools  # None until loaded (lazy) or pre-populated (eager)
        self._tool_loader = _tool_loader  # Callable that returns Dict[str, Callable]
        self.metadata = metadata or {}

        # New: Enhanced metadata from ToolsRegistry patterns
        self._tool_metadata: Dict[str, ToolMetadata] = tool_metadata or {}
        self.category = category
        self.mcp_enabled = mcp_enabled
        self.tags = tags or []
        self.version = version

        # Capability-based discovery: enables smart skill filtering
        # capabilities: What this skill can do (e.g., ["data-fetch", "communicate"])
        # is_composite: True if this skill combines multiple atomic skills
        # combines: List of atomic skills this composite replaces (hint to LLM)
        # use_when: Natural language hint for when to use this skill
        self.capabilities = capabilities or []
        self.combines = combines or []
        self.use_when = use_when or ""

        # Skill type classification
        # skill_type: BASE | DERIVED | COMPOSITE (see SkillType enum)
        # base_skills: List of skills this depends on (for derived: 1 skill, for composite: 2+)
        # execution_mode: For composite skills - "sequential", "parallel", or "mixed"
        self.base_skills = base_skills or []
        self.execution_mode = execution_mode or ""

        # Resolve skill_type: explicit > inferred from is_composite > default BASE
        if skill_type is not None:
            self.skill_type = skill_type
        elif is_composite:
            self.skill_type = SkillType.COMPOSITE
        else:
            self.skill_type = SkillType.BASE

        # Backward compat: is_composite is now derived from skill_type
        # but can still be set explicitly for legacy SKILL.md files
        self._is_composite_override = is_composite

    @property
    def is_composite(self) -> bool:
        """Whether this is a composite skill (backward-compatible property)."""
        return self.skill_type == SkillType.COMPOSITE or self._is_composite_override

    @is_composite.setter
    def is_composite(self, value: bool):
        """Setter for backward compatibility."""
        self._is_composite_override = value
        if value and self.skill_type == SkillType.BASE:
            self.skill_type = SkillType.COMPOSITE

    @property
    def tools(self) -> Dict[str, Callable]:
        """Lazy-load tools on first access."""
        if self._tools is None:
            if self._tool_loader:
                try:
                    self._tools = self._tool_loader()
                    logger.debug(f"Lazy-loaded {len(self._tools)} tools for skill '{self.name}'")
                except Exception as e:
                    logger.error(f"Failed to lazy-load tools for skill '{self.name}': {e}")
                    self._tools = {}
            else:
                self._tools = {}
        return self._tools

    @tools.setter
    def tools(self, value: Dict[str, Callable]):
        self._tools = value

    def get_tool_metadata(self, tool_name: str) -> Optional[ToolMetadata]:
        """Get metadata for a specific tool."""
        return self._tool_metadata.get(tool_name)

    def set_tool_metadata(self, tool_name: str, metadata: ToolMetadata):
        """Set metadata for a specific tool."""
        self._tool_metadata[tool_name] = metadata

    def list_tools(self) -> List[str]:
        """List all tool names in this skill (triggers lazy load)."""
        return list(self.tools.keys())

    @property
    def is_loaded(self) -> bool:
        """Check if tools have been loaded without triggering lazy loading."""
        return self._tools is not None

    def get_tool(self, tool_name: str) -> Optional[Callable]:
        """Get a specific tool callable."""
        return self.tools.get(tool_name)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API responses."""
        result = {
            'name': self.name,
            'description': self.description,
            'category': self.category,
            'mcp_enabled': self.mcp_enabled,
            'tags': self.tags,
            'version': self.version,
            'tools': self.list_tools(),
            'tool_count': len(self.tools),
            'metadata': self.metadata,
            # Capability-based discovery fields
            'capabilities': self.capabilities,
            'is_composite': self.is_composite,
            # Skill type classification
            'skill_type': self.skill_type.value,
            'base_skills': self.base_skills,
        }
        # Only include composite/derived hints when relevant
        if self.skill_type == SkillType.COMPOSITE:
            # Backward compat: populate combines from base_skills if empty
            result['combines'] = self.combines if self.combines else self.base_skills
            result['use_when'] = self.use_when
            result['execution_mode'] = self.execution_mode
        elif self.skill_type == SkillType.DERIVED:
            result['use_when'] = self.use_when
        return result

    def to_claude_tools(self) -> List[Dict[str, Any]]:
        """Convert all tools to Claude API tool format."""
        claude_tools = []
        for tool_name in self.list_tools():
            meta = self._tool_metadata.get(tool_name)
            if meta:
                claude_tools.append(meta.to_claude_tool())
            else:
                # Generate basic tool definition from callable
                tool = self.tools.get(tool_name)
                if tool:
                    doc = tool.__doc__ or f"Tool: {tool_name}"
                    claude_tools.append({
                        'name': tool_name,
                        'description': doc.strip().split('\n')[0],
                        'input_schema': {'type': 'object', 'properties': {}},
                    })
        return claude_tools


class SkillsRegistry:
    """
    Skills Registry for Jotty Framework
    
    Loads skills from disk and registers tools dynamically.
    Integrates with Jotty's existing tool system (no duplication).
    
    Supports both:
    - Manual skills (written by developers)
    - AI-generated skills (created on-demand via SkillGenerator)
    """
    
    def __init__(self, skills_dir: Optional[str] = None, skill_generator=None):
        """
        Initialize skills registry.
        
        Args:
            skills_dir: Directory containing skills (default: ~/jotty/skills)
            skill_generator: Optional SkillGenerator for AI-powered skill creation
        """
        if skills_dir is None:
            # Priority: env var > repo-relative > user home
            skills_dir = os.getenv("JOTTY_SKILLS_DIR")
            
            if not skills_dir:
                # Try repo-relative (for development)
                # __file__ is core/registry/skills_registry.py
                # Go up: core/registry -> core -> Jotty -> skills
                current_file = Path(__file__).resolve()
                repo_root = current_file.parent.parent.parent  # core/registry -> core -> Jotty
                repo_skills = repo_root / "skills"
                if repo_skills.exists() or repo_root.name == "Jotty":
                    # Create if doesn't exist (we're in repo)
                    repo_skills.mkdir(exist_ok=True)
                    skills_dir = str(repo_skills)
                else:
                    # Fallback to user home (for installed packages)
                    home = os.path.expanduser("~")
                    skills_dir = os.path.join(home, "jotty", "skills")
        
        self.skills_dir = Path(skills_dir)
        self.skills_dir.mkdir(parents=True, exist_ok=True)
        
        # Also check Claude Code skills directory (~/.claude/skills)
        self.claude_skills_dir = Path.home() / ".claude" / "skills"
        
        self.loaded_skills: Dict[str, SkillDefinition] = {}
        self.composite_skills: Dict[str, Any] = {}  # Store composite skills
        self.loaded_collections: Dict[str, Any] = {}  # Store loaded tool collections
        self.initialized = False
        self.skill_generator = skill_generator  # For AI-powered skill generation
        
        # Dependency management
        from .skill_dependency_manager import get_dependency_manager
        self.dependency_manager = get_dependency_manager()
    
    def init(self) -> None:
        """Initialize registry by scanning skill directories for metadata only.

        Tools are NOT imported here - they are lazy-loaded on first access
        via SkillDefinition.tools property. This makes init() fast (no imports,
        no subprocess calls, no dependency checks).
        """
        if self.initialized:
            return

        self._scan_skills_metadata()
        self.initialized = True
        logger.info(f"SkillsRegistry initialized with {len(self.loaded_skills)} skills (lazy)")

    def _scan_skills_metadata(self) -> None:
        """Scan skill directories and register lazy SkillDefinitions (metadata only)."""
        excluded_dirs = {'composite-templates', '__pycache__', '.git', '.DS_Store'}

        # Scan Jotty skills directory
        if self.skills_dir.exists():
            for skill_dir in self.skills_dir.iterdir():
                if skill_dir.is_dir() and skill_dir.name not in excluded_dirs:
                    try:
                        skill = self._register_lazy_skill(skill_dir.name, self.skills_dir)
                        if skill:
                            self.loaded_skills[skill.name] = skill
                    except Exception as e:
                        logger.error(f"Failed to register skill {skill_dir.name}: {e}")
        else:
            logger.warning(f"Skills directory not found: {self.skills_dir}")

        # Scan Claude Code skills directory
        if self.claude_skills_dir.exists():
            for skill_dir in self.claude_skills_dir.iterdir():
                if skill_dir.is_dir() and skill_dir.name not in excluded_dirs:
                    if skill_dir.name in self.loaded_skills:
                        logger.debug(f"Skipping {skill_dir.name} from Claude directory (already registered)")
                        continue
                    try:
                        skill = self._register_lazy_skill(skill_dir.name, self.claude_skills_dir)
                        if skill:
                            self.loaded_skills[skill.name] = skill
                    except Exception as e:
                        logger.error(f"Failed to register Claude Code skill {skill_dir.name}: {e}")

    def _register_lazy_skill(self, skill_name: str, base_dir: Path) -> Optional[SkillDefinition]:
        """Register a skill with metadata only - tools loaded lazily on first access."""
        skill_dir = base_dir / skill_name
        skill_md = skill_dir / "SKILL.md"
        tools_py = skill_dir / "tools.py"
        scripts_dir = skill_dir / "scripts"

        is_claude_code_skill = scripts_dir.exists() and scripts_dir.is_dir()

        if not tools_py.exists() and not is_claude_code_skill:
            logger.debug(f"Skipping {skill_name}: no tools.py or scripts/")
            return None

        # Parse SKILL.md for full metadata including capabilities
        skill_metadata = self._parse_skill_metadata(skill_md)

        # Create a loader closure that captures the skill directory info
        registry = self  # capture reference for closure
        def make_tool_loader(s_dir, s_name, is_cc_skill, s_md):
            def loader() -> Dict[str, Callable]:
                # Dependency check deferred to first tool load
                dep_result = registry.dependency_manager.ensure_skill_dependencies(s_name, s_dir)
                if dep_result["success"] and dep_result.get("installed"):
                    logger.info(f"Installed dependencies for {s_name}: {dep_result['installed']}")
                elif not dep_result["success"]:
                    logger.warning(f"Dependency install failed for {s_name}: {dep_result.get('error')}")

                if is_cc_skill:
                    md_content = s_md.read_text() if s_md.exists() else ""
                    return registry._load_claude_code_skill(s_dir, s_name, md_content)
                else:
                    tools_file = s_dir / "tools.py"
                    if tools_file.exists():
                        return registry._load_tools_from_file(tools_file)
                    return {}
            return loader

        # Resolve SkillType from parsed metadata
        parsed_type = skill_metadata.get('skill_type')
        resolved_skill_type = None
        if parsed_type == 'base':
            resolved_skill_type = SkillType.BASE
        elif parsed_type == 'derived':
            resolved_skill_type = SkillType.DERIVED
        elif parsed_type == 'composite':
            resolved_skill_type = SkillType.COMPOSITE

        return SkillDefinition(
            name=skill_name,
            description=skill_metadata['description'] or f"Skill: {skill_name}",
            _tool_loader=make_tool_loader(skill_dir, skill_name, is_claude_code_skill, skill_md),
            metadata={"path": str(skill_dir), "is_claude_code_skill": is_claude_code_skill},
            # Capability-based discovery fields
            capabilities=skill_metadata['capabilities'],
            is_composite=skill_metadata['is_composite'],
            combines=skill_metadata['combines'],
            use_when=skill_metadata['use_when'],
            # Skill type classification
            skill_type=resolved_skill_type,
            base_skills=skill_metadata['base_skills'],
            execution_mode=skill_metadata.get('execution_mode', ''),
        )

    def _parse_skill_metadata(self, skill_md: Path) -> Dict[str, Any]:
        """
        Parse SKILL.md for comprehensive metadata including type and capability fields.

        Extracts:
        - description: What the skill does
        - skill_type: "base", "derived", or "composite" (SkillType enum value)
        - base_skills: List of skills this depends on (for derived/composite)
        - execution_mode: "sequential", "parallel", "mixed" (for composite)
        - capabilities: List of capabilities (e.g., ["data-fetch", "communicate"])
        - is_composite: Whether this combines multiple atomic skills (legacy compat)
        - combines: List of atomic skills this replaces (for composites)
        - use_when: Natural language hint for when to use this skill

        SKILL.md format:
        ```
        # Skill Name

        Description text here.

        ## Type
        base

        ## Base Skills
        - web-search
        - claude-cli-llm

        ## Execution
        sequential

        ## Capabilities
        - data-fetch
        - communicate

        ## Composite
        Combines: weather-checker, telegram-sender
        Use when: User wants weather sent to Telegram
        ```
        """
        metadata = {
            'description': '',
            'skill_type': None,  # None = not specified, will be inferred
            'base_skills': [],
            'execution_mode': '',
            'capabilities': [],
            'is_composite': False,
            'combines': [],
            'use_when': '',
        }

        if not skill_md.exists():
            return metadata

        try:
            content = skill_md.read_text()
            lines = content.split("\n")

            title = ""
            current_section = None

            for i, line in enumerate(lines):
                stripped = line.strip()

                # Get title from first heading
                if line.startswith("# ") and not title:
                    title = line[2:].strip()
                    # Check if next line is description
                    if i + 1 < len(lines) and lines[i + 1].strip() and not lines[i + 1].startswith("#"):
                        metadata['description'] = lines[i + 1].strip()
                    continue

                # Detect section headers
                if stripped.lower() in ["## description", "**description**", "description:"]:
                    current_section = 'description'
                    continue
                elif stripped.lower() in ["## type", "**type**", "type:"]:
                    current_section = 'type'
                    continue
                elif stripped.lower() in ["## base skills", "**base skills**", "base skills:",
                                          "## base skill", "**base skill**", "base skill:"]:
                    current_section = 'base_skills'
                    continue
                elif stripped.lower() in ["## execution", "**execution**", "execution:",
                                          "## execution mode", "**execution mode**"]:
                    current_section = 'execution'
                    continue
                elif stripped.lower() in ["## capabilities", "**capabilities**", "capabilities:"]:
                    current_section = 'capabilities'
                    continue
                elif stripped.lower() in ["## composite", "**composite**", "composite:"]:
                    current_section = 'composite'
                    metadata['is_composite'] = True
                    continue
                elif stripped.startswith("##") or stripped.startswith("**"):
                    current_section = None  # End of relevant sections
                    continue

                # Parse section content
                if current_section == 'description' and stripped:
                    if metadata['description']:
                        metadata['description'] += " " + stripped
                    else:
                        metadata['description'] = stripped

                elif current_section == 'type' and stripped:
                    type_val = stripped.lower().strip()
                    if type_val in ('base', 'derived', 'composite'):
                        metadata['skill_type'] = type_val
                        if type_val == 'composite':
                            metadata['is_composite'] = True

                elif current_section == 'base_skills' and stripped.startswith("-"):
                    skill_ref = stripped[1:].strip()
                    if skill_ref:
                        metadata['base_skills'].append(skill_ref)

                elif current_section == 'execution' and stripped:
                    mode_val = stripped.lower().strip()
                    if mode_val in ('sequential', 'parallel', 'mixed'):
                        metadata['execution_mode'] = mode_val

                elif current_section == 'capabilities' and stripped.startswith("-"):
                    cap = stripped[1:].strip().lower()
                    if cap:
                        metadata['capabilities'].append(cap)

                elif current_section == 'composite':
                    if stripped.lower().startswith("combines:"):
                        combines_str = stripped[9:].strip()
                        metadata['combines'] = [s.strip() for s in combines_str.split(",") if s.strip()]
                    elif stripped.lower().startswith("use when:"):
                        metadata['use_when'] = stripped[9:].strip()

            # Fallback description to title
            if not metadata['description']:
                metadata['description'] = title

            # Truncate description
            metadata['description'] = metadata['description'][:500]

            # Infer skill_type from combines/base_skills if not explicitly set
            if metadata['skill_type'] is None:
                if metadata['is_composite'] or len(metadata['combines']) >= 2:
                    metadata['skill_type'] = 'composite'
                elif len(metadata['base_skills']) == 1:
                    metadata['skill_type'] = 'derived'
                elif len(metadata['base_skills']) >= 2:
                    metadata['skill_type'] = 'composite'
                # else: leave as None, will default to BASE

        except Exception as e:
            logger.debug(f"Could not parse {skill_md}: {e}")

        return metadata

    def _read_skill_description(self, skill_md: Path) -> str:
        """Read description from SKILL.md (lightweight metadata parsing)."""
        metadata = self._parse_skill_metadata(skill_md)
        return metadata['description']

    def load_all_skills(self) -> Dict[str, Callable]:
        """
        Eagerly load all skills and return tools.

        This forces all lazy skills to load their tools immediately.
        Prefer using init() + lazy access for better startup performance.
        """
        self.init()  # Ensure metadata is scanned
        all_tools: Dict[str, Callable] = {}
        for skill in self.loaded_skills.values():
            all_tools.update(skill.tools)  # Triggers lazy load
        return all_tools
    
    def _load_skill(self, skill_name: str, base_dir: Optional[Path] = None) -> SkillDefinition:
        """
        Eagerly load a single skill from disk (tools imported immediately).

        Used by load_collection and other callers that need tools right away.
        For lazy loading, use _register_lazy_skill() instead.
        """
        if base_dir is None:
            base_dir = self.skills_dir

        skill_dir = base_dir / skill_name
        skill_md = skill_dir / "SKILL.md"
        tools_py = skill_dir / "tools.py"
        scripts_dir = skill_dir / "scripts"

        is_claude_code_skill = scripts_dir.exists() and scripts_dir.is_dir()

        if not tools_py.exists() and not is_claude_code_skill:
            raise FileNotFoundError(f"Skill {skill_name} missing tools.py and no scripts/ directory found")

        description = self._read_skill_description(skill_md)

        # Load tools eagerly
        if is_claude_code_skill:
            content = skill_md.read_text() if skill_md.exists() else ""
            tools = self._load_claude_code_skill(skill_dir, skill_name, content)
        elif tools_py.exists():
            tools = self._load_tools_from_file(tools_py)
        else:
            tools = {}

        return SkillDefinition(
            name=skill_name,
            description=description or f"Skill: {skill_name}",
            tools=tools,
            metadata={"path": str(skill_dir), "is_claude_code_skill": is_claude_code_skill}
        )
    
    def _load_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Load tools from a Python file.
        
        For TypeScript/JavaScript skills, would need compilation step.
        This is a simplified version for Python tools.
        
        Args:
            tools_file: Path to tools.py file
            
        Returns:
            Dict mapping tool names to execute functions
        """
        tools: Dict[str, Callable] = {}
        
        try:
            # Add venv site-packages to sys.path if available
            import sys
            if hasattr(self, 'dependency_manager') and self.dependency_manager:
                venv_manager = self.dependency_manager.venv_manager
                if venv_manager and venv_manager.shared_venv_path:
                    # Detect Python version dynamically
                    python_version = f"{sys.version_info.major}.{sys.version_info.minor}"
                    venv_site_packages = venv_manager.shared_venv_path / 'lib' / f'python{python_version}' / 'site-packages'
                    
                    # If not found, try to find any pythonX.Y directory
                    if not venv_site_packages.exists():
                        lib_dir = venv_manager.shared_venv_path / 'lib'
                        if lib_dir.exists():
                            for subdir in lib_dir.iterdir():
                                if subdir.is_dir() and subdir.name.startswith('python'):
                                    potential_site_packages = subdir / 'site-packages'
                                    if potential_site_packages.exists():
                                        venv_site_packages = potential_site_packages
                                        break
                    
                    if venv_site_packages.exists() and str(venv_site_packages) not in sys.path:
                        sys.path.insert(0, str(venv_site_packages))
                        logger.debug(f"Added venv site-packages to sys.path: {venv_site_packages}")
            
            # Dynamically import the module
            spec = importlib.util.spec_from_file_location("skill_tools", tools_file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Extract tool functions (functions decorated with @tool or named *_tool)
                for attr_name in dir(module):
                    if not attr_name.startswith("_"):
                        attr = getattr(module, attr_name)
                        if callable(attr):
                            # Check if it's a tool (has execute method or is tool-like)
                            if hasattr(attr, "execute") or attr_name.endswith("_tool"):
                                tools[attr_name] = attr
        except Exception as e:
            logger.error(f"Error loading tools from {tools_file}: {e}")
            # Fallback: create mock tools based on file content
            tools = self._create_mock_tools_from_file(tools_file)
        
        return tools
    
    def _create_mock_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Create mock tools from file content (for testing/fallback).
        
        In production, proper tool loading would be used.
        This is for testing integration only.
        """
        content = tools_file.read_text()
        tools: Dict[str, Callable] = {}
        
        # Extract tool names from file (simplified)
        import re
        tool_matches = re.findall(r'def\s+(\w+)\s*\(|(\w+)\s*=\s*tool\(', content)
        
        for match in tool_matches:
            tool_name = match[0] or match[1]
            if tool_name:
                # Create mock execute function
                tools[tool_name] = self._create_mock_executor(tool_name)
        
        return tools
    
    def _create_mock_executor(self, tool_name: str) -> Callable:
        """Create mock executor for testing."""
        async def mock_execute(params: Dict[str, Any]) -> Dict[str, Any]:
            return {
                "success": True,
                "tool": tool_name,
                "params": params,
                "message": f"Tool {tool_name} executed (mock - implement in tools.py)",
            }
        return mock_execute
    
    def _load_claude_code_skill(self, skill_dir: Path, skill_name: str, skill_md_content: str) -> Dict[str, Callable]:
        """
        Load Python-based Claude Code skill (e.g., last30days).
        
        Claude Code skills have Python scripts in scripts/ directory instead of tools.py.
        This method creates wrapper tools that execute the Python scripts.
        
        Args:
            skill_dir: Skill directory path
            skill_name: Skill name
            skill_md_content: Content of SKILL.md for metadata extraction
            
        Returns:
            Dict mapping tool names to execute functions
        """
        tools: Dict[str, Callable] = {}
        scripts_dir = skill_dir / "scripts"
        
        if not scripts_dir.exists():
            logger.warning(f"Claude Code skill {skill_name} has no scripts/ directory")
            return tools
        
        # Look for main script (skill_name.py) or any .py files
        main_script = scripts_dir / f"{skill_name}.py"
        
        if main_script.exists():
            # Create wrapper tool for main script
            tool_name = skill_name.replace("-", "_")
            tools[tool_name] = self._create_claude_code_executor(main_script, skill_dir, skill_md_content)
        else:
            # Look for other Python scripts
            for script_file in scripts_dir.glob("*.py"):
                tool_name = script_file.stem.replace("-", "_")
                tools[tool_name] = self._create_claude_code_executor(script_file, skill_dir, skill_md_content)
        
        return tools
    
    def _create_claude_code_executor(self, script_path: Path, skill_dir: Path, skill_md_content: str) -> Callable:
        """
        Create executor function for Claude Code Python script.
        
        Args:
            script_path: Path to Python script
            skill_dir: Skill directory
            skill_md_content: SKILL.md content for description extraction
            
        Returns:
            Callable tool executor function
        """
        async def execute_claude_code_skill(params: Dict[str, Any]) -> Dict[str, Any]:
            """
            Execute Claude Code Python skill script.
            
            Supports common parameters:
            - topic: Research topic
            - tool: Target tool (e.g., "ChatGPT")
            - quick: Faster research
            - deep: Comprehensive research
            - sources: Source selection (auto, reddit, x, both)
            - emit: Output format (compact, json, md, context, path)
            - refresh: Bypass cache
            """
            try:
                # Build command arguments
                args = []
                
                if params.get("topic"):
                    args.append(f'"{params["topic"]}"')
                
                if params.get("tool"):
                    args.append(f'for {params["tool"]}')
                
                if params.get("quick"):
                    args.append("--quick")
                
                if params.get("deep"):
                    args.append("--deep")
                
                if params.get("sources"):
                    args.append(f"--sources={params['sources']}")
                
                if params.get("emit"):
                    args.append(f"--emit={params['emit']}")
                
                if params.get("refresh"):
                    args.append("--refresh")
                
                # Execute Python script
                cmd = ["python3", str(script_path)] + args
                
                result = subprocess.run(
                    cmd,
                    cwd=str(skill_dir),
                    capture_output=True,
                    text=True,
                    timeout=120,  # 2 minutes timeout
                )
                
                if result.returncode != 0:
                    logger.error(f"Claude Code skill execution failed: {result.stderr}")
                    return {
                        "success": False,
                        "error": result.stderr or "Script execution failed",
                        "stdout": result.stdout,
                    }
                
                # Parse output based on emit format
                if params.get("emit") == "json":
                    try:
                        output = json.loads(result.stdout)
                        return {"success": True, **output}
                    except json.JSONDecodeError:
                        return {
                            "success": True,
                            "output": result.stdout,
                            "format": "json",
                            "raw": True,
                        }
                
                return {
                    "success": True,
                    "output": result.stdout,
                    "format": params.get("emit", "compact"),
                }
            except subprocess.TimeoutExpired:
                return {
                    "success": False,
                    "error": "Script execution timed out (120s limit)",
                }
            except Exception as e:
                logger.error(f"Error executing Claude Code skill: {e}")
                return {
                    "success": False,
                    "error": str(e),
                }
        
        return execute_claude_code_skill
    
    def get_registered_tools(self) -> Dict[str, Callable]:
        """
        Get all registered tools from loaded skills.
        
        Returns:
            Dict mapping tool names to execute functions
            (for merging into Jotty's tool registry)
        """
        tools: Dict[str, Callable] = {}
        for skill in self.loaded_skills.values():
            tools.update(skill.tools)
        
        # Add package management tools
        from .skill_package_tools import create_package_management_tools
        from .skill_venv_manager import get_venv_manager
        venv_manager = get_venv_manager()
        package_tools = create_package_management_tools(venv_manager)
        tools.update(package_tools)
        
        return tools
    
    def get_tool_metadata(self) -> Dict[str, Dict[str, str]]:
        """
        Get tool metadata for all skill tools.
        
        Returns:
            Dict mapping tool names to metadata
            (for merging into Jotty's tool metadata)
        """
        metadata: Dict[str, Dict[str, str]] = {}
        
        for skill in self.loaded_skills.values():
            for tool_name in skill.tools.keys():
                metadata[tool_name] = {
                    "category": "skill",
                    "description": f"Tool from skill: {skill.name}",
                    "skill": skill.name,
                }
        
        return metadata
    
    def list_skills(self, include_composites: bool = True) -> List[Dict[str, Any]]:
        """List all registered skills without triggering lazy loading.

        Args:
            include_composites: If False, only return atomic skills (default: True)

        Returns skill metadata. Tool names are only included if tools
        have already been loaded; otherwise returns an empty list for
        the 'tools' key to avoid forcing all skills to import.
        """
        skills = []
        for skill in self.loaded_skills.values():
            # Filter composites if requested
            if not include_composites and skill.is_composite:
                continue

            # Only list tool names if already loaded â€” avoids triggering
            # lazy import of all 126+ skills' tools.py modules
            tool_names = list(skill._tools.keys()) if skill.is_loaded else []

            skill_dict = {
                "name": skill.name,
                "description": skill.description,
                "tools": tool_names,
                "metadata": skill.metadata,
                "capabilities": skill.capabilities,
                "is_composite": skill.is_composite,
                "skill_type": skill.skill_type.value,
                "base_skills": skill.base_skills,
            }
            # Add composite/derived hints
            if skill.skill_type == SkillType.COMPOSITE:
                # Backward compat: populate combines from base_skills if empty
                skill_dict["combines"] = skill.combines if skill.combines else skill.base_skills
                skill_dict["use_when"] = skill.use_when
                skill_dict["execution_mode"] = skill.execution_mode
            elif skill.skill_type == SkillType.DERIVED:
                skill_dict["use_when"] = skill.use_when
            skills.append(skill_dict)
        return skills

    def list_skills_by_type(
        self,
        skill_type: SkillType,
        max_skills: int = 0,
    ) -> List[Dict[str, Any]]:
        """
        List skills filtered by type.

        Args:
            skill_type: SkillType.BASE, SkillType.DERIVED, or SkillType.COMPOSITE
            max_skills: Maximum skills to return (0 = no limit)

        Returns:
            List of skill dicts matching the type
        """
        results = []
        for skill in self.loaded_skills.values():
            if skill.skill_type == skill_type:
                tool_names = list(skill._tools.keys()) if skill.is_loaded else []
                skill_dict = {
                    "name": skill.name,
                    "description": skill.description,
                    "tools": tool_names,
                    "capabilities": skill.capabilities,
                    "skill_type": skill.skill_type.value,
                    "base_skills": skill.base_skills,
                }
                if skill.skill_type == SkillType.COMPOSITE:
                    skill_dict["combines"] = skill.combines
                    skill_dict["execution_mode"] = skill.execution_mode
                results.append(skill_dict)

                if max_skills and len(results) >= max_skills:
                    break
        return results

    def get_skill_type_summary(self) -> Dict[str, int]:
        """Get a count of skills by type."""
        counts = {t.value: 0 for t in SkillType}
        for skill in self.loaded_skills.values():
            counts[skill.skill_type.value] += 1
        return counts

    def filter_skills_by_capabilities(
        self,
        required_capabilities: List[str],
        include_composites: bool = True,
        max_skills: int = 20
    ) -> List[Dict[str, Any]]:
        """
        Filter skills by required capabilities.

        Returns skills that match ANY of the required capabilities,
        sorted by relevance (more matching capabilities = higher priority).

        Args:
            required_capabilities: List of capabilities needed (e.g., ["data-fetch", "communicate"])
            include_composites: Whether to include composite skills (default: True)
            max_skills: Maximum number of skills to return (default: 20)

        Returns:
            List of skill dicts sorted by relevance
        """
        if not required_capabilities:
            return self.list_skills(include_composites)[:max_skills]

        required_set = set(c.lower() for c in required_capabilities)
        scored_skills = []

        for skill in self.loaded_skills.values():
            # Filter composites if requested
            if not include_composites and skill.is_composite:
                continue

            # Calculate match score
            skill_caps = set(c.lower() for c in skill.capabilities)
            matching_caps = required_set & skill_caps
            score = len(matching_caps)

            # Skills with no capabilities defined get a low default score
            # (they might still be relevant)
            if not skill.capabilities:
                score = 0.1

            if score > 0:
                tool_names = list(skill._tools.keys()) if skill.is_loaded else []
                skill_dict = {
                    "name": skill.name,
                    "description": skill.description,
                    "tools": tool_names,
                    "metadata": skill.metadata,
                    "capabilities": skill.capabilities,
                    "is_composite": skill.is_composite,
                    "skill_type": skill.skill_type.value,
                    "base_skills": skill.base_skills,
                    "_match_score": score,
                    "_matched_capabilities": list(matching_caps),
                }
                if skill.skill_type == SkillType.COMPOSITE:
                    skill_dict["combines"] = skill.combines if skill.combines else skill.base_skills
                    skill_dict["use_when"] = skill.use_when
                elif skill.skill_type == SkillType.DERIVED:
                    skill_dict["use_when"] = skill.use_when
                scored_skills.append((score, skill_dict))

        # Sort by score (descending) - higher score = more matching capabilities
        scored_skills.sort(key=lambda x: -x[0])

        # Return top skills
        return [s[1] for s in scored_skills[:max_skills]]

    def get_skill(self, name: str) -> Optional[SkillDefinition]:
        """Get a specific skill by name."""
        return self.loaded_skills.get(name)
    
    def load_collection(self, collection: 'ToolCollection', collection_name: Optional[str] = None) -> Dict[str, Callable]:
        """
        Load a tool collection into the registry.
        
        Args:
            collection: ToolCollection instance
            collection_name: Optional name for the collection (default: auto-generated)
            
        Returns:
            Dict mapping tool names to execute functions
            
        Example:
            from core.registry.tool_collection import ToolCollection
            
            collection = ToolCollection.from_hub("collection-slug", trust_remote_code=True)
            registry.load_collection(collection)
        """
        from .tool_collection import ToolCollection
        
        if not isinstance(collection, ToolCollection):
            raise TypeError(f"Expected ToolCollection, got {type(collection)}")
        
        # Generate collection name if not provided
        if collection_name is None:
            collection_name = f"collection_{len(self.loaded_collections)}"
        
        # Convert tools to SkillDefinitions
        skill_definitions = collection.to_skill_definitions()
        
        # Register each skill
        all_tools: Dict[str, Callable] = {}
        for skill_def in skill_definitions:
            if skill_def:
                # Add collection prefix to avoid conflicts
                prefixed_name = f"{collection_name}_{skill_def.name}"
                
                # Register skill
                self.loaded_skills[prefixed_name] = skill_def
                all_tools.update(skill_def.tools)
                
                logger.info(f"Loaded tool from collection: {prefixed_name}")
        
        # Store collection
        self.loaded_collections[collection_name] = {
            "collection": collection,
            "tools": all_tools,
            "source": collection.source,
            "metadata": collection.metadata
        }
        
        logger.info(f"Loaded collection '{collection_name}' with {len(skill_definitions)} tools")
        
        return all_tools
    
    def list_collections(self) -> List[Dict[str, Any]]:
        """
        List all loaded collections.
        
        Returns:
            List of collection metadata dicts
        """
        return [
            {
                "name": name,
                "source": info["source"],
                "tool_count": len(info["tools"]),
                "metadata": info["metadata"]
            }
            for name, info in self.loaded_collections.items()
        ]
    
    def get_collection(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get a loaded collection by name.
        
        Args:
            name: Collection name
            
        Returns:
            Collection info dict or None
        """
        return self.loaded_collections.get(name)
    
    # =============================================================================
    # Agent Conversion (Refactoring #4)
    # =============================================================================
    
    async def get_agent_for_skill(
        self,
        skill_name: str,
        agent_name: Optional[str] = None
    ):
        """
        Get or create AgentConfig for a skill.
        
        Args:
            skill_name: Name of skill
            agent_name: Optional custom agent name
            
        Returns:
            AgentConfig or None
        """
        try:
            from .skill_to_agent_converter import SkillToAgentConverter
            converter = SkillToAgentConverter()
            return await converter.create_agent_from_skill_name(skill_name, agent_name)
        except Exception as e:
            logger.warning(f"Failed to convert skill '{skill_name}' to agent: {e}")
            return None
    
    async def list_agents_from_skills(
        self,
        agent_name_prefix: Optional[str] = None
    ) -> List[Any]:
        """
        List all agents created from skills.
        
        Args:
            agent_name_prefix: Optional prefix for agent names
            
        Returns:
            List of AgentConfig
        """
        try:
            from .skill_to_agent_converter import SkillToAgentConverter
            converter = SkillToAgentConverter()
            
            skills = list(self.loaded_skills.values())
            return await converter.convert_skills_to_agents(skills, agent_name_prefix)
        except Exception as e:
            logger.warning(f"Failed to convert skills to agents: {e}")
            return []


# Singleton instance
_registry_instance: Optional[SkillsRegistry] = None


def get_skills_registry(skills_dir: Optional[str] = None) -> SkillsRegistry:
    """Get singleton skills registry instance (auto-initialized)."""
    global _registry_instance
    if _registry_instance is None:
        _registry_instance = SkillsRegistry(skills_dir)
        _registry_instance.init()  # Auto-initialize to load skills
    return _registry_instance
