"""
Skills Registry - DRY Implementation for Jotty Framework

Skills are dynamically loaded tools that extend agent capabilities.
This is framework-level infrastructure, reusable across all Jotty clients.

Architecture:
- Skills live in ~/jotty/skills/<name>/SKILL.md and tools.py
- Skills registry loads and registers tools dynamically
- Skills can be GENERATED by AI (like Clawd.bot) or manually written
- Tools integrate with existing Jotty tool system (no duplication)
- Clients (like JustJot.ai) use Jotty's skills system

Key Features:
- Load existing skills from disk
- Generate new skills using AI (via SkillGenerator)
- Hot-reload skills on changes
- Validate skills before registration

Note: This is framework code, not client-specific.
"""

import os
import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
import importlib.util

# Load environment variables from .env file
try:
    from dotenv import load_dotenv
    # Load .env from Jotty root directory
    current_file = Path(__file__).resolve()
    jotty_root = current_file.parent.parent.parent  # core/registry -> core -> Jotty
    env_file = jotty_root / ".env"
    if env_file.exists():
        load_dotenv(env_file, override=False)  # Don't override existing env vars
except ImportError:
    pass  # python-dotenv not available, fall back to os.getenv

logger = logging.getLogger(__name__)


# =============================================================================
# SKILL TYPE ENUM
# =============================================================================

class SkillType(Enum):
    """
    Classification of skills by their composition pattern.

    BASE:      Fundamental atomic skill. Does one thing, no dependency on other skills.
               Examples: web-search, calculator, telegram-sender, file-operations

    DERIVED:   Extends a single base skill for a specific domain.
               Has ONE primary base skill it specializes.
               Examples: stock-research (derives from web-search),
                         investing-commodities (derives from web-scraper)

    COMPOSITE: Combines 2+ base or derived skills in a workflow.
               Supports sequential, parallel, or mixed execution.
               Examples: search-summarize-pdf-telegram (web-search + claude-cli-llm +
                         document-converter + telegram-sender)
    """
    BASE = "base"
    DERIVED = "derived"
    COMPOSITE = "composite"


class TrustLevel(Enum):
    """
    Tool trust level â€” determines verification depth before execution.
    Inspired by Cline's per-tool auto-approve pattern.

    SAFE:         Read-only, no side effects. Auto-approved.
                  Examples: web-search, calculator, read-file
    SIDE_EFFECT:  Creates or modifies external state. Basic verification.
                  Examples: create-idea, send-telegram, write-file
    DESTRUCTIVE:  Irreversible actions. Full verification + user confirmation.
                  Examples: delete-file, drop-database, send-email-blast
    """
    SAFE = "safe"
    SIDE_EFFECT = "side_effect"
    DESTRUCTIVE = "destructive"


# Auto-classify trust level from skill category/tags (heuristic)
_SAFE_CATEGORIES = {'search', 'research', 'analysis', 'calculation', 'read', 'general'}
_DESTRUCTIVE_TAGS = {'delete', 'drop', 'purge', 'destroy', 'remove', 'irreversible'}


def _infer_trust_level(
    category: str, tags: List[str], name: str
) -> TrustLevel:
    """Infer trust level from skill metadata. KISS heuristic."""
    tag_set = {t.lower() for t in tags}
    if tag_set & _DESTRUCTIVE_TAGS:
        return TrustLevel.DESTRUCTIVE
    if category.lower() in _SAFE_CATEGORIES:
        return TrustLevel.SAFE
    # Side-effect keywords in name
    if any(kw in name.lower() for kw in ('send', 'create', 'write', 'post', 'update')):
        return TrustLevel.SIDE_EFFECT
    return TrustLevel.SAFE  # default: safe


# =============================================================================
# BASE SKILL CLASS
# =============================================================================

class BaseSkill:
    """
    Base class for all Jotty skills.

    Skills extend this class to gain:
    - Status callback support for progress reporting
    - Lifecycle hooks (setup, execute, cleanup)
    - Consistent interface across all skills
    - Context sharing (session, user, metadata)

    Usage:
        class ResearchSkill(BaseSkill):
            name = "research-to-pdf"
            description = "Research topics and create PDF reports"

            def setup(self):
                # Initialize resources
                pass

            async def execute(self, params: dict) -> dict:
                self.status("Searching", "ðŸ” Searching the web...")
                results = await self.search(params['query'])

                self.status("Analyzing", "ðŸ§  Analyzing results...")
                analysis = self.analyze(results)

                self.status("Creating", "ðŸ“„ Creating PDF...")
                pdf_path = self.create_pdf(analysis)

                return {"success": True, "pdf_path": pdf_path}

    The status() method emits progress updates that flow to the CLI/UI.
    """

    # Class attributes - override in subclasses
    name: str = "base-skill"
    description: str = "Base skill class"
    version: str = "1.0.0"
    category: str = "general"
    tags: List[str] = []

    def __init__(self, status_callback: Optional[Callable] = None):
        """
        Initialize skill with optional status callback.

        Args:
            status_callback: Callable(stage, detail) for progress updates
        """
        self._status_callback = status_callback
        self._context: Dict[str, Any] = {}

    def set_status_callback(self, callback: Callable):
        """Set status callback for progress reporting."""
        self._status_callback = callback

    def set_context(self, **context):
        """Set execution context (session_id, user_id, metadata, etc.)."""
        self._context.update(context)

    def status(self, stage: str, detail: str = ""):
        """
        Emit a status update for progress reporting.

        Args:
            stage: Stage name (e.g., "Searching", "Analyzing")
            detail: Detail message with emoji (e.g., "ðŸ” Searching web...")
        """
        if self._status_callback:
            try:
                self._status_callback(stage, detail)
            except Exception:
                pass
        logger.debug(f"[{self.name}] {stage}: {detail}")

    def setup(self):
        """
        Setup hook called before execution.
        Override in subclasses for initialization.
        """
        pass

    def cleanup(self):
        """
        Cleanup hook called after execution.
        Override in subclasses for resource cleanup.
        """
        pass

    async def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the skill with given parameters.

        Override in subclasses to implement skill logic.

        Args:
            params: Skill parameters

        Returns:
            Result dict with 'success' key
        """
        raise NotImplementedError("Subclasses must implement execute()")

    def get_tools(self) -> Dict[str, Callable]:
        """
        Get tool functions for this skill.

        Returns dict mapping tool names to callables.
        Default implementation wraps execute() as the main tool.
        Override for skills with multiple tools.
        """
        async def main_tool(params: dict) -> dict:
            self.setup()
            try:
                return await self.execute(params)
            finally:
                self.cleanup()

        return {f"{self.name}_tool": main_tool}

    def to_definition(self) -> "SkillDefinition":
        """Convert to SkillDefinition for registry compatibility."""
        return SkillDefinition(
            name=self.name,
            description=self.description,
            tools=self.get_tools(),
            category=self.category,
            tags=self.tags,
            version=self.version,
        )


# =============================================================================
# TOOL METADATA (Absorbed from ToolsRegistry)
# =============================================================================

@dataclass
class ToolMetadata:
    """
    Metadata for a tool within a skill.

    This consolidates ToolSchema from the old ToolsRegistry into SkillsRegistry,
    providing rich metadata for each tool including MCP support, parameters, etc.

    The SkillsRegistry is now the single source of truth for tools.
    """
    name: str  # Tool name within the skill
    description: str  # What this tool does
    category: str = "general"  # Category grouping
    mcp_enabled: bool = False  # Available via MCP protocol
    parameters: Dict[str, Any] = field(default_factory=dict)  # Parameter schema (JSON Schema)
    returns: Optional[str] = None  # Return type description
    examples: List[Dict[str, Any]] = field(default_factory=list)  # Usage examples
    tags: List[str] = field(default_factory=list)  # Searchable tags

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API responses."""
        return {
            'name': self.name,
            'description': self.description,
            'category': self.category,
            'mcp_enabled': self.mcp_enabled,
            'parameters': self.parameters,
            'returns': self.returns,
            'examples': self.examples,
            'tags': self.tags,
        }

    def to_claude_tool(self) -> Dict[str, Any]:
        """Convert to Claude API tool format."""
        return {
            'name': self.name,
            'description': self.description,
            'input_schema': {
                'type': 'object',
                'properties': self.parameters.get('properties', {}),
                'required': self.parameters.get('required', []),
            }
        }


# =============================================================================
# SKILL DEFINITION (Enhanced with Tool Metadata)
# =============================================================================

class SkillDefinition:
    """
    Definition of a skill with its tools (supports lazy loading).

    Skills are the "Hands" of the Jotty system - they represent what the
    swarm can DO. Each skill contains multiple tools with rich metadata.

    Architecture:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                       SKILL DEFINITION (Hands)                       â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
    â”‚  â”‚                          Tools                                   â”‚ â”‚
    â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚ â”‚
    â”‚  â”‚  â”‚   tool_1    â”‚  â”‚   tool_2    â”‚  â”‚   tool_N    â”‚             â”‚ â”‚
    â”‚  â”‚  â”‚  callable   â”‚  â”‚  callable   â”‚  â”‚  callable   â”‚             â”‚ â”‚
    â”‚  â”‚  â”‚  metadata   â”‚  â”‚  metadata   â”‚  â”‚  metadata   â”‚             â”‚ â”‚
    â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚ â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
    â”‚  Metadata: name, description, category, path, mcp_enabled, tags     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    """

    def __init__(
        self,
        name: str,
        description: str,
        tools: Optional[Dict[str, Callable]] = None,
        metadata: Optional[Dict[str, Any]] = None,
        _tool_loader: Optional[Callable] = None,
        # Tool metadata for each tool
        tool_metadata: Optional[Dict[str, ToolMetadata]] = None,
        # Skill-level attributes
        category: str = "general",
        mcp_enabled: bool = False,
        tags: Optional[List[str]] = None,
        version: str = "1.0.0",
        # Discovery fields
        capabilities: Optional[List[str]] = None,
        use_when: Optional[str] = None,
        # Skill type classification (base/derived/composite)
        skill_type: Optional[SkillType] = None,
        base_skills: Optional[List[str]] = None,
        execution_mode: Optional[str] = None,
        # Trust level (Cline auto-approve pattern)
        trust_level: Optional[TrustLevel] = None,
        # Context gate (Cline contextRequirements pattern)
        # Callable that takes task_context dict â†’ bool (should skill be available?)
        context_gate: Optional[Callable] = None,
        # Executor surface classification (browser, terminal, web_search, etc.)
        executor_type: Optional[str] = None,
    ):
        self.name = name
        self.description = description
        self._tools = tools  # None until loaded (lazy) or pre-populated (eager)
        self._tool_loader = _tool_loader  # Callable that returns Dict[str, Callable]
        self.metadata = metadata or {}

        # Enhanced metadata from ToolsRegistry patterns
        self._tool_metadata: Dict[str, ToolMetadata] = tool_metadata or {}
        self.category = category
        self.mcp_enabled = mcp_enabled
        self.tags = tags or []
        self.version = version

        # Discovery fields
        # capabilities: What this skill can do (e.g., ["data-fetch", "communicate"])
        # use_when: Natural language hint for when to use this skill
        self.capabilities = capabilities or []
        self.use_when = use_when or ""

        # Skill type classification
        # skill_type: BASE | DERIVED | COMPOSITE (see SkillType enum)
        # base_skills: List of skills this depends on (derived: 1, composite: 2+)
        # execution_mode: For composite skills - "sequential", "parallel", or "mixed"
        self.skill_type = skill_type or SkillType.BASE
        self.base_skills = base_skills or []
        self.execution_mode = execution_mode or ""

        # Trust level: determines verification depth before execution.
        # Auto-inferred from category/tags if not explicitly set.
        self.trust_level = trust_level or _infer_trust_level(
            category, self.tags, name
        )

        # Context gate: optional function(task_context) â†’ bool.
        # When set, skill is only available when gate returns True.
        # Example: browser skill only available when headless browser is configured.
        self.context_gate = context_gate

        # Executor type: classifies which execution surface this skill targets.
        # Auto-inferred from name/category/tags when not explicitly provided.
        self.executor_type = executor_type or self._infer_executor_type(
            name, category, self.tags
        )

    @staticmethod
    def _infer_executor_type(name: str, category: str, tags: List[str]) -> str:
        """Infer executor surface from skill name, category, and tags."""
        combined = f"{name} {category} {' '.join(tags)}".lower()
        if any(kw in combined for kw in ('browser', 'scrape', 'playwright', 'selenium', 'headless')):
            return 'browser'
        if any(kw in combined for kw in ('shell', 'terminal', 'exec', 'bash', 'command')):
            return 'terminal'
        if any(kw in combined for kw in ('search', 'web-search', 'google', 'bing', 'serp')):
            return 'web_search'
        if any(kw in combined for kw in ('pdf', 'doc', 'report', 'document', 'markdown')):
            return 'doc_gen'
        if any(kw in combined for kw in ('telegram', 'slack', 'discord', 'whatsapp', 'email', 'messaging', 'notification')):
            return 'messaging'
        if any(kw in combined for kw in ('code', 'python', 'javascript', 'compile', 'lint')):
            return 'code'
        if any(kw in combined for kw in ('data', 'csv', 'sql', 'database', 'analytics', 'chart', 'stock')):
            return 'data'
        if any(kw in combined for kw in ('llm', 'claude', 'openai', 'groq', 'generate', 'summarize')):
            return 'llm'
        return 'general'

    @property
    def tools(self) -> Dict[str, Callable]:
        """Lazy-load tools on first access."""
        if self._tools is None:
            if self._tool_loader:
                try:
                    self._tools = self._tool_loader()
                    logger.debug(f"Lazy-loaded {len(self._tools)} tools for skill '{self.name}'")
                except Exception as e:
                    logger.error(f"Failed to lazy-load tools for skill '{self.name}': {e}")
                    self._tools = {}
            else:
                self._tools = {}
        return self._tools

    @tools.setter
    def tools(self, value: Dict[str, Callable]):
        self._tools = value

    def get_tool_metadata(self, tool_name: str) -> Optional[ToolMetadata]:
        """Get metadata for a specific tool."""
        return self._tool_metadata.get(tool_name)

    def set_tool_metadata(self, tool_name: str, metadata: ToolMetadata):
        """Set metadata for a specific tool."""
        self._tool_metadata[tool_name] = metadata

    def list_tools(self) -> List[str]:
        """List all tool names in this skill (triggers lazy load)."""
        return list(self.tools.keys())

    @property
    def is_loaded(self) -> bool:
        """Check if tools have been loaded without triggering lazy loading."""
        return self._tools is not None

    def get_tool(self, tool_name: str) -> Optional[Callable]:
        """Get a specific tool callable."""
        return self.tools.get(tool_name)

    def is_available(self, task_context: Optional[Dict[str, Any]] = None) -> bool:
        """Check if this skill is available for the given task context.

        Evaluates the context_gate (Cline's contextRequirements pattern).
        Skills without a gate are always available.
        """
        if self.context_gate is None:
            return True
        try:
            return bool(self.context_gate(task_context or {}))
        except Exception:
            return True  # Fail open â€” don't block execution on gate errors

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API responses."""
        result = {
            'name': self.name,
            'description': self.description,
            'category': self.category,
            'mcp_enabled': self.mcp_enabled,
            'tags': self.tags,
            'version': self.version,
            'tools': self.list_tools(),
            'tool_count': len(self.tools),
            'metadata': self.metadata,
            'capabilities': self.capabilities,
            'skill_type': self.skill_type.value,
            'base_skills': self.base_skills,
            'trust_level': self.trust_level.value,
            'executor_type': self.executor_type,
        }
        if self.skill_type == SkillType.COMPOSITE:
            result['execution_mode'] = self.execution_mode
        if self.use_when:
            result['use_when'] = self.use_when
        return result

    def to_claude_tools(self) -> List[Dict[str, Any]]:
        """Convert all tools to Claude API tool format."""
        claude_tools = []
        for tool_name in self.list_tools():
            meta = self._tool_metadata.get(tool_name)
            if meta:
                claude_tools.append(meta.to_claude_tool())
            else:
                # Generate basic tool definition from callable
                tool = self.tools.get(tool_name)
                if tool:
                    doc = tool.__doc__ or f"Tool: {tool_name}"
                    claude_tools.append({
                        'name': tool_name,
                        'description': doc.strip().split('\n')[0],
                        'input_schema': {'type': 'object', 'properties': {}},
                    })
        return claude_tools


class SkillsRegistry:
    """
    Skills Registry for Jotty Framework
    
    Loads skills from disk and registers tools dynamically.
    Integrates with Jotty's existing tool system (no duplication).
    
    Supports both:
    - Manual skills (written by developers)
    - AI-generated skills (created on-demand via SkillGenerator)
    """
    
    def __init__(self, skills_dir: Optional[str] = None, skill_generator=None):
        """
        Initialize skills registry.
        
        Args:
            skills_dir: Directory containing skills (default: ~/jotty/skills)
            skill_generator: Optional SkillGenerator for AI-powered skill creation
        """
        if skills_dir is None:
            # Priority: env var > repo-relative > user home
            skills_dir = os.getenv("JOTTY_SKILLS_DIR")
            
            if not skills_dir:
                # Try repo-relative (for development)
                # __file__ is core/registry/skills_registry.py
                # Go up: core/registry -> core -> Jotty -> skills
                current_file = Path(__file__).resolve()
                repo_root = current_file.parent.parent.parent  # core/registry -> core -> Jotty
                repo_skills = repo_root / "skills"
                if repo_skills.exists() or repo_root.name == "Jotty":
                    # Create if doesn't exist (we're in repo)
                    repo_skills.mkdir(exist_ok=True)
                    skills_dir = str(repo_skills)
                else:
                    # Fallback to user home (for installed packages)
                    home = os.path.expanduser("~")
                    skills_dir = os.path.join(home, "jotty", "skills")
        
        self.skills_dir = Path(skills_dir)
        self.skills_dir.mkdir(parents=True, exist_ok=True)
        
        # Also check Claude Code skills directory (~/.claude/skills)
        self.claude_skills_dir = Path.home() / ".claude" / "skills"
        
        self.loaded_skills: Dict[str, SkillDefinition] = {}
        self.composite_skills: Dict[str, Any] = {}  # Store composite skills
        self.loaded_collections: Dict[str, Any] = {}  # Store loaded tool collections
        self.initialized = False
        self.skill_generator = skill_generator  # For AI-powered skill generation
        
        # Dependency management
        from .skill_dependency_manager import get_dependency_manager
        self.dependency_manager = get_dependency_manager()
    
    # Top skills by usage (referenced by most derived/composite skills)
    # Pre-warming these saves 1-3s on first task execution
    _TOP_SKILLS = [
        'web-search', 'claude-cli-llm', 'calculator',
        'file-operations', 'document-converter',
    ]

    def init(self) -> None:
        """Initialize registry by scanning skill directories for metadata only.

        Tools are NOT imported here - they are lazy-loaded on first access
        via SkillDefinition.tools property. This makes init() fast (no imports,
        no subprocess calls, no dependency checks).

        After metadata scan, starts background pre-warming of top 5 skills
        so they're ready when first task runs.
        """
        if self.initialized:
            return

        self._scan_skills_metadata()
        self.initialized = True
        logger.info(f"SkillsRegistry initialized with {len(self.loaded_skills)} skills (lazy)")

        # Pre-warm top skills in background thread (non-blocking)
        self._prewarm_top_skills()

    def _prewarm_top_skills(self) -> None:
        """Load tools for top skills in a background thread.

        These 5 skills are used in ~80% of tasks. Pre-warming them
        removes 1-3s from the first task's critical path.
        """
        import threading

        def _warm():
            for name in self._TOP_SKILLS:
                skill = self.loaded_skills.get(name)
                if skill and not skill.is_loaded:
                    try:
                        _ = skill.tools  # Triggers lazy load
                    except Exception as e:
                        logger.debug(f"Pre-warm {name} failed: {e}")

        threading.Thread(target=_warm, daemon=True, name="skill-prewarm").start()

    def _scan_skills_metadata(self) -> None:
        """Scan skill directories and register lazy SkillDefinitions (metadata only)."""
        excluded_dirs = {'composite-templates', '__pycache__', '.git', '.DS_Store'}

        # Scan Jotty skills directory
        if self.skills_dir.exists():
            for skill_dir in self.skills_dir.iterdir():
                if skill_dir.is_dir() and skill_dir.name not in excluded_dirs:
                    try:
                        skill = self._register_lazy_skill(skill_dir.name, self.skills_dir)
                        if skill:
                            self.loaded_skills[skill.name] = skill
                    except Exception as e:
                        logger.error(f"Failed to register skill {skill_dir.name}: {e}")
        else:
            logger.warning(f"Skills directory not found: {self.skills_dir}")

        # Scan Claude Code skills directory
        if self.claude_skills_dir.exists():
            for skill_dir in self.claude_skills_dir.iterdir():
                if skill_dir.is_dir() and skill_dir.name not in excluded_dirs:
                    if skill_dir.name in self.loaded_skills:
                        logger.debug(f"Skipping {skill_dir.name} from Claude directory (already registered)")
                        continue
                    try:
                        skill = self._register_lazy_skill(skill_dir.name, self.claude_skills_dir)
                        if skill:
                            self.loaded_skills[skill.name] = skill
                    except Exception as e:
                        logger.error(f"Failed to register Claude Code skill {skill_dir.name}: {e}")

    def _register_lazy_skill(self, skill_name: str, base_dir: Path) -> Optional[SkillDefinition]:
        """Register a skill with metadata only - tools loaded lazily on first access."""
        skill_dir = base_dir / skill_name
        skill_md = skill_dir / "SKILL.md"
        tools_py = skill_dir / "tools.py"
        scripts_dir = skill_dir / "scripts"

        is_claude_code_skill = scripts_dir.exists() and scripts_dir.is_dir()

        if not tools_py.exists() and not is_claude_code_skill:
            logger.debug(f"Skipping {skill_name}: no tools.py or scripts/")
            return None

        # Parse SKILL.md for full metadata including capabilities
        skill_metadata = self._parse_skill_metadata(skill_md)

        # Create a loader closure that captures the skill directory info
        registry = self  # capture reference for closure
        def make_tool_loader(s_dir, s_name, is_cc_skill, s_md):
            def loader() -> Dict[str, Callable]:
                # Dependency check deferred to first tool load
                dep_result = registry.dependency_manager.ensure_skill_dependencies(s_name, s_dir)
                if dep_result["success"] and dep_result.get("installed"):
                    logger.info(f"Installed dependencies for {s_name}: {dep_result['installed']}")
                elif not dep_result["success"]:
                    logger.warning(f"Dependency install failed for {s_name}: {dep_result.get('error')}")

                if is_cc_skill:
                    md_content = s_md.read_text() if s_md.exists() else ""
                    return registry._load_claude_code_skill(s_dir, s_name, md_content)
                else:
                    tools_file = s_dir / "tools.py"
                    if tools_file.exists():
                        return registry._load_tools_from_file(tools_file)
                    return {}
            return loader

        # Resolve SkillType from parsed metadata
        parsed_type = skill_metadata.get('skill_type')
        resolved_skill_type = None
        if parsed_type == 'base':
            resolved_skill_type = SkillType.BASE
        elif parsed_type == 'derived':
            resolved_skill_type = SkillType.DERIVED
        elif parsed_type == 'composite':
            resolved_skill_type = SkillType.COMPOSITE

        return SkillDefinition(
            name=skill_name,
            description=skill_metadata['description'] or f"Skill: {skill_name}",
            _tool_loader=make_tool_loader(skill_dir, skill_name, is_claude_code_skill, skill_md),
            metadata={"path": str(skill_dir), "is_claude_code_skill": is_claude_code_skill},
            capabilities=skill_metadata['capabilities'],
            use_when=skill_metadata['use_when'],
            skill_type=resolved_skill_type,
            base_skills=skill_metadata['base_skills'],
            execution_mode=skill_metadata.get('execution_mode', ''),
        )

    def _parse_skill_metadata(self, skill_md: Path) -> Dict[str, Any]:
        """
        Parse SKILL.md for metadata including type classification and capabilities.

        Extracts:
        - description: What the skill does
        - skill_type: "base", "derived", or "composite"
        - base_skills: Skills this depends on (derived: 1, composite: 2+)
        - execution_mode: "sequential", "parallel", "mixed" (composite only)
        - capabilities: List of capabilities (e.g., ["data-fetch", "communicate"])
        - use_when: Natural language hint for when to use this skill

        SKILL.md format:
        ```
        # Skill Name

        Description text here.

        ## Type
        base

        ## Base Skills
        - web-search
        - claude-cli-llm

        ## Execution
        sequential

        ## Capabilities
        - data-fetch
        - communicate

        ## Use When
        User wants weather sent to Telegram
        ```
        """
        metadata = {
            'description': '',
            'skill_type': None,  # None = not specified, will default to BASE
            'base_skills': [],
            'execution_mode': '',
            'capabilities': [],
            'use_when': '',
        }

        if not skill_md.exists():
            return metadata

        try:
            content = skill_md.read_text()
            lines = content.split("\n")

            title = ""
            current_section = None

            for i, line in enumerate(lines):
                stripped = line.strip()

                # Get title from first heading
                if line.startswith("# ") and not title:
                    title = line[2:].strip()
                    # Find description: first non-empty line after title that isn't a heading
                    for j in range(i + 1, min(i + 5, len(lines))):
                        next_line = lines[j].strip()
                        if next_line and not next_line.startswith("#") and not next_line.startswith("---"):
                            metadata['description'] = next_line
                            break
                    continue

                # Detect section headers
                if stripped.lower() in ["## description", "**description**", "description:"]:
                    current_section = 'description'
                    continue
                elif stripped.lower() in ["## type", "**type**", "type:"]:
                    current_section = 'type'
                    continue
                elif stripped.lower() in ["## base skills", "**base skills**", "base skills:",
                                          "## base skill", "**base skill**", "base skill:"]:
                    current_section = 'base_skills'
                    continue
                elif stripped.lower() in ["## execution", "**execution**", "execution:",
                                          "## execution mode", "**execution mode**"]:
                    current_section = 'execution'
                    continue
                elif stripped.lower() in ["## capabilities", "**capabilities**", "capabilities:"]:
                    current_section = 'capabilities'
                    continue
                elif stripped.lower() in ["## use when", "**use when**", "use when:"]:
                    current_section = 'use_when'
                    continue
                elif stripped.startswith("##") or stripped.startswith("**"):
                    current_section = None  # End of relevant sections
                    continue

                # Parse section content
                if current_section == 'description' and stripped:
                    if metadata['description']:
                        metadata['description'] += " " + stripped
                    else:
                        metadata['description'] = stripped

                elif current_section == 'type' and stripped:
                    type_val = stripped.lower().strip()
                    if type_val in ('base', 'derived', 'composite'):
                        metadata['skill_type'] = type_val

                elif current_section == 'base_skills' and stripped.startswith("-"):
                    skill_ref = stripped[1:].strip()
                    if skill_ref:
                        metadata['base_skills'].append(skill_ref)

                elif current_section == 'execution' and stripped:
                    mode_val = stripped.lower().strip()
                    if mode_val in ('sequential', 'parallel', 'mixed'):
                        metadata['execution_mode'] = mode_val

                elif current_section == 'capabilities' and stripped.startswith("-"):
                    cap = stripped[1:].strip().lower()
                    if cap:
                        metadata['capabilities'].append(cap)

                elif current_section == 'use_when' and stripped:
                    if metadata['use_when']:
                        metadata['use_when'] += " " + stripped
                    else:
                        metadata['use_when'] = stripped

            # Fallback description to title
            if not metadata['description']:
                metadata['description'] = title

            # Truncate description
            metadata['description'] = metadata['description'][:500]

            # Auto-infer use_when from description if not provided
            # This gives the LLM a selection hint without requiring manual SKILL.md edits
            if not metadata['use_when'] and metadata['description']:
                desc = metadata['description']
                # Strip markdown formatting and truncate
                clean = desc.replace('**', '').replace('*', '').strip()
                if len(clean) > 10:
                    metadata['use_when'] = clean[:120]

            # Infer skill_type from base_skills if not explicitly set
            if metadata['skill_type'] is None:
                if len(metadata['base_skills']) == 1:
                    metadata['skill_type'] = 'derived'
                elif len(metadata['base_skills']) >= 2:
                    metadata['skill_type'] = 'composite'
                # else: leave as None, will default to BASE

        except Exception as e:
            logger.debug(f"Could not parse {skill_md}: {e}")

        return metadata

    def _read_skill_description(self, skill_md: Path) -> str:
        """Read description from SKILL.md (lightweight metadata parsing)."""
        metadata = self._parse_skill_metadata(skill_md)
        return metadata['description']

    def load_all_skills(self) -> Dict[str, Callable]:
        """
        Eagerly load all skills and return tools.

        This forces all lazy skills to load their tools immediately.
        Prefer using init() + lazy access for better startup performance.
        """
        self.init()  # Ensure metadata is scanned
        all_tools: Dict[str, Callable] = {}
        for skill in self.loaded_skills.values():
            all_tools.update(skill.tools)  # Triggers lazy load
        return all_tools
    
    def _load_skill(self, skill_name: str, base_dir: Optional[Path] = None) -> SkillDefinition:
        """
        Eagerly load a single skill from disk (tools imported immediately).

        Used by load_collection and other callers that need tools right away.
        For lazy loading, use _register_lazy_skill() instead.
        """
        if base_dir is None:
            base_dir = self.skills_dir

        skill_dir = base_dir / skill_name
        skill_md = skill_dir / "SKILL.md"
        tools_py = skill_dir / "tools.py"
        scripts_dir = skill_dir / "scripts"

        is_claude_code_skill = scripts_dir.exists() and scripts_dir.is_dir()

        if not tools_py.exists() and not is_claude_code_skill:
            raise FileNotFoundError(f"Skill {skill_name} missing tools.py and no scripts/ directory found")

        description = self._read_skill_description(skill_md)

        # Load tools eagerly
        if is_claude_code_skill:
            content = skill_md.read_text() if skill_md.exists() else ""
            tools = self._load_claude_code_skill(skill_dir, skill_name, content)
        elif tools_py.exists():
            tools = self._load_tools_from_file(tools_py)
        else:
            tools = {}

        return SkillDefinition(
            name=skill_name,
            description=description or f"Skill: {skill_name}",
            tools=tools,
            metadata={"path": str(skill_dir), "is_claude_code_skill": is_claude_code_skill}
        )
    
    def _load_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Load tools from a Python file.
        
        For TypeScript/JavaScript skills, would need compilation step.
        This is a simplified version for Python tools.
        
        Args:
            tools_file: Path to tools.py file
            
        Returns:
            Dict mapping tool names to execute functions
        """
        tools: Dict[str, Callable] = {}
        
        try:
            # Add venv site-packages to sys.path if available
            import sys
            if hasattr(self, 'dependency_manager') and self.dependency_manager:
                venv_manager = self.dependency_manager.venv_manager
                if venv_manager and venv_manager.shared_venv_path:
                    # Detect Python version dynamically
                    python_version = f"{sys.version_info.major}.{sys.version_info.minor}"
                    venv_site_packages = venv_manager.shared_venv_path / 'lib' / f'python{python_version}' / 'site-packages'
                    
                    # If not found, try to find any pythonX.Y directory
                    if not venv_site_packages.exists():
                        lib_dir = venv_manager.shared_venv_path / 'lib'
                        if lib_dir.exists():
                            for subdir in lib_dir.iterdir():
                                if subdir.is_dir() and subdir.name.startswith('python'):
                                    potential_site_packages = subdir / 'site-packages'
                                    if potential_site_packages.exists():
                                        venv_site_packages = potential_site_packages
                                        break
                    
                    if venv_site_packages.exists() and str(venv_site_packages) not in sys.path:
                        sys.path.insert(0, str(venv_site_packages))
                        logger.debug(f"Added venv site-packages to sys.path: {venv_site_packages}")
            
            # Dynamically import the module
            spec = importlib.util.spec_from_file_location("skill_tools", tools_file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Extract tool functions (functions decorated with @tool or named *_tool)
                for attr_name in dir(module):
                    if not attr_name.startswith("_"):
                        attr = getattr(module, attr_name)
                        if callable(attr):
                            # Check if it's a tool (has execute method or is tool-like)
                            if hasattr(attr, "execute") or attr_name.endswith("_tool"):
                                tools[attr_name] = attr
        except Exception as e:
            logger.error(f"Error loading tools from {tools_file}: {e}")

            # Retry once with isolated import (handles missing imports at module level)
            retry_tools = self._retry_load_with_isolation(tools_file, e)
            if retry_tools:
                logger.info(f"âœ… Retry succeeded for {tools_file.parent.name}: {len(retry_tools)} tools loaded")
                return retry_tools

            # Track failed skills for diagnostics
            if not hasattr(self, '_failed_skills'):
                self._failed_skills = {}
            skill_name = tools_file.parent.name
            self._failed_skills[skill_name] = str(e)
            logger.warning(f"âš ï¸ Skill '{skill_name}' failed to load: {e}. "
                          f"Fix: check imports in {tools_file}")

            # Fallback: create mock tools based on file content
            tools = self._create_mock_tools_from_file(tools_file)
        
        return tools
    
    def _retry_load_with_isolation(self, tools_file: Path, original_error: Exception) -> Optional[Dict[str, Callable]]:
        """
        Retry loading a tools module after attempting to fix common import issues.
        
        Common issues:
        - Missing SkillStatus import â†’ inject it before retrying
        - Missing optional dependencies â†’ skip gracefully
        """
        import sys
        import importlib.util
        
        try:
            # Read the source to check for common fixable issues
            source = tools_file.read_text()
            error_str = str(original_error)
            
            # If the error is a NameError for a known symbol, try injecting it
            if 'SkillStatus' in error_str and 'SkillStatus' not in source.split('import')[-1] if 'import' in source else True:
                logger.info(f"Retrying {tools_file.parent.name} with SkillStatus injection...")
                
                # Load with the missing name pre-injected
                spec = importlib.util.spec_from_file_location(
                    f"skill_tools_retry_{tools_file.parent.name}", tools_file
                )
                if spec and spec.loader:
                    module = importlib.util.module_from_spec(spec)
                    # Pre-inject SkillStatus
                    try:
                        from ..utils.skill_status import SkillStatus
                        module.SkillStatus = SkillStatus
                    except ImportError:
                        pass
                    
                    spec.loader.exec_module(module)
                    
                    tools = {}
                    for attr_name in dir(module):
                        if not attr_name.startswith("_"):
                            attr = getattr(module, attr_name)
                            if callable(attr):
                                if hasattr(attr, "execute") or attr_name.endswith("_tool"):
                                    tools[attr_name] = attr
                    if tools:
                        return tools
        except Exception as retry_e:
            logger.debug(f"Retry also failed for {tools_file.parent.name}: {retry_e}")
        
        return None
    
    def get_failed_skills(self) -> Dict[str, str]:
        """Return dict of skill_name -> error_message for skills that failed to load."""
        return getattr(self, '_failed_skills', {})
    
    def _create_mock_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Create mock tools from file content (for testing/fallback).
        
        In production, proper tool loading would be used.
        This is for testing integration only.
        """
        content = tools_file.read_text()
        tools: Dict[str, Callable] = {}
        
        # Extract tool names from file (simplified)
        import re
        tool_matches = re.findall(r'def\s+(\w+)\s*\(|(\w+)\s*=\s*tool\(', content)
        
        for match in tool_matches:
            tool_name = match[0] or match[1]
            if tool_name:
                # Create mock execute function
                tools[tool_name] = self._create_mock_executor(tool_name)
        
        return tools
    
    def _create_mock_executor(self, tool_name: str) -> Callable:
        """Create mock executor for testing."""
        async def mock_execute(params: Dict[str, Any]) -> Dict[str, Any]:
            return {
                "success": True,
                "tool": tool_name,
                "params": params,
                "message": f"Tool {tool_name} executed (mock - implement in tools.py)",
            }
        return mock_execute
    
    def _load_claude_code_skill(self, skill_dir: Path, skill_name: str, skill_md_content: str) -> Dict[str, Callable]:
        """
        Load Python-based Claude Code skill (e.g., last30days).
        
        Claude Code skills have Python scripts in scripts/ directory instead of tools.py.
        This method creates wrapper tools that execute the Python scripts.
        
        Args:
            skill_dir: Skill directory path
            skill_name: Skill name
            skill_md_content: Content of SKILL.md for metadata extraction
            
        Returns:
            Dict mapping tool names to execute functions
        """
        tools: Dict[str, Callable] = {}
        scripts_dir = skill_dir / "scripts"
        
        if not scripts_dir.exists():
            logger.warning(f"Claude Code skill {skill_name} has no scripts/ directory")
            return tools
        
        # Look for main script (skill_name.py) or any .py files
        main_script = scripts_dir / f"{skill_name}.py"
        
        if main_script.exists():
            # Create wrapper tool for main script
            tool_name = skill_name.replace("-", "_")
            tools[tool_name] = self._create_claude_code_executor(main_script, skill_dir, skill_md_content)
        else:
            # Look for other Python scripts
            for script_file in scripts_dir.glob("*.py"):
                tool_name = script_file.stem.replace("-", "_")
                tools[tool_name] = self._create_claude_code_executor(script_file, skill_dir, skill_md_content)
        
        return tools
    
    def _create_claude_code_executor(self, script_path: Path, skill_dir: Path, skill_md_content: str) -> Callable:
        """
        Create executor function for Claude Code Python script.
        
        Args:
            script_path: Path to Python script
            skill_dir: Skill directory
            skill_md_content: SKILL.md content for description extraction
            
        Returns:
            Callable tool executor function
        """
        async def execute_claude_code_skill(params: Dict[str, Any]) -> Dict[str, Any]:
            """
            Execute Claude Code Python skill script.
            
            Supports common parameters:
            - topic: Research topic
            - tool: Target tool (e.g., "ChatGPT")
            - quick: Faster research
            - deep: Comprehensive research
            - sources: Source selection (auto, reddit, x, both)
            - emit: Output format (compact, json, md, context, path)
            - refresh: Bypass cache
            """
            try:
                # Build command arguments
                args = []
                
                if params.get("topic"):
                    args.append(f'"{params["topic"]}"')
                
                if params.get("tool"):
                    args.append(f'for {params["tool"]}')
                
                if params.get("quick"):
                    args.append("--quick")
                
                if params.get("deep"):
                    args.append("--deep")
                
                if params.get("sources"):
                    args.append(f"--sources={params['sources']}")
                
                if params.get("emit"):
                    args.append(f"--emit={params['emit']}")
                
                if params.get("refresh"):
                    args.append("--refresh")
                
                # Execute Python script
                cmd = ["python3", str(script_path)] + args
                
                result = subprocess.run(
                    cmd,
                    cwd=str(skill_dir),
                    capture_output=True,
                    text=True,
                    timeout=120,  # 2 minutes timeout
                )
                
                if result.returncode != 0:
                    logger.error(f"Claude Code skill execution failed: {result.stderr}")
                    return {
                        "success": False,
                        "error": result.stderr or "Script execution failed",
                        "stdout": result.stdout,
                    }
                
                # Parse output based on emit format
                if params.get("emit") == "json":
                    try:
                        output = json.loads(result.stdout)
                        return {"success": True, **output}
                    except json.JSONDecodeError:
                        return {
                            "success": True,
                            "output": result.stdout,
                            "format": "json",
                            "raw": True,
                        }
                
                return {
                    "success": True,
                    "output": result.stdout,
                    "format": params.get("emit", "compact"),
                }
            except subprocess.TimeoutExpired:
                return {
                    "success": False,
                    "error": "Script execution timed out (120s limit)",
                }
            except Exception as e:
                logger.error(f"Error executing Claude Code skill: {e}")
                return {
                    "success": False,
                    "error": str(e),
                }
        
        return execute_claude_code_skill
    
    def get_registered_tools(self) -> Dict[str, Callable]:
        """
        Get all registered tools from loaded skills.
        
        Returns:
            Dict mapping tool names to execute functions
            (for merging into Jotty's tool registry)
        """
        tools: Dict[str, Callable] = {}
        for skill in self.loaded_skills.values():
            tools.update(skill.tools)
        
        # Add package management tools
        from .skill_package_tools import create_package_management_tools
        from .skill_venv_manager import get_venv_manager
        venv_manager = get_venv_manager()
        package_tools = create_package_management_tools(venv_manager)
        tools.update(package_tools)
        
        return tools
    
    def get_tool_metadata(self) -> Dict[str, Dict[str, str]]:
        """
        Get tool metadata for all skill tools.
        
        Returns:
            Dict mapping tool names to metadata
            (for merging into Jotty's tool metadata)
        """
        metadata: Dict[str, Dict[str, str]] = {}
        
        for skill in self.loaded_skills.values():
            for tool_name in skill.tools.keys():
                metadata[tool_name] = {
                    "category": "skill",
                    "description": f"Tool from skill: {skill.name}",
                    "skill": skill.name,
                }
        
        return metadata
    
    def list_skills(self, filter_type: Optional[SkillType] = None) -> List[Dict[str, Any]]:
        """List all registered skills without triggering lazy loading.

        Args:
            filter_type: Optional SkillType to filter by (default: None = all)

        Returns skill metadata. Tool names are only included if tools
        have already been loaded; otherwise returns an empty list for
        the 'tools' key to avoid forcing all skills to import.
        """
        skills = []
        for skill in self.loaded_skills.values():
            if filter_type is not None and skill.skill_type != filter_type:
                continue

            # Only list tool names if already loaded â€” avoids triggering
            # lazy import of all 126+ skills' tools.py modules
            tool_names = list(skill._tools.keys()) if skill.is_loaded else []

            skill_dict = {
                "name": skill.name,
                "description": skill.description,
                "tools": tool_names,
                "metadata": skill.metadata,
                "capabilities": skill.capabilities,
                "skill_type": skill.skill_type.value,
                "base_skills": skill.base_skills,
            }
            if skill.skill_type == SkillType.COMPOSITE:
                skill_dict["execution_mode"] = skill.execution_mode
            if skill.use_when:
                skill_dict["use_when"] = skill.use_when
            skills.append(skill_dict)
        return skills

    def list_skills_by_type(
        self,
        skill_type: SkillType,
        max_skills: int = 0,
    ) -> List[Dict[str, Any]]:
        """
        List skills filtered by type.

        Args:
            skill_type: SkillType.BASE, SkillType.DERIVED, or SkillType.COMPOSITE
            max_skills: Maximum skills to return (0 = no limit)

        Returns:
            List of skill dicts matching the type
        """
        results = self.list_skills(filter_type=skill_type)
        if max_skills:
            return results[:max_skills]
        return results

    def get_skill_type_summary(self) -> Dict[str, int]:
        """Get a count of skills by type."""
        counts = {t.value: 0 for t in SkillType}
        for skill in self.loaded_skills.values():
            counts[skill.skill_type.value] += 1
        return counts

    def discover(
        self, task: str, max_results: int = 50,
        task_context: Optional[Dict[str, Any]] = None,
    ) -> List[Dict[str, Any]]:
        """
        Discover relevant skills for a task using keyword + capability scoring.

        This is THE single discovery method. Scores each skill by:
        - Name keyword match (+3 per word)
        - Description keyword match (+1 per word)
        - Capability keyword match (+2 per capability)
        - Type boost: composite +2, derived +1

        Context gates (Cline's contextRequirements pattern):
        Skills with a context_gate are only included when the gate returns True
        for the given task_context. This allows conditional tool availability
        (e.g., browser skills only when headless browser is available).

        Returns all matched skills sorted by score, padded with unmatched
        skills up to max_results so the LLM has diverse options.

        Args:
            task: Task description
            max_results: Maximum skills to return (default: 50)
            task_context: Optional dict for context_gate evaluation

        Returns:
            List of skill dicts sorted by relevance score (descending)
        """
        task_lower = task.lower()

        stop_words = {
            'the', 'and', 'for', 'with', 'how', 'what', 'are', 'is',
            'to', 'of', 'in', 'on', 'a', 'an',
        }
        task_words = set(
            w for w in task_lower.split()
            if len(w) > 2 and w not in stop_words
        )
        # Simple stemming: "slides" -> "slide"
        stemmed = set(task_words)
        for w in task_words:
            if w.endswith('s') and len(w) > 3:
                stemmed.add(w[:-1])

        scored = []
        unmatched = []

        for skill in self.loaded_skills.values():
            # Context gate filter: skip skills whose gate says "not available"
            if not skill.is_available(task_context):
                continue

            name_lower = skill.name.lower()
            desc_lower = (skill.description or '').lower()

            score = 0
            for word in stemmed:
                if word in name_lower:
                    score += 3
                if word in desc_lower:
                    score += 1

            # Capability match: boost if any capability keyword appears in task
            for cap in skill.capabilities:
                if cap.lower() in task_lower:
                    score += 2

            if score > 0:
                # Type boost: pre-built workflows and specialized skills are preferred
                if skill.skill_type == SkillType.COMPOSITE:
                    score += 2
                elif skill.skill_type == SkillType.DERIVED:
                    score += 1

                scored.append((score, skill))
            else:
                unmatched.append(skill)

        # Sort matched by score descending
        scored.sort(key=lambda x: -x[0])

        # Build output: matched first, then unmatched to fill up
        results = []
        for score, skill in scored:
            results.append(self._skill_to_discovery_dict(skill, score))

        for skill in unmatched:
            if len(results) >= max_results:
                break
            results.append(self._skill_to_discovery_dict(skill, 0))

        return results[:max_results]

    def _skill_to_discovery_dict(self, skill: 'SkillDefinition', score: int = 0) -> Dict[str, Any]:
        """Convert a SkillDefinition to a dict for discovery output."""
        tool_names = list(skill._tools.keys()) if skill.is_loaded else []
        d = {
            'name': skill.name,
            'description': skill.description or skill.name,
            'category': skill.category,
            'tools': tool_names,
            'skill_type': skill.skill_type.value,
            'base_skills': skill.base_skills,
            'capabilities': skill.capabilities,
            'relevance_score': score,
            'trust_level': skill.trust_level.value,
        }
        if skill.skill_type == SkillType.COMPOSITE and skill.execution_mode:
            d['execution_mode'] = skill.execution_mode
        if skill.use_when:
            d['use_when'] = skill.use_when
        return d

    def filter_skills_by_capabilities(
        self,
        required_capabilities: List[str],
        filter_type: Optional[SkillType] = None,
        max_skills: int = 20
    ) -> List[Dict[str, Any]]:
        """
        Filter skills by required capabilities.

        Returns skills that match ANY of the required capabilities,
        sorted by relevance (more matching capabilities = higher priority).

        Args:
            required_capabilities: List of capabilities needed (e.g., ["data-fetch", "communicate"])
            filter_type: Optional SkillType to restrict results (default: None = all types)
            max_skills: Maximum number of skills to return (default: 20)

        Returns:
            List of skill dicts sorted by relevance
        """
        if not required_capabilities:
            return self.list_skills(filter_type=filter_type)[:max_skills]

        required_set = set(c.lower() for c in required_capabilities)
        scored_skills = []

        for skill in self.loaded_skills.values():
            if filter_type is not None and skill.skill_type != filter_type:
                continue

            # Calculate match score
            skill_caps = set(c.lower() for c in skill.capabilities)
            matching_caps = required_set & skill_caps
            score = len(matching_caps)

            # Skills with no capabilities defined get a low default score
            # (they might still be relevant)
            if not skill.capabilities:
                score = 0.1

            if score > 0:
                tool_names = list(skill._tools.keys()) if skill.is_loaded else []
                skill_dict = {
                    "name": skill.name,
                    "description": skill.description,
                    "tools": tool_names,
                    "metadata": skill.metadata,
                    "capabilities": skill.capabilities,
                    "skill_type": skill.skill_type.value,
                    "base_skills": skill.base_skills,
                    "_match_score": score,
                    "_matched_capabilities": list(matching_caps),
                }
                if skill.skill_type == SkillType.COMPOSITE:
                    skill_dict["execution_mode"] = skill.execution_mode
                if skill.use_when:
                    skill_dict["use_when"] = skill.use_when
                scored_skills.append((score, skill_dict))

        # Sort by score (descending) - higher score = more matching capabilities
        scored_skills.sort(key=lambda x: -x[0])

        # Return top skills
        return [s[1] for s in scored_skills[:max_skills]]

    def get_skill(self, name: str) -> Optional[SkillDefinition]:
        """Get a specific skill by name."""
        return self.loaded_skills.get(name)
    
    def load_collection(self, collection: 'ToolCollection', collection_name: Optional[str] = None) -> Dict[str, Callable]:
        """
        Load a tool collection into the registry.
        
        Args:
            collection: ToolCollection instance
            collection_name: Optional name for the collection (default: auto-generated)
            
        Returns:
            Dict mapping tool names to execute functions
            
        Example:
            from core.registry.tool_collection import ToolCollection
            
            collection = ToolCollection.from_hub("collection-slug", trust_remote_code=True)
            registry.load_collection(collection)
        """
        from .tool_collection import ToolCollection
        
        if not isinstance(collection, ToolCollection):
            raise TypeError(f"Expected ToolCollection, got {type(collection)}")
        
        # Generate collection name if not provided
        if collection_name is None:
            collection_name = f"collection_{len(self.loaded_collections)}"
        
        # Convert tools to SkillDefinitions
        skill_definitions = collection.to_skill_definitions()
        
        # Register each skill
        all_tools: Dict[str, Callable] = {}
        for skill_def in skill_definitions:
            if skill_def:
                # Add collection prefix to avoid conflicts
                prefixed_name = f"{collection_name}_{skill_def.name}"
                
                # Register skill
                self.loaded_skills[prefixed_name] = skill_def
                all_tools.update(skill_def.tools)
                
                logger.info(f"Loaded tool from collection: {prefixed_name}")
        
        # Store collection
        self.loaded_collections[collection_name] = {
            "collection": collection,
            "tools": all_tools,
            "source": collection.source,
            "metadata": collection.metadata
        }
        
        logger.info(f"Loaded collection '{collection_name}' with {len(skill_definitions)} tools")
        
        return all_tools
    
    def list_collections(self) -> List[Dict[str, Any]]:
        """
        List all loaded collections.
        
        Returns:
            List of collection metadata dicts
        """
        return [
            {
                "name": name,
                "source": info["source"],
                "tool_count": len(info["tools"]),
                "metadata": info["metadata"]
            }
            for name, info in self.loaded_collections.items()
        ]
    
    def get_collection(self, name: str) -> Optional[Dict[str, Any]]:
        """
        Get a loaded collection by name.
        
        Args:
            name: Collection name
            
        Returns:
            Collection info dict or None
        """
        return self.loaded_collections.get(name)
    
    # =============================================================================
    # Agent Conversion (Refactoring #4)
    # =============================================================================
    
    async def get_agent_for_skill(
        self,
        skill_name: str,
        agent_name: Optional[str] = None
    ):
        """
        Get or create AgentConfig for a skill.
        
        Args:
            skill_name: Name of skill
            agent_name: Optional custom agent name
            
        Returns:
            AgentConfig or None
        """
        try:
            from .skill_to_agent_converter import SkillToAgentConverter
            converter = SkillToAgentConverter()
            return await converter.create_agent_from_skill_name(skill_name, agent_name)
        except Exception as e:
            logger.warning(f"Failed to convert skill '{skill_name}' to agent: {e}")
            return None
    
    async def list_agents_from_skills(
        self,
        agent_name_prefix: Optional[str] = None
    ) -> List[Any]:
        """
        List all agents created from skills.
        
        Args:
            agent_name_prefix: Optional prefix for agent names
            
        Returns:
            List of AgentConfig
        """
        try:
            from .skill_to_agent_converter import SkillToAgentConverter
            converter = SkillToAgentConverter()
            
            skills = list(self.loaded_skills.values())
            return await converter.convert_skills_to_agents(skills, agent_name_prefix)
        except Exception as e:
            logger.warning(f"Failed to convert skills to agents: {e}")
            return []


# Singleton instance
_registry_instance: Optional[SkillsRegistry] = None


def get_skills_registry(skills_dir: Optional[str] = None) -> SkillsRegistry:
    """Get singleton skills registry instance (auto-initialized)."""
    global _registry_instance
    if _registry_instance is None:
        _registry_instance = SkillsRegistry(skills_dir)
        _registry_instance.init()  # Auto-initialize to load skills
    return _registry_instance
