"""
Skills Registry - DRY Implementation for Jotty Framework

Skills are dynamically loaded tools that extend agent capabilities.
This is framework-level infrastructure, reusable across all Jotty clients.

Architecture:
- Skills live in ~/jotty/skills/<name>/SKILL.md and tools.py
- Skills registry loads and registers tools dynamically
- Skills can be GENERATED by AI (like Clawd.bot) or manually written
- Tools integrate with existing Jotty tool system (no duplication)
- Clients (like JustJot.ai) use Jotty's skills system

Key Features:
- Load existing skills from disk
- Generate new skills using AI (via SkillGenerator)
- Hot-reload skills on changes
- Validate skills before registration

Note: This is framework code, not client-specific.
"""

import os
import json
import logging
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any, Callable
import importlib.util

logger = logging.getLogger(__name__)


class SkillDefinition:
    """Definition of a skill with its tools."""
    
    def __init__(
        self,
        name: str,
        description: str,
        tools: Dict[str, Callable],
        metadata: Optional[Dict[str, Any]] = None
    ):
        self.name = name
        self.description = description
        self.tools = tools  # {tool_name: execute_function}
        self.metadata = metadata or {}


class SkillsRegistry:
    """
    Skills Registry for Jotty Framework
    
    Loads skills from disk and registers tools dynamically.
    Integrates with Jotty's existing tool system (no duplication).
    
    Supports both:
    - Manual skills (written by developers)
    - AI-generated skills (created on-demand via SkillGenerator)
    """
    
    def __init__(self, skills_dir: Optional[str] = None, skill_generator=None):
        """
        Initialize skills registry.
        
        Args:
            skills_dir: Directory containing skills (default: ~/jotty/skills)
            skill_generator: Optional SkillGenerator for AI-powered skill creation
        """
        if skills_dir is None:
            # Priority: env var > repo-relative > user home
            skills_dir = os.getenv("JOTTY_SKILLS_DIR")
            
            if not skills_dir:
                # Try repo-relative (for development)
                # __file__ is core/registry/skills_registry.py
                # Go up: core/registry -> core -> Jotty -> skills
                current_file = Path(__file__).resolve()
                repo_root = current_file.parent.parent.parent  # core/registry -> core -> Jotty
                repo_skills = repo_root / "skills"
                if repo_skills.exists() or repo_root.name == "Jotty":
                    # Create if doesn't exist (we're in repo)
                    repo_skills.mkdir(exist_ok=True)
                    skills_dir = str(repo_skills)
                else:
                    # Fallback to user home (for installed packages)
                    home = os.path.expanduser("~")
                    skills_dir = os.path.join(home, "jotty", "skills")
        
        self.skills_dir = Path(skills_dir)
        self.skills_dir.mkdir(parents=True, exist_ok=True)
        
        # Also check Claude Code skills directory (~/.claude/skills)
        self.claude_skills_dir = Path.home() / ".claude" / "skills"
        
        self.loaded_skills: Dict[str, SkillDefinition] = {}
        self.composite_skills: Dict[str, Any] = {}  # Store composite skills
        self.initialized = False
        self.skill_generator = skill_generator  # For AI-powered skill generation
        
        # Dependency management
        from .skill_dependency_manager import get_dependency_manager
        self.dependency_manager = get_dependency_manager()
    
    def init(self) -> None:
        """Initialize and load all skills."""
        if self.initialized:
            return
        
        self.load_all_skills()
        self.initialized = True
        logger.info(f"SkillsRegistry initialized with {len(self.loaded_skills)} skills")
    
    def load_all_skills(self) -> Dict[str, Callable]:
        """
        Load all skills and return tools.
        
        Checks both ~/jotty/skills and ~/.claude/skills for compatibility.
        
        Returns:
            Dict mapping tool names to execute functions
            (can be merged into Jotty's tool registry)
        """
        all_tools: Dict[str, Callable] = {}
        
        # Load from Jotty skills directory
        if self.skills_dir.exists():
            for skill_dir in self.skills_dir.iterdir():
                if skill_dir.is_dir():
                    try:
                        skill = self._load_skill(skill_dir.name, self.skills_dir)
                        
                        # Auto-install dependencies if needed
                        dep_result = self.dependency_manager.ensure_skill_dependencies(
                            skill_dir.name, skill_dir
                        )
                        if dep_result["success"] and dep_result.get("installed"):
                            logger.info(f"✅ Installed dependencies for {skill_dir.name}: {dep_result['installed']}")
                        elif not dep_result["success"]:
                            logger.warning(f"⚠️  Dependency installation failed for {skill_dir.name}: {dep_result.get('error')}")
                        
                        all_tools.update(skill.tools)
                        self.loaded_skills[skill.name] = skill
                        logger.info(f"Loaded skill: {skill.name} ({len(skill.tools)} tools)")
                    except Exception as e:
                        logger.error(f"Failed to load skill {skill_dir.name}: {e}")
        else:
            logger.warning(f"Skills directory not found: {self.skills_dir}")
        
        # Load from Claude Code skills directory (~/.claude/skills)
        if self.claude_skills_dir.exists():
            for skill_dir in self.claude_skills_dir.iterdir():
                if skill_dir.is_dir():
                    try:
                        skill = self._load_skill(skill_dir.name, self.claude_skills_dir)
                        
                        # Skip if already loaded from Jotty directory
                        if skill.name in self.loaded_skills:
                            logger.debug(f"Skipping {skill.name} from Claude directory (already loaded from Jotty)")
                            continue
                        
                        all_tools.update(skill.tools)
                        self.loaded_skills[skill.name] = skill
                        logger.info(f"Loaded Claude Code skill: {skill.name} ({len(skill.tools)} tools)")
                    except Exception as e:
                        logger.error(f"Failed to load Claude Code skill {skill_dir.name}: {e}")
        
        return all_tools
    
    def _load_skill(self, skill_name: str, base_dir: Optional[Path] = None) -> SkillDefinition:
        """
        Load a single skill from disk.
        
        Args:
            skill_name: Name of skill directory
            base_dir: Base directory to load from (default: self.skills_dir)
            
        Returns:
            SkillDefinition with tools
        """
        if base_dir is None:
            base_dir = self.skills_dir
        
        skill_dir = base_dir / skill_name
        skill_md = skill_dir / "SKILL.md"
        tools_py = skill_dir / "tools.py"
        scripts_dir = skill_dir / "scripts"
        
        # Check if it's a Python-based Claude Code skill (has scripts/ directory)
        is_claude_code_skill = scripts_dir.exists() and scripts_dir.is_dir()
        
        if not tools_py.exists() and not is_claude_code_skill:
            raise FileNotFoundError(f"Skill {skill_name} missing tools.py and no scripts/ directory found")
        
        # Read SKILL.md for metadata
        description = ""
        if skill_md.exists():
            content = skill_md.read_text()
            # Extract description (simple parsing)
            for line in content.split("\n"):
                if "description" in line.lower() or "**Description**" in line:
                    desc_match = line.split(":", 1)
                    if len(desc_match) > 1:
                        description = desc_match[1].strip()
                    break
                # Also check for description in markdown format
                if line.startswith("# "):
                    # First heading is usually the title/description
                    if not description:
                        description = line[2:].strip()
        
        # Load tools
        if is_claude_code_skill:
            # Load Python-based Claude Code skill
            tools = self._load_claude_code_skill(skill_dir, skill_name, content if skill_md.exists() else "")
        elif tools_py.exists():
            # Load standard Python tools.py
            tools = self._load_tools_from_file(tools_py)
        else:
            tools = {}
        
        return SkillDefinition(
            name=skill_name,
            description=description or f"Skill: {skill_name}",
            tools=tools,
            metadata={"path": str(skill_dir), "is_claude_code_skill": is_claude_code_skill}
        )
    
    def _load_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Load tools from a Python file.
        
        For TypeScript/JavaScript skills, would need compilation step.
        This is a simplified version for Python tools.
        
        Args:
            tools_file: Path to tools.py file
            
        Returns:
            Dict mapping tool names to execute functions
        """
        tools: Dict[str, Callable] = {}
        
        try:
            # Add venv site-packages to sys.path if available
            import sys
            if hasattr(self, 'dependency_manager') and self.dependency_manager:
                venv_manager = self.dependency_manager.venv_manager
                if venv_manager and venv_manager.shared_venv_path:
                    # Detect Python version dynamically
                    python_version = f"{sys.version_info.major}.{sys.version_info.minor}"
                    venv_site_packages = venv_manager.shared_venv_path / 'lib' / f'python{python_version}' / 'site-packages'
                    
                    # If not found, try to find any pythonX.Y directory
                    if not venv_site_packages.exists():
                        lib_dir = venv_manager.shared_venv_path / 'lib'
                        if lib_dir.exists():
                            for subdir in lib_dir.iterdir():
                                if subdir.is_dir() and subdir.name.startswith('python'):
                                    potential_site_packages = subdir / 'site-packages'
                                    if potential_site_packages.exists():
                                        venv_site_packages = potential_site_packages
                                        break
                    
                    if venv_site_packages.exists() and str(venv_site_packages) not in sys.path:
                        sys.path.insert(0, str(venv_site_packages))
                        logger.debug(f"Added venv site-packages to sys.path: {venv_site_packages}")
            
            # Dynamically import the module
            spec = importlib.util.spec_from_file_location("skill_tools", tools_file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Extract tool functions (functions decorated with @tool or named *_tool)
                for attr_name in dir(module):
                    if not attr_name.startswith("_"):
                        attr = getattr(module, attr_name)
                        if callable(attr):
                            # Check if it's a tool (has execute method or is tool-like)
                            if hasattr(attr, "execute") or attr_name.endswith("_tool"):
                                tools[attr_name] = attr
        except Exception as e:
            logger.error(f"Error loading tools from {tools_file}: {e}")
            # Fallback: create mock tools based on file content
            tools = self._create_mock_tools_from_file(tools_file)
        
        return tools
    
    def _create_mock_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Create mock tools from file content (for testing/fallback).
        
        In production, proper tool loading would be used.
        This is for testing integration only.
        """
        content = tools_file.read_text()
        tools: Dict[str, Callable] = {}
        
        # Extract tool names from file (simplified)
        import re
        tool_matches = re.findall(r'def\s+(\w+)\s*\(|(\w+)\s*=\s*tool\(', content)
        
        for match in tool_matches:
            tool_name = match[0] or match[1]
            if tool_name:
                # Create mock execute function
                tools[tool_name] = self._create_mock_executor(tool_name)
        
        return tools
    
    def _create_mock_executor(self, tool_name: str) -> Callable:
        """Create mock executor for testing."""
        async def mock_execute(params: Dict[str, Any]) -> Dict[str, Any]:
            return {
                "success": True,
                "tool": tool_name,
                "params": params,
                "message": f"Tool {tool_name} executed (mock - implement in tools.py)",
            }
        return mock_execute
    
    def _load_claude_code_skill(self, skill_dir: Path, skill_name: str, skill_md_content: str) -> Dict[str, Callable]:
        """
        Load Python-based Claude Code skill (e.g., last30days).
        
        Claude Code skills have Python scripts in scripts/ directory instead of tools.py.
        This method creates wrapper tools that execute the Python scripts.
        
        Args:
            skill_dir: Skill directory path
            skill_name: Skill name
            skill_md_content: Content of SKILL.md for metadata extraction
            
        Returns:
            Dict mapping tool names to execute functions
        """
        tools: Dict[str, Callable] = {}
        scripts_dir = skill_dir / "scripts"
        
        if not scripts_dir.exists():
            logger.warning(f"Claude Code skill {skill_name} has no scripts/ directory")
            return tools
        
        # Look for main script (skill_name.py) or any .py files
        main_script = scripts_dir / f"{skill_name}.py"
        
        if main_script.exists():
            # Create wrapper tool for main script
            tool_name = skill_name.replace("-", "_")
            tools[tool_name] = self._create_claude_code_executor(main_script, skill_dir, skill_md_content)
        else:
            # Look for other Python scripts
            for script_file in scripts_dir.glob("*.py"):
                tool_name = script_file.stem.replace("-", "_")
                tools[tool_name] = self._create_claude_code_executor(script_file, skill_dir, skill_md_content)
        
        return tools
    
    def _create_claude_code_executor(self, script_path: Path, skill_dir: Path, skill_md_content: str) -> Callable:
        """
        Create executor function for Claude Code Python script.
        
        Args:
            script_path: Path to Python script
            skill_dir: Skill directory
            skill_md_content: SKILL.md content for description extraction
            
        Returns:
            Callable tool executor function
        """
        async def execute_claude_code_skill(params: Dict[str, Any]) -> Dict[str, Any]:
            """
            Execute Claude Code Python skill script.
            
            Supports common parameters:
            - topic: Research topic
            - tool: Target tool (e.g., "ChatGPT")
            - quick: Faster research
            - deep: Comprehensive research
            - sources: Source selection (auto, reddit, x, both)
            - emit: Output format (compact, json, md, context, path)
            - refresh: Bypass cache
            """
            try:
                # Build command arguments
                args = []
                
                if params.get("topic"):
                    args.append(f'"{params["topic"]}"')
                
                if params.get("tool"):
                    args.append(f'for {params["tool"]}')
                
                if params.get("quick"):
                    args.append("--quick")
                
                if params.get("deep"):
                    args.append("--deep")
                
                if params.get("sources"):
                    args.append(f"--sources={params['sources']}")
                
                if params.get("emit"):
                    args.append(f"--emit={params['emit']}")
                
                if params.get("refresh"):
                    args.append("--refresh")
                
                # Execute Python script
                cmd = ["python3", str(script_path)] + args
                
                result = subprocess.run(
                    cmd,
                    cwd=str(skill_dir),
                    capture_output=True,
                    text=True,
                    timeout=120,  # 2 minutes timeout
                )
                
                if result.returncode != 0:
                    logger.error(f"Claude Code skill execution failed: {result.stderr}")
                    return {
                        "success": False,
                        "error": result.stderr or "Script execution failed",
                        "stdout": result.stdout,
                    }
                
                # Parse output based on emit format
                if params.get("emit") == "json":
                    try:
                        output = json.loads(result.stdout)
                        return {"success": True, **output}
                    except json.JSONDecodeError:
                        return {
                            "success": True,
                            "output": result.stdout,
                            "format": "json",
                            "raw": True,
                        }
                
                return {
                    "success": True,
                    "output": result.stdout,
                    "format": params.get("emit", "compact"),
                }
            except subprocess.TimeoutExpired:
                return {
                    "success": False,
                    "error": "Script execution timed out (120s limit)",
                }
            except Exception as e:
                logger.error(f"Error executing Claude Code skill: {e}")
                return {
                    "success": False,
                    "error": str(e),
                }
        
        return execute_claude_code_skill
    
    def get_registered_tools(self) -> Dict[str, Callable]:
        """
        Get all registered tools from loaded skills.
        
        Returns:
            Dict mapping tool names to execute functions
            (for merging into Jotty's tool registry)
        """
        tools: Dict[str, Callable] = {}
        for skill in self.loaded_skills.values():
            tools.update(skill.tools)
        
        # Add package management tools
        from .skill_package_tools import create_package_management_tools
        from .skill_venv_manager import get_venv_manager
        venv_manager = get_venv_manager()
        package_tools = create_package_management_tools(venv_manager)
        tools.update(package_tools)
        
        return tools
    
    def get_tool_metadata(self) -> Dict[str, Dict[str, str]]:
        """
        Get tool metadata for all skill tools.
        
        Returns:
            Dict mapping tool names to metadata
            (for merging into Jotty's tool metadata)
        """
        metadata: Dict[str, Dict[str, str]] = {}
        
        for skill in self.loaded_skills.values():
            for tool_name in skill.tools.keys():
                metadata[tool_name] = {
                    "category": "skill",
                    "description": f"Tool from skill: {skill.name}",
                    "skill": skill.name,
                }
        
        return metadata
    
    def list_skills(self) -> List[Dict[str, Any]]:
        """List all loaded skills."""
        return [
            {
                "name": skill.name,
                "description": skill.description,
                "tools": list(skill.tools.keys()),
                "metadata": skill.metadata,
            }
            for skill in self.loaded_skills.values()
        ]
    
    def get_skill(self, name: str) -> Optional[SkillDefinition]:
        """Get a specific skill by name."""
        return self.loaded_skills.get(name)


# Singleton instance
_registry_instance: Optional[SkillsRegistry] = None


def get_skills_registry(skills_dir: Optional[str] = None) -> SkillsRegistry:
    """Get singleton skills registry instance."""
    global _registry_instance
    if _registry_instance is None:
        _registry_instance = SkillsRegistry(skills_dir)
    return _registry_instance
