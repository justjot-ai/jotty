"""
Skills Registry - DRY Implementation for Jotty Framework

Skills are dynamically loaded tools that extend agent capabilities.
This is framework-level infrastructure, reusable across all Jotty clients.

Architecture:
- Skills live in ~/jotty/skills/<name>/SKILL.md and tools.py
- Skills registry loads and registers tools dynamically
- Skills can be GENERATED by AI (like Clawd.bot) or manually written
- Tools integrate with existing Jotty tool system (no duplication)
- Clients (like JustJot.ai) use Jotty's skills system

Key Features:
- Load existing skills from disk
- Generate new skills using AI (via SkillGenerator)
- Hot-reload skills on changes
- Validate skills before registration

Note: This is framework code, not client-specific.
"""

import os
import json
import logging
from pathlib import Path
from typing import Dict, List, Optional, Any, Callable
import importlib.util

logger = logging.getLogger(__name__)


class SkillDefinition:
    """Definition of a skill with its tools."""
    
    def __init__(
        self,
        name: str,
        description: str,
        tools: Dict[str, Callable],
        metadata: Optional[Dict[str, Any]] = None
    ):
        self.name = name
        self.description = description
        self.tools = tools  # {tool_name: execute_function}
        self.metadata = metadata or {}


class SkillsRegistry:
    """
    Skills Registry for Jotty Framework
    
    Loads skills from disk and registers tools dynamically.
    Integrates with Jotty's existing tool system (no duplication).
    
    Supports both:
    - Manual skills (written by developers)
    - AI-generated skills (created on-demand via SkillGenerator)
    """
    
    def __init__(self, skills_dir: Optional[str] = None, skill_generator=None):
        """
        Initialize skills registry.
        
        Args:
            skills_dir: Directory containing skills (default: ~/jotty/skills)
            skill_generator: Optional SkillGenerator for AI-powered skill creation
        """
        if skills_dir is None:
            # Priority: env var > repo-relative > user home
            skills_dir = os.getenv("JOTTY_SKILLS_DIR")
            
            if not skills_dir:
                # Try repo-relative (for development)
                # __file__ is core/registry/skills_registry.py
                # Go up: core/registry -> core -> Jotty -> skills
                current_file = Path(__file__).resolve()
                repo_root = current_file.parent.parent.parent  # core/registry -> core -> Jotty
                repo_skills = repo_root / "skills"
                if repo_skills.exists() or repo_root.name == "Jotty":
                    # Create if doesn't exist (we're in repo)
                    repo_skills.mkdir(exist_ok=True)
                    skills_dir = str(repo_skills)
                else:
                    # Fallback to user home (for installed packages)
                    home = os.path.expanduser("~")
                    skills_dir = os.path.join(home, "jotty", "skills")
        
        self.skills_dir = Path(skills_dir)
        self.skills_dir.mkdir(parents=True, exist_ok=True)
        
        self.loaded_skills: Dict[str, SkillDefinition] = {}
        self.initialized = False
        self.skill_generator = skill_generator  # For AI-powered skill generation
        
        # Dependency management
        from .skill_dependency_manager import get_dependency_manager
        self.dependency_manager = get_dependency_manager()
        
        # Dependency management
        from .skill_dependency_manager import get_dependency_manager
        self.dependency_manager = get_dependency_manager()
    
    def init(self) -> None:
        """Initialize and load all skills."""
        if self.initialized:
            return
        
        self.load_all_skills()
        self.initialized = True
        logger.info(f"SkillsRegistry initialized with {len(self.loaded_skills)} skills")
    
    def load_all_skills(self) -> Dict[str, Callable]:
        """
        Load all skills and return tools.
        
        Returns:
            Dict mapping tool names to execute functions
            (can be merged into Jotty's tool registry)
        """
        all_tools: Dict[str, Callable] = {}
        
        if not self.skills_dir.exists():
            logger.warning(f"Skills directory not found: {self.skills_dir}")
            return all_tools
        
        for skill_dir in self.skills_dir.iterdir():
            if skill_dir.is_dir():
                try:
                    skill = self._load_skill(skill_dir.name)
                    
                    # Auto-install dependencies if needed
                    dep_result = self.dependency_manager.ensure_skill_dependencies(
                        skill_dir.name, skill_dir
                    )
                    if dep_result["success"] and dep_result.get("installed"):
                        logger.info(f"✅ Installed dependencies for {skill_dir.name}: {dep_result['installed']}")
                    elif not dep_result["success"]:
                        logger.warning(f"⚠️  Dependency installation failed for {skill_dir.name}: {dep_result.get('error')}")
                    
                    all_tools.update(skill.tools)
                    self.loaded_skills[skill.name] = skill
                    logger.info(f"Loaded skill: {skill.name} ({len(skill.tools)} tools)")
                except Exception as e:
                    logger.error(f"Failed to load skill {skill_dir.name}: {e}")
        
        return all_tools
    
    def _load_skill(self, skill_name: str) -> SkillDefinition:
        """
        Load a single skill from disk.
        
        Args:
            skill_name: Name of skill directory
            
        Returns:
            SkillDefinition with tools
        """
        skill_dir = self.skills_dir / skill_name
        skill_md = skill_dir / "SKILL.md"
        tools_py = skill_dir / "tools.py"
        
        if not tools_py.exists():
            raise FileNotFoundError(f"Skill {skill_name} missing tools.py")
        
        # Read SKILL.md for metadata
        description = ""
        if skill_md.exists():
            content = skill_md.read_text()
            # Extract description (simple parsing)
            for line in content.split("\n"):
                if "description" in line.lower() or "**Description**" in line:
                    desc_match = line.split(":", 1)
                    if len(desc_match) > 1:
                        description = desc_match[1].strip()
                    break
        
        # Load tools.py
        # In production, this would compile TS/JS or use proper Python imports
        tools = self._load_tools_from_file(tools_py)
        
        return SkillDefinition(
            name=skill_name,
            description=description or f"Skill: {skill_name}",
            tools=tools,
            metadata={"path": str(skill_dir)}
        )
    
    def _load_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Load tools from a Python file.
        
        For TypeScript/JavaScript skills, would need compilation step.
        This is a simplified version for Python tools.
        
        Args:
            tools_file: Path to tools.py file
            
        Returns:
            Dict mapping tool names to execute functions
        """
        tools: Dict[str, Callable] = {}
        
        try:
            # Dynamically import the module
            spec = importlib.util.spec_from_file_location("skill_tools", tools_file)
            if spec and spec.loader:
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                
                # Extract tool functions (functions decorated with @tool or named *_tool)
                for attr_name in dir(module):
                    if not attr_name.startswith("_"):
                        attr = getattr(module, attr_name)
                        if callable(attr):
                            # Check if it's a tool (has execute method or is tool-like)
                            if hasattr(attr, "execute") or attr_name.endswith("_tool"):
                                tools[attr_name] = attr
        except Exception as e:
            logger.error(f"Error loading tools from {tools_file}: {e}")
            # Fallback: create mock tools based on file content
            tools = self._create_mock_tools_from_file(tools_file)
        
        return tools
    
    def _create_mock_tools_from_file(self, tools_file: Path) -> Dict[str, Callable]:
        """
        Create mock tools from file content (for testing/fallback).
        
        In production, proper tool loading would be used.
        This is for testing integration only.
        """
        content = tools_file.read_text()
        tools: Dict[str, Callable] = {}
        
        # Extract tool names from file (simplified)
        import re
        tool_matches = re.findall(r'def\s+(\w+)\s*\(|(\w+)\s*=\s*tool\(', content)
        
        for match in tool_matches:
            tool_name = match[0] or match[1]
            if tool_name:
                # Create mock execute function
                tools[tool_name] = self._create_mock_executor(tool_name)
        
        return tools
    
    def _create_mock_executor(self, tool_name: str) -> Callable:
        """Create mock executor for testing."""
        async def mock_execute(params: Dict[str, Any]) -> Dict[str, Any]:
            return {
                "success": True,
                "tool": tool_name,
                "params": params,
                "message": f"Tool {tool_name} executed (mock - implement in tools.py)",
            }
        return mock_execute
    
    def get_registered_tools(self) -> Dict[str, Callable]:
        """
        Get all registered tools from loaded skills.
        
        Returns:
            Dict mapping tool names to execute functions
            (for merging into Jotty's tool registry)
        """
        tools: Dict[str, Callable] = {}
        for skill in self.loaded_skills.values():
            tools.update(skill.tools)
        
        # Add package management tools
        from .skill_package_tools import create_package_management_tools
        from .skill_venv_manager import get_venv_manager
        venv_manager = get_venv_manager()
        package_tools = create_package_management_tools(venv_manager)
        tools.update(package_tools)
        
        return tools
    
    def get_tool_metadata(self) -> Dict[str, Dict[str, str]]:
        """
        Get tool metadata for all skill tools.
        
        Returns:
            Dict mapping tool names to metadata
            (for merging into Jotty's tool metadata)
        """
        metadata: Dict[str, Dict[str, str]] = {}
        
        for skill in self.loaded_skills.values():
            for tool_name in skill.tools.keys():
                metadata[tool_name] = {
                    "category": "skill",
                    "description": f"Tool from skill: {skill.name}",
                    "skill": skill.name,
                }
        
        return metadata
    
    def list_skills(self) -> List[Dict[str, Any]]:
        """List all loaded skills."""
        return [
            {
                "name": skill.name,
                "description": skill.description,
                "tools": list(skill.tools.keys()),
                "metadata": skill.metadata,
            }
            for skill in self.loaded_skills.values()
        ]
    
    def get_skill(self, name: str) -> Optional[SkillDefinition]:
        """Get a specific skill by name."""
        return self.loaded_skills.get(name)


# Singleton instance
_registry_instance: Optional[SkillsRegistry] = None


def get_skills_registry(skills_dir: Optional[str] = None) -> SkillsRegistry:
    """Get singleton skills registry instance."""
    global _registry_instance
    if _registry_instance is None:
        _registry_instance = SkillsRegistry(skills_dir)
    return _registry_instance
